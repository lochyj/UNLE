/*!
 * PixiJS - v8.0.0-beta.10
 * Compiled Mon, 20 Nov 2023 10:39:01 UTC
 *
 * PixiJS is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
*/class Point{constructor(X=0,K=0){this.x=0,this.y=0,this.x=X,this.y=K}clone(){return new Point(this.x,this.y)}copyFrom(X){return this.set(X.x,X.y),this}copyTo(X){return X.set(this.x,this.y),X}equals(X){return X.x===this.x&&X.y===this.y}set(X=0,K=X){return this.x=X,this.y=K,this}static get shared(){return e$d.x=0,e$d.y=0,e$d}}const e$d=new Point;class FederatedEvent{constructor(X){this.bubbles=!0,this.cancelBubble=!0,this.cancelable=!1,this.composed=!1,this.defaultPrevented=!1,this.eventPhase=FederatedEvent.prototype.NONE,this.propagationStopped=!1,this.propagationImmediatelyStopped=!1,this.layer=new Point,this.page=new Point,this.NONE=0,this.CAPTURING_PHASE=1,this.AT_TARGET=2,this.BUBBLING_PHASE=3,this.manager=X}get layerX(){return this.layer.x}get layerY(){return this.layer.y}get pageX(){return this.page.x}get pageY(){return this.page.y}get data(){return this}composedPath(){return this.manager&&(!this.path||this.path[this.path.length-1]!==this.target)&&(this.path=this.target?this.manager.propagationPath(this.target):[]),this.path}initEvent(X,K,J){throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")}initUIEvent(X,K,J,Q,ee){throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")}preventDefault(){this.nativeEvent instanceof Event&&this.nativeEvent.cancelable&&this.nativeEvent.preventDefault(),this.defaultPrevented=!0}stopImmediatePropagation(){this.propagationImmediatelyStopped=!0}stopPropagation(){this.propagationStopped=!0}}var f$w=Object.defineProperty,h$u=Object.defineProperties,E$7=Object.getOwnPropertyDescriptors,c$z=Object.getOwnPropertySymbols,y$o=Object.prototype.hasOwnProperty,v$8=Object.prototype.propertyIsEnumerable,m$C=(Z,X,K)=>X in Z?f$w(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,d$q=(Z,X)=>{for(var K in X||(X={}))y$o.call(X,K)&&m$C(Z,K,X[K]);if(c$z)for(var K of c$z(X))v$8.call(X,K)&&m$C(Z,K,X[K]);return Z},l$w=(Z,X)=>h$u(Z,E$7(X)),u$v=(Z=>(Z.Application="application",Z.WebGLPipes="webgl-pipes",Z.WebGLPipesAdaptor="webgl-pipes-adaptor",Z.WebGLSystem="webgl-system",Z.WebGPUPipes="webgpu-pipes",Z.WebGPUPipesAdaptor="webgpu-pipes-adaptor",Z.WebGPUSystem="webgpu-system",Z.CanvasSystem="canvas-system",Z.CanvasPipesAdaptor="canvas-pipes-adaptor",Z.CanvasPipes="canvas-pipes",Z.Asset="asset",Z.LoadParser="load-parser",Z.ResolveParser="resolve-parser",Z.CacheParser="cache-parser",Z.DetectionParser="detection-parser",Z.MaskEffect="mask-effect",Z.BlendMode="blend-mode",Z.TextureSource="texture-source",Z.Environment="environment",Z))(u$v||{});const p$K=Z=>{if(typeof Z=="function"||typeof Z=="object"&&Z.extension){const X=typeof Z.extension!="object"?{type:Z.extension}:Z.extension;Z=l$w(d$q({},X),{ref:Z})}if(typeof Z=="object")Z=d$q({},Z);else throw new Error("Invalid extension type");return typeof Z.type=="string"&&(Z.type=[Z.type]),Z},normalizeExtensionPriority=(Z,X)=>{var K;return(K=p$K(Z).priority)!=null?K:X},b$p={_addHandlers:{},_removeHandlers:{},_queue:{},remove(...Z){return Z.map(p$K).forEach(X=>{X.type.forEach(K=>{var J,Q;return(Q=(J=this._removeHandlers)[K])==null?void 0:Q.call(J,X)})}),this},add(...Z){return Z.map(p$K).forEach(X=>{X.type.forEach(K=>{const J=this._addHandlers,Q=this._queue;J[K]?J[K](X):(Q[K]=Q[K]||[],Q[K].push(X))})}),this},handle(Z,X,K){const J=this._addHandlers,Q=this._removeHandlers;J[Z]=X,Q[Z]=K;const ee=this._queue;return ee[Z]&&(ee[Z].forEach(te=>X(te)),delete ee[Z]),this},handleByMap(Z,X){return this.handle(Z,K=>{X[K.name]=K.ref},K=>{delete X[K.name]})},handleByNamedList(Z,X,K=-1){return this.handle(Z,J=>{X.findIndex(Q=>Q.name===J.name)>=0||(X.push({name:J.name,value:J.ref}),X.sort((Q,ee)=>normalizeExtensionPriority(ee.value,K)-normalizeExtensionPriority(Q.value,K)))},J=>{const Q=X.findIndex(ee=>ee.name===J.name);Q!==-1&&X.splice(Q,1)})},handleByList(Z,X,K=-1){return this.handle(Z,J=>{X.includes(J.ref)||(X.push(J.ref),X.sort((Q,ee)=>normalizeExtensionPriority(ee,K)-normalizeExtensionPriority(Q,K)))},J=>{const Q=X.indexOf(J.ref);Q!==-1&&X.splice(Q,1)})}};var appleIphone=/iPhone/i,appleIpod=/iPod/i,appleTablet=/iPad/i,appleUniversal=/\biOS-universal(?:.+)Mac\b/i,androidPhone=/\bAndroid(?:.+)Mobile\b/i,androidTablet=/Android/i,amazonPhone=/(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,amazonTablet=/Silk/i,windowsPhone=/Windows Phone/i,windowsTablet=/\bWindows(?:.+)ARM\b/i,otherBlackBerry=/BlackBerry/i,otherBlackBerry10=/BB10/i,otherOpera=/Opera Mini/i,otherChrome=/\b(CriOS|Chrome)(?:.+)Mobile/i,otherFirefox=/Mobile(?:.+)Firefox\b/i,isAppleTabletOnIos13=function(Z){return typeof Z!="undefined"&&Z.platform==="MacIntel"&&typeof Z.maxTouchPoints=="number"&&Z.maxTouchPoints>1&&typeof MSStream=="undefined"};function createMatch(Z){return function(X){return X.test(Z)}}function isMobile$1(Z){var X={userAgent:"",platform:"",maxTouchPoints:0};!Z&&typeof navigator!="undefined"?X={userAgent:navigator.userAgent,platform:navigator.platform,maxTouchPoints:navigator.maxTouchPoints||0}:typeof Z=="string"?X.userAgent=Z:Z&&Z.userAgent&&(X={userAgent:Z.userAgent,platform:Z.platform,maxTouchPoints:Z.maxTouchPoints||0});var K=X.userAgent,J=K.split("[FBAN");typeof J[1]!="undefined"&&(K=J[0]),J=K.split("Twitter"),typeof J[1]!="undefined"&&(K=J[0]);var Q=createMatch(K),ee={apple:{phone:Q(appleIphone)&&!Q(windowsPhone),ipod:Q(appleIpod),tablet:!Q(appleIphone)&&(Q(appleTablet)||isAppleTabletOnIos13(X))&&!Q(windowsPhone),universal:Q(appleUniversal),device:(Q(appleIphone)||Q(appleIpod)||Q(appleTablet)||Q(appleUniversal)||isAppleTabletOnIos13(X))&&!Q(windowsPhone)},amazon:{phone:Q(amazonPhone),tablet:!Q(amazonPhone)&&Q(amazonTablet),device:Q(amazonPhone)||Q(amazonTablet)},android:{phone:!Q(windowsPhone)&&Q(amazonPhone)||!Q(windowsPhone)&&Q(androidPhone),tablet:!Q(windowsPhone)&&!Q(amazonPhone)&&!Q(androidPhone)&&(Q(amazonTablet)||Q(androidTablet)),device:!Q(windowsPhone)&&(Q(amazonPhone)||Q(amazonTablet)||Q(androidPhone)||Q(androidTablet))||Q(/\bokhttp\b/i)},windows:{phone:Q(windowsPhone),tablet:Q(windowsTablet),device:Q(windowsPhone)||Q(windowsTablet)},other:{blackberry:Q(otherBlackBerry),blackberry10:Q(otherBlackBerry10),opera:Q(otherOpera),firefox:Q(otherFirefox),chrome:Q(otherChrome),device:Q(otherBlackBerry)||Q(otherBlackBerry10)||Q(otherOpera)||Q(otherFirefox)||Q(otherChrome)},any:!1,phone:!1,tablet:!1};return ee.any=ee.apple.device||ee.android.device||ee.windows.device||ee.other.device,ee.phone=ee.apple.phone||ee.android.phone||ee.windows.phone,ee.tablet=ee.apple.tablet||ee.android.tablet||ee.windows.tablet,ee}var e$c;const l$v=(e$c=isMobile$1.default)!=null?e$c:isMobile$1,isMobile=l$v(globalThis.navigator);function removeItems(Z,X,K){const J=Z.length;let Q;if(X>=J||K===0)return;K=X+K>J?J-X:K;const ee=J-K;for(Q=X;Q<ee;++Q)Z[Q]=Z[Q+K];Z.length=ee}const T$c=9,v$7=100,w$7=0,D$2=0,y$n=2,m$B=1,H$8=-1e3,I$8=-1e3,M$7=2;class AccessibilitySystem{constructor(X,K=isMobile){this._mobileInfo=K,this.debug=!1,this._isActive=!1,this._isMobileAccessibility=!1,this._pool=[],this._renderId=0,this._children=[],this._androidUpdateCount=0,this._androidUpdateFrequency=500,this._hookDiv=null,(K.tablet||K.phone)&&this._createTouchHook();const J=document.createElement("div");J.style.width=`${v$7}px`,J.style.height=`${v$7}px`,J.style.position="absolute",J.style.top=`${w$7}px`,J.style.left=`${D$2}px`,J.style.zIndex=y$n.toString(),this._div=J,this._renderer=X,this._onKeyDown=this._onKeyDown.bind(this),this._onMouseMove=this._onMouseMove.bind(this),globalThis.addEventListener("keydown",this._onKeyDown,!1)}get isActive(){return this._isActive}get isMobileAccessibility(){return this._isMobileAccessibility}get hookDiv(){return this._hookDiv}_createTouchHook(){const X=document.createElement("button");X.style.width=`${m$B}px`,X.style.height=`${m$B}px`,X.style.position="absolute",X.style.top=`${H$8}px`,X.style.left=`${I$8}px`,X.style.zIndex=M$7.toString(),X.style.backgroundColor="#FF0000",X.title="select to enable accessibility for this content",X.addEventListener("focus",()=>{this._isMobileAccessibility=!0,this._activate(),this._destroyTouchHook()}),document.body.appendChild(X),this._hookDiv=X}_destroyTouchHook(){this._hookDiv&&(document.body.removeChild(this._hookDiv),this._hookDiv=null)}_activate(){var X;this._isActive||(this._isActive=!0,globalThis.document.addEventListener("mousemove",this._onMouseMove,!0),globalThis.removeEventListener("keydown",this._onKeyDown,!1),this._renderer.runners.postrender.add(this),(X=this._renderer.view.canvas.parentNode)==null||X.appendChild(this._div))}_deactivate(){var X;!this._isActive||this._isMobileAccessibility||(this._isActive=!1,globalThis.document.removeEventListener("mousemove",this._onMouseMove,!0),globalThis.addEventListener("keydown",this._onKeyDown,!1),this._renderer.runners.postrender.remove(this),(X=this._div.parentNode)==null||X.removeChild(this._div))}_updateAccessibleObjects(X){if(!X.visible||!X.accessibleChildren)return;X.accessible&&X.isInteractive()&&(X._accessibleActive||this._addChild(X),X._renderId=this._renderId);const K=X.children;if(K)for(let J=0;J<K.length;J++)this._updateAccessibleObjects(K[J])}init(X){var K;this.debug=(K=X==null?void 0:X.debug)!=null?K:this.debug,this._renderer.runners.postrender.remove(this)}postrender(){const X=performance.now();if(this._mobileInfo.android.device&&X<this._androidUpdateCount||(this._androidUpdateCount=X+this._androidUpdateFrequency,!this._renderer.renderingToScreen||!this._renderer.view.canvas))return;this._renderer.lastObjectRendered&&this._updateAccessibleObjects(this._renderer.lastObjectRendered);const{x:K,y:J,width:Q,height:ee}=this._renderer.view.canvas.getBoundingClientRect(),{width:te,height:re,resolution:ie}=this._renderer,ne=Q/te*ie,se=ee/re*ie;let oe=this._div;oe.style.left=`${K}px`,oe.style.top=`${J}px`,oe.style.width=`${te}px`,oe.style.height=`${re}px`;for(let ae=0;ae<this._children.length;ae++){const le=this._children[ae];if(le._renderId!==this._renderId)le._accessibleActive=!1,removeItems(this._children,ae,1),this._div.removeChild(le._accessibleDiv),this._pool.push(le._accessibleDiv),le._accessibleDiv=null,ae--;else{oe=le._accessibleDiv;let ce=le.hitArea;const de=le.worldTransform;le.hitArea?(oe.style.left=`${(de.tx+ce.x*de.a)*ne}px`,oe.style.top=`${(de.ty+ce.y*de.d)*se}px`,oe.style.width=`${ce.width*de.a*ne}px`,oe.style.height=`${ce.height*de.d*se}px`):(ce=le.getBounds(),this._capHitArea(ce),oe.style.left=`${ce.x*ne}px`,oe.style.top=`${ce.y*se}px`,oe.style.width=`${ce.width*ne}px`,oe.style.height=`${ce.height*se}px`,oe.title!==le.accessibleTitle&&le.accessibleTitle!==null&&(oe.title=le.accessibleTitle),oe.getAttribute("aria-label")!==le.accessibleHint&&le.accessibleHint!==null&&oe.setAttribute("aria-label",le.accessibleHint)),(le.accessibleTitle!==oe.title||le.tabIndex!==oe.tabIndex)&&(oe.title=le.accessibleTitle,oe.tabIndex=le.tabIndex,this.debug&&this._updateDebugHTML(oe))}}this._renderId++}_updateDebugHTML(X){X.innerHTML=`type: ${X.type}</br> title : ${X.title}</br> tabIndex: ${X.tabIndex}`}_capHitArea(X){X.x<0&&(X.width+=X.x,X.x=0),X.y<0&&(X.height+=X.y,X.y=0);const{width:K,height:J}=this._renderer;X.x+X.width>K&&(X.width=K-X.x),X.y+X.height>J&&(X.height=J-X.y)}_addChild(X){let K=this._pool.pop();K||(K=document.createElement("button"),K.style.width=`${v$7}px`,K.style.height=`${v$7}px`,K.style.backgroundColor=this.debug?"rgba(255,255,255,0.5)":"transparent",K.style.position="absolute",K.style.zIndex=y$n.toString(),K.style.borderStyle="none",navigator.userAgent.toLowerCase().includes("chrome")?K.setAttribute("aria-live","off"):K.setAttribute("aria-live","polite"),navigator.userAgent.match(/rv:.*Gecko\//)?K.setAttribute("aria-relevant","additions"):K.setAttribute("aria-relevant","text"),K.addEventListener("click",this._onClick.bind(this)),K.addEventListener("focus",this._onFocus.bind(this)),K.addEventListener("focusout",this._onFocusOut.bind(this))),K.style.pointerEvents=X.accessiblePointerEvents,K.type=X.accessibleType,X.accessibleTitle&&X.accessibleTitle!==null?K.title=X.accessibleTitle:(!X.accessibleHint||X.accessibleHint===null)&&(K.title=`container ${X.tabIndex}`),X.accessibleHint&&X.accessibleHint!==null&&K.setAttribute("aria-label",X.accessibleHint),this.debug&&this._updateDebugHTML(K),X._accessibleActive=!0,X._accessibleDiv=K,K.container=X,this._children.push(X),this._div.appendChild(X._accessibleDiv),X._accessibleDiv.tabIndex=X.tabIndex}_dispatchEvent(X,K){const{container:J}=X.target,Q=this._renderer.events.rootBoundary,ee=Object.assign(new FederatedEvent(Q),{target:J});Q.rootTarget=this._renderer.lastObjectRendered,K.forEach(te=>Q.dispatchEvent(ee,te))}_onClick(X){this._dispatchEvent(X,["click","pointertap","tap"])}_onFocus(X){X.target.getAttribute("aria-live")||X.target.setAttribute("aria-live","assertive"),this._dispatchEvent(X,["mouseover"])}_onFocusOut(X){X.target.getAttribute("aria-live")||X.target.setAttribute("aria-live","polite"),this._dispatchEvent(X,["mouseout"])}_onKeyDown(X){X.keyCode===T$c&&this._activate()}_onMouseMove(X){X.movementX===0&&X.movementY===0||this._deactivate()}destroy(){this._destroyTouchHook(),this._div=null,globalThis.document.removeEventListener("mousemove",this._onMouseMove,!0),globalThis.removeEventListener("keydown",this._onKeyDown),this._pool=null,this._children=null,this._renderer=null}}AccessibilitySystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem],name:"accessibility"},b$p.add(AccessibilitySystem);const accessibilityTarget={accessible:!1,accessibleTitle:null,accessibleHint:null,tabIndex:0,_accessibleActive:!1,_accessibleDiv:null,accessibleType:"button",accessiblePointerEvents:"auto",accessibleChildren:!0,_renderId:-1};var commonjsGlobal=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function getDefaultExportFromCjs(Z){return Z&&Z.__esModule&&Object.prototype.hasOwnProperty.call(Z,"default")?Z.default:Z}function createCommonjsModule(Z,X,K){return K={path:X,exports:{},require:function(J,Q){return commonjsRequire(J,Q==null?K.path:Q)}},Z(K,K.exports),K.exports}function getDefaultExportFromNamespaceIfPresent(Z){return Z&&Object.prototype.hasOwnProperty.call(Z,"default")?Z.default:Z}function getDefaultExportFromNamespaceIfNotNamed(Z){return Z&&Object.prototype.hasOwnProperty.call(Z,"default")&&Object.keys(Z).length===1?Z.default:Z}function getAugmentedNamespace(Z){if(Z.__esModule)return Z;var X=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(Z).forEach(function(K){var J=Object.getOwnPropertyDescriptor(Z,K);Object.defineProperty(X,K,J.get?J:{enumerable:!0,get:function(){return Z[K]}})}),X}function commonjsRequire(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}var eventemitter3=createCommonjsModule(function(Z){"use strict";var X=Object.prototype.hasOwnProperty,K="~";function J(){}Object.create&&(J.prototype=Object.create(null),new J().__proto__||(K=!1));function Q(ie,ne,se){this.fn=ie,this.context=ne,this.once=se||!1}function ee(ie,ne,se,oe,ae){if(typeof se!="function")throw new TypeError("The listener must be a function");var le=new Q(se,oe||ie,ae),ce=K?K+ne:ne;return ie._events[ce]?ie._events[ce].fn?ie._events[ce]=[ie._events[ce],le]:ie._events[ce].push(le):(ie._events[ce]=le,ie._eventsCount++),ie}function te(ie,ne){--ie._eventsCount===0?ie._events=new J:delete ie._events[ne]}function re(){this._events=new J,this._eventsCount=0}re.prototype.eventNames=function(){var ne=[],se,oe;if(this._eventsCount===0)return ne;for(oe in se=this._events)X.call(se,oe)&&ne.push(K?oe.slice(1):oe);return Object.getOwnPropertySymbols?ne.concat(Object.getOwnPropertySymbols(se)):ne},re.prototype.listeners=function(ne){var se=K?K+ne:ne,oe=this._events[se];if(!oe)return[];if(oe.fn)return[oe.fn];for(var ae=0,le=oe.length,ce=new Array(le);ae<le;ae++)ce[ae]=oe[ae].fn;return ce},re.prototype.listenerCount=function(ne){var se=K?K+ne:ne,oe=this._events[se];return oe?oe.fn?1:oe.length:0},re.prototype.emit=function(ne,se,oe,ae,le,ce){var de=K?K+ne:ne;if(!this._events[de])return!1;var he=this._events[de],pe=arguments.length,fe,ge;if(he.fn){switch(he.once&&this.removeListener(ne,he.fn,void 0,!0),pe){case 1:return he.fn.call(he.context),!0;case 2:return he.fn.call(he.context,se),!0;case 3:return he.fn.call(he.context,se,oe),!0;case 4:return he.fn.call(he.context,se,oe,ae),!0;case 5:return he.fn.call(he.context,se,oe,ae,le),!0;case 6:return he.fn.call(he.context,se,oe,ae,le,ce),!0}for(ge=1,fe=new Array(pe-1);ge<pe;ge++)fe[ge-1]=arguments[ge];he.fn.apply(he.context,fe)}else{var me=he.length,ye;for(ge=0;ge<me;ge++)switch(he[ge].once&&this.removeListener(ne,he[ge].fn,void 0,!0),pe){case 1:he[ge].fn.call(he[ge].context);break;case 2:he[ge].fn.call(he[ge].context,se);break;case 3:he[ge].fn.call(he[ge].context,se,oe);break;case 4:he[ge].fn.call(he[ge].context,se,oe,ae);break;default:if(!fe)for(ye=1,fe=new Array(pe-1);ye<pe;ye++)fe[ye-1]=arguments[ye];he[ge].fn.apply(he[ge].context,fe)}}return!0},re.prototype.on=function(ne,se,oe){return ee(this,ne,se,oe,!1)},re.prototype.once=function(ne,se,oe){return ee(this,ne,se,oe,!0)},re.prototype.removeListener=function(ne,se,oe,ae){var le=K?K+ne:ne;if(!this._events[le])return this;if(!se)return te(this,le),this;var ce=this._events[le];if(ce.fn)ce.fn===se&&(!ae||ce.once)&&(!oe||ce.context===oe)&&te(this,le);else{for(var de=0,he=[],pe=ce.length;de<pe;de++)(ce[de].fn!==se||ae&&!ce[de].once||oe&&ce[de].context!==oe)&&he.push(ce[de]);he.length?this._events[le]=he.length===1?he[0]:he:te(this,le)}return this},re.prototype.removeAllListeners=function(ne){var se;return ne?(se=K?K+ne:ne,this._events[se]&&te(this,se)):(this._events=new J,this._eventsCount=0),this},re.prototype.off=re.prototype.removeListener,re.prototype.addListener=re.prototype.on,re.prefixed=K,re.EventEmitter=re,Z.exports=re}),r$b={grad:.9,turn:360,rad:360/(2*Math.PI)},t$g=function(Z){return typeof Z=="string"?Z.length>0:typeof Z=="number"},n$B=function(Z,X,K){return X===void 0&&(X=0),K===void 0&&(K=Math.pow(10,X)),Math.round(K*Z)/K+0},e$b=function(Z,X,K){return X===void 0&&(X=0),K===void 0&&(K=1),Z>K?K:Z>X?Z:X},u$u=function(Z){return(Z=isFinite(Z)?Z%360:0)>0?Z:Z+360},a$z=function(Z){return{r:e$b(Z.r,0,255),g:e$b(Z.g,0,255),b:e$b(Z.b,0,255),a:e$b(Z.a)}},o$x=function(Z){return{r:n$B(Z.r),g:n$B(Z.g),b:n$B(Z.b),a:n$B(Z.a,3)}},i$v=/^#([0-9a-f]{3,8})$/i,s$D=function(Z){var X=Z.toString(16);return X.length<2?"0"+X:X},h$t=function(Z){var X=Z.r,K=Z.g,J=Z.b,Q=Z.a,ee=Math.max(X,K,J),te=ee-Math.min(X,K,J),re=te?ee===X?(K-J)/te:ee===K?2+(J-X)/te:4+(X-K)/te:0;return{h:60*(re<0?re+6:re),s:ee?te/ee*100:0,v:ee/255*100,a:Q}},b$o=function(Z){var X=Z.h,K=Z.s,J=Z.v,Q=Z.a;X=X/360*6,K/=100,J/=100;var ee=Math.floor(X),te=J*(1-K),re=J*(1-(X-ee)*K),ie=J*(1-(1-X+ee)*K),ne=ee%6;return{r:255*[J,re,te,te,ie,J][ne],g:255*[ie,J,J,re,te,te][ne],b:255*[te,te,ie,J,J,re][ne],a:Q}},g$o=function(Z){return{h:u$u(Z.h),s:e$b(Z.s,0,100),l:e$b(Z.l,0,100),a:e$b(Z.a)}},d$p=function(Z){return{h:n$B(Z.h),s:n$B(Z.s),l:n$B(Z.l),a:n$B(Z.a,3)}},f$v=function(Z){return b$o((K=(X=Z).s,{h:X.h,s:(K*=((J=X.l)<50?J:100-J)/100)>0?2*K/(J+K)*100:0,v:J+K,a:X.a}));var X,K,J},c$y=function(Z){return{h:(X=h$t(Z)).h,s:(Q=(200-(K=X.s))*(J=X.v)/100)>0&&Q<200?K*J/100/(Q<=100?Q:200-Q)*100:0,l:Q/2,a:X.a};var X,K,J,Q},l$u=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p$J=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v$6=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m$A=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y$m={string:[[function(Z){var X=i$v.exec(Z);return X?(Z=X[1]).length<=4?{r:parseInt(Z[0]+Z[0],16),g:parseInt(Z[1]+Z[1],16),b:parseInt(Z[2]+Z[2],16),a:Z.length===4?n$B(parseInt(Z[3]+Z[3],16)/255,2):1}:Z.length===6||Z.length===8?{r:parseInt(Z.substr(0,2),16),g:parseInt(Z.substr(2,2),16),b:parseInt(Z.substr(4,2),16),a:Z.length===8?n$B(parseInt(Z.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(Z){var X=v$6.exec(Z)||m$A.exec(Z);return X?X[2]!==X[4]||X[4]!==X[6]?null:a$z({r:Number(X[1])/(X[2]?100/255:1),g:Number(X[3])/(X[4]?100/255:1),b:Number(X[5])/(X[6]?100/255:1),a:X[7]===void 0?1:Number(X[7])/(X[8]?100:1)}):null},"rgb"],[function(Z){var X=l$u.exec(Z)||p$J.exec(Z);if(!X)return null;var K,J,Q=g$o({h:(K=X[1],J=X[2],J===void 0&&(J="deg"),Number(K)*(r$b[J]||1)),s:Number(X[3]),l:Number(X[4]),a:X[5]===void 0?1:Number(X[5])/(X[6]?100:1)});return f$v(Q)},"hsl"]],object:[[function(Z){var X=Z.r,K=Z.g,J=Z.b,Q=Z.a,ee=Q===void 0?1:Q;return t$g(X)&&t$g(K)&&t$g(J)?a$z({r:Number(X),g:Number(K),b:Number(J),a:Number(ee)}):null},"rgb"],[function(Z){var X=Z.h,K=Z.s,J=Z.l,Q=Z.a,ee=Q===void 0?1:Q;if(!t$g(X)||!t$g(K)||!t$g(J))return null;var te=g$o({h:Number(X),s:Number(K),l:Number(J),a:Number(ee)});return f$v(te)},"hsl"],[function(Z){var X=Z.h,K=Z.s,J=Z.v,Q=Z.a,ee=Q===void 0?1:Q;if(!t$g(X)||!t$g(K)||!t$g(J))return null;var te=function(re){return{h:u$u(re.h),s:e$b(re.s,0,100),v:e$b(re.v,0,100),a:e$b(re.a)}}({h:Number(X),s:Number(K),v:Number(J),a:Number(ee)});return b$o(te)},"hsv"]]},N$3=function(Z,X){for(var K=0;K<X.length;K++){var J=X[K][0](Z);if(J)return[J,X[K][1]]}return[null,void 0]},x$g=function(Z){return typeof Z=="string"?N$3(Z.trim(),y$m.string):typeof Z=="object"&&Z!==null?N$3(Z,y$m.object):[null,void 0]},I$7=function(Z){return x$g(Z)[1]},M$6=function(Z,X){var K=c$y(Z);return{h:K.h,s:e$b(K.s+100*X,0,100),l:K.l,a:K.a}},H$7=function(Z){return(299*Z.r+587*Z.g+114*Z.b)/1e3/255},$$2=function(Z,X){var K=c$y(Z);return{h:K.h,s:K.s,l:e$b(K.l+100*X,0,100),a:K.a}},j$2=function(){function Z(X){this.parsed=x$g(X)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return Z.prototype.isValid=function(){return this.parsed!==null},Z.prototype.brightness=function(){return n$B(H$7(this.rgba),2)},Z.prototype.isDark=function(){return H$7(this.rgba)<.5},Z.prototype.isLight=function(){return H$7(this.rgba)>=.5},Z.prototype.toHex=function(){return X=o$x(this.rgba),K=X.r,J=X.g,Q=X.b,te=(ee=X.a)<1?s$D(n$B(255*ee)):"","#"+s$D(K)+s$D(J)+s$D(Q)+te;var X,K,J,Q,ee,te},Z.prototype.toRgb=function(){return o$x(this.rgba)},Z.prototype.toRgbString=function(){return X=o$x(this.rgba),K=X.r,J=X.g,Q=X.b,(ee=X.a)<1?"rgba("+K+", "+J+", "+Q+", "+ee+")":"rgb("+K+", "+J+", "+Q+")";var X,K,J,Q,ee},Z.prototype.toHsl=function(){return d$p(c$y(this.rgba))},Z.prototype.toHslString=function(){return X=d$p(c$y(this.rgba)),K=X.h,J=X.s,Q=X.l,(ee=X.a)<1?"hsla("+K+", "+J+"%, "+Q+"%, "+ee+")":"hsl("+K+", "+J+"%, "+Q+"%)";var X,K,J,Q,ee},Z.prototype.toHsv=function(){return X=h$t(this.rgba),{h:n$B(X.h),s:n$B(X.s),v:n$B(X.v),a:n$B(X.a,3)};var X},Z.prototype.invert=function(){return w$6({r:255-(X=this.rgba).r,g:255-X.g,b:255-X.b,a:X.a});var X},Z.prototype.saturate=function(X){return X===void 0&&(X=.1),w$6(M$6(this.rgba,X))},Z.prototype.desaturate=function(X){return X===void 0&&(X=.1),w$6(M$6(this.rgba,-X))},Z.prototype.grayscale=function(){return w$6(M$6(this.rgba,-1))},Z.prototype.lighten=function(X){return X===void 0&&(X=.1),w$6($$2(this.rgba,X))},Z.prototype.darken=function(X){return X===void 0&&(X=.1),w$6($$2(this.rgba,-X))},Z.prototype.rotate=function(X){return X===void 0&&(X=15),this.hue(this.hue()+X)},Z.prototype.alpha=function(X){return typeof X=="number"?w$6({r:(K=this.rgba).r,g:K.g,b:K.b,a:X}):n$B(this.rgba.a,3);var K},Z.prototype.hue=function(X){var K=c$y(this.rgba);return typeof X=="number"?w$6({h:X,s:K.s,l:K.l,a:K.a}):n$B(K.h)},Z.prototype.isEqual=function(X){return this.toHex()===w$6(X).toHex()},Z}(),w$6=function(Z){return Z instanceof j$2?Z:new j$2(Z)},S$d=[],k$4=function(Z){Z.forEach(function(X){S$d.indexOf(X)<0&&(X(j$2,y$m),S$d.push(X))})},E$6=function(){return new j$2({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};function d$o(Z,X){var K={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},J={};for(var Q in K)J[K[Q]]=Q;var ee={};Z.prototype.toName=function(te){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var re,ie,ne=J[this.toHex()];if(ne)return ne;if(te!=null&&te.closest){var se=this.toRgb(),oe=1/0,ae="black";if(!ee.length)for(var le in K)ee[le]=new Z(K[le]).toRgb();for(var ce in K){var de=(re=se,ie=ee[ce],Math.pow(re.r-ie.r,2)+Math.pow(re.g-ie.g,2)+Math.pow(re.b-ie.b,2));de<oe&&(oe=de,ae=ce)}return ae}},X.string.push([function(te){var re=te.toLowerCase(),ie=re==="transparent"?"#0000":K[re];return ie?new Z(ie).toRgb():null},"name"])}var u$t=Object.defineProperty,c$x=Object.getOwnPropertySymbols,m$z=Object.prototype.hasOwnProperty,h$s=Object.prototype.propertyIsEnumerable,b$n=(Z,X,K)=>X in Z?u$t(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,f$u=(Z,X)=>{for(var K in X||(X={}))m$z.call(X,K)&&b$n(Z,K,X[K]);if(c$x)for(var K of c$x(X))h$s.call(X,K)&&b$n(Z,K,X[K]);return Z};k$4([d$o]);const i$u=class{constructor(Z=16777215){this._value=null,this._components=new Float32Array(4),this._components.fill(1),this._int=16777215,this.value=Z}get red(){return this._components[0]}get green(){return this._components[1]}get blue(){return this._components[2]}get alpha(){return this._components[3]}setValue(Z){return this.value=Z,this}set value(Z){if(Z instanceof i$u)this._value=this._cloneSource(Z._value),this._int=Z._int,this._components.set(Z._components);else{if(Z===null)throw new Error("Cannot set Color#value to null");(this._value===null||!this._isSourceEqual(this._value,Z))&&(this._normalize(Z),this._value=this._cloneSource(Z))}}get value(){return this._value}_cloneSource(Z){return typeof Z=="string"||typeof Z=="number"||Z instanceof Number||Z===null?Z:Array.isArray(Z)||ArrayBuffer.isView(Z)?Z.slice(0):typeof Z=="object"&&Z!==null?f$u({},Z):Z}_isSourceEqual(Z,X){const K=typeof Z;if(K!==typeof X)return!1;if(K==="number"||K==="string"||Z instanceof Number)return Z===X;if(Array.isArray(Z)&&Array.isArray(X)||ArrayBuffer.isView(Z)&&ArrayBuffer.isView(X))return Z.length!==X.length?!1:Z.every((J,Q)=>J===X[Q]);if(Z!==null&&X!==null){const J=Object.keys(Z),Q=Object.keys(X);return J.length!==Q.length?!1:J.every(ee=>Z[ee]===X[ee])}return Z===X}toRgba(){const[Z,X,K,J]=this._components;return{r:Z,g:X,b:K,a:J}}toRgb(){const[Z,X,K]=this._components;return{r:Z,g:X,b:K}}toRgbaString(){const[Z,X,K]=this.toUint8RgbArray();return`rgba(${Z},${X},${K},${this.alpha})`}toUint8RgbArray(Z){const[X,K,J]=this._components;return this._arrayRgb||(this._arrayRgb=[]),Z=Z||this._arrayRgb,Z[0]=Math.round(X*255),Z[1]=Math.round(K*255),Z[2]=Math.round(J*255),Z}toArray(Z){this._arrayRgba||(this._arrayRgba=[]),Z=Z||this._arrayRgba;const[X,K,J,Q]=this._components;return Z[0]=X,Z[1]=K,Z[2]=J,Z[3]=Q,Z}toRgbArray(Z){this._arrayRgb||(this._arrayRgb=[]),Z=Z||this._arrayRgb;const[X,K,J]=this._components;return Z[0]=X,Z[1]=K,Z[2]=J,Z}toNumber(){return this._int}toBgrNumber(){const[Z,X,K]=this.toUint8RgbArray();return(K<<16)+(X<<8)+Z}toLittleEndianNumber(){const Z=this._int;return(Z>>16)+(Z&65280)+((Z&255)<<16)}multiply(Z){const[X,K,J,Q]=i$u._temp.setValue(Z)._components;return this._components[0]*=X,this._components[1]*=K,this._components[2]*=J,this._components[3]*=Q,this._refreshInt(),this._value=null,this}premultiply(Z,X=!0){return X&&(this._components[0]*=Z,this._components[1]*=Z,this._components[2]*=Z),this._components[3]=Z,this._refreshInt(),this._value=null,this}toPremultiplied(Z,X=!0){if(Z===1)return(255<<24)+this._int;if(Z===0)return X?0:this._int;let K=this._int>>16&255,J=this._int>>8&255,Q=this._int&255;return X&&(K=K*Z+.5|0,J=J*Z+.5|0,Q=Q*Z+.5|0),(Z*255<<24)+(K<<16)+(J<<8)+Q}toHex(){const Z=this._int.toString(16);return`#${"000000".substring(0,6-Z.length)+Z}`}toHexa(){const Z=Math.round(this._components[3]*255).toString(16);return this.toHex()+"00".substring(0,2-Z.length)+Z}setAlpha(Z){return this._components[3]=this._clamp(Z),this}_normalize(Z){let X,K,J,Q;if((typeof Z=="number"||Z instanceof Number)&&Z>=0&&Z<=16777215){const ee=Z;X=(ee>>16&255)/255,K=(ee>>8&255)/255,J=(ee&255)/255,Q=1}else if((Array.isArray(Z)||Z instanceof Float32Array)&&Z.length>=3&&Z.length<=4)Z=this._clamp(Z),[X,K,J,Q=1]=Z;else if((Z instanceof Uint8Array||Z instanceof Uint8ClampedArray)&&Z.length>=3&&Z.length<=4)Z=this._clamp(Z,0,255),[X,K,J,Q=255]=Z,X/=255,K/=255,J/=255,Q/=255;else if(typeof Z=="string"||typeof Z=="object"){if(typeof Z=="string"){const te=i$u.HEX_PATTERN.exec(Z);te&&(Z=`#${te[2]}`)}const ee=w$6(Z);ee.isValid()&&({r:X,g:K,b:J,a:Q}=ee.rgba,X/=255,K/=255,J/=255)}if(X!==void 0)this._components[0]=X,this._components[1]=K,this._components[2]=J,this._components[3]=Q,this._refreshInt();else throw new Error(`Unable to convert color ${Z}`)}_refreshInt(){this._clamp(this._components);const[Z,X,K]=this._components;this._int=(Z*255<<16)+(X*255<<8)+(K*255|0)}_clamp(Z,X=0,K=1){return typeof Z=="number"?Math.min(Math.max(Z,X),K):(Z.forEach((J,Q)=>{Z[Q]=Math.min(Math.max(J,X),K)}),Z)}static isColorLike(Z){return typeof Z=="number"||typeof Z=="string"||Z instanceof Number||Z instanceof i$u||Array.isArray(Z)||Z instanceof Uint8Array||Z instanceof Uint8ClampedArray||Z instanceof Float32Array||Z.r!==void 0&&Z.g!==void 0&&Z.b!==void 0||Z.r!==void 0&&Z.g!==void 0&&Z.b!==void 0&&Z.a!==void 0||Z.h!==void 0&&Z.s!==void 0&&Z.l!==void 0||Z.h!==void 0&&Z.s!==void 0&&Z.l!==void 0&&Z.a!==void 0||Z.h!==void 0&&Z.s!==void 0&&Z.v!==void 0||Z.h!==void 0&&Z.s!==void 0&&Z.v!==void 0&&Z.a!==void 0}};let Color=i$u;Color.shared=new i$u,Color._temp=new i$u,Color.HEX_PATTERN=/^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;const PI_2=Math.PI*2,RAD_TO_DEG=180/Math.PI,DEG_TO_RAD=Math.PI/180;class Matrix{constructor(X=1,K=0,J=0,Q=1,ee=0,te=0){this.array=null,this.a=X,this.b=K,this.c=J,this.d=Q,this.tx=ee,this.ty=te}fromArray(X){this.a=X[0],this.b=X[1],this.c=X[3],this.d=X[4],this.tx=X[2],this.ty=X[5]}set(X,K,J,Q,ee,te){return this.a=X,this.b=K,this.c=J,this.d=Q,this.tx=ee,this.ty=te,this}toArray(X,K){this.array||(this.array=new Float32Array(9));const J=K||this.array;return X?(J[0]=this.a,J[1]=this.b,J[2]=0,J[3]=this.c,J[4]=this.d,J[5]=0,J[6]=this.tx,J[7]=this.ty,J[8]=1):(J[0]=this.a,J[1]=this.c,J[2]=this.tx,J[3]=this.b,J[4]=this.d,J[5]=this.ty,J[6]=0,J[7]=0,J[8]=1),J}apply(X,K){K=K||new Point;const J=X.x,Q=X.y;return K.x=this.a*J+this.c*Q+this.tx,K.y=this.b*J+this.d*Q+this.ty,K}applyInverse(X,K){K=K||new Point;const J=this.a,Q=this.b,ee=this.c,te=this.d,re=this.tx,ie=this.ty,ne=1/(J*te+ee*-Q),se=X.x,oe=X.y;return K.x=te*ne*se+-ee*ne*oe+(ie*ee-re*te)*ne,K.y=J*ne*oe+-Q*ne*se+(-ie*J+re*Q)*ne,K}translate(X,K){return this.tx+=X,this.ty+=K,this}scale(X,K){return this.a*=X,this.d*=K,this.c*=X,this.b*=K,this.tx*=X,this.ty*=K,this}rotate(X){const K=Math.cos(X),J=Math.sin(X),Q=this.a,ee=this.c,te=this.tx;return this.a=Q*K-this.b*J,this.b=Q*J+this.b*K,this.c=ee*K-this.d*J,this.d=ee*J+this.d*K,this.tx=te*K-this.ty*J,this.ty=te*J+this.ty*K,this}append(X){const K=this.a,J=this.b,Q=this.c,ee=this.d;return this.a=X.a*K+X.b*Q,this.b=X.a*J+X.b*ee,this.c=X.c*K+X.d*Q,this.d=X.c*J+X.d*ee,this.tx=X.tx*K+X.ty*Q+this.tx,this.ty=X.tx*J+X.ty*ee+this.ty,this}appendFrom(X,K){const J=X.a,Q=X.b,ee=X.c,te=X.d,re=X.tx,ie=X.ty,ne=K.a,se=K.b,oe=K.c,ae=K.d;return this.a=J*ne+Q*oe,this.b=J*se+Q*ae,this.c=ee*ne+te*oe,this.d=ee*se+te*ae,this.tx=re*ne+ie*oe+K.tx,this.ty=re*se+ie*ae+K.ty,this}setTransform(X,K,J,Q,ee,te,re,ie,ne){return this.a=Math.cos(re+ne)*ee,this.b=Math.sin(re+ne)*ee,this.c=-Math.sin(re-ie)*te,this.d=Math.cos(re-ie)*te,this.tx=X-(J*this.a+Q*this.c),this.ty=K-(J*this.b+Q*this.d),this}prepend(X){const K=this.tx;if(X.a!==1||X.b!==0||X.c!==0||X.d!==1){const J=this.a,Q=this.c;this.a=J*X.a+this.b*X.c,this.b=J*X.b+this.b*X.d,this.c=Q*X.a+this.d*X.c,this.d=Q*X.b+this.d*X.d}return this.tx=K*X.a+this.ty*X.c+X.tx,this.ty=K*X.b+this.ty*X.d+X.ty,this}decompose(X){const K=this.a,J=this.b,Q=this.c,ee=this.d,te=X.pivot,re=-Math.atan2(-Q,ee),ie=Math.atan2(J,K),ne=Math.abs(re+ie);return ne<1e-5||Math.abs(PI_2-ne)<1e-5?(X.rotation=ie,X.skew.x=X.skew.y=0):(X.rotation=0,X.skew.x=re,X.skew.y=ie),X.scale.x=Math.sqrt(K*K+J*J),X.scale.y=Math.sqrt(Q*Q+ee*ee),X.position.x=this.tx+(te.x*K+te.y*Q),X.position.y=this.ty+(te.x*J+te.y*ee),X}invert(){const X=this.a,K=this.b,J=this.c,Q=this.d,ee=this.tx,te=X*Q-K*J;return this.a=Q/te,this.b=-K/te,this.c=-J/te,this.d=X/te,this.tx=(J*this.ty-Q*ee)/te,this.ty=-(X*this.ty-K*ee)/te,this}isIdentity(){return this.a===1&&this.b===0&&this.c===0&&this.d===1&&this.tx===0&&this.ty===0}identity(){return this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0,this}clone(){const X=new Matrix;return X.a=this.a,X.b=this.b,X.c=this.c,X.d=this.d,X.tx=this.tx,X.ty=this.ty,X}copyTo(X){return X.a=this.a,X.b=this.b,X.c=this.c,X.d=this.d,X.tx=this.tx,X.ty=this.ty,X}copyFrom(X){return this.a=X.a,this.b=X.b,this.c=X.c,this.d=X.d,this.tx=X.tx,this.ty=X.ty,this}static get IDENTITY(){return l$t.identity()}static get shared(){return p$I.identity()}}const p$I=new Matrix,l$t=new Matrix;class ObservablePoint{constructor(X,K,J){this._x=K||0,this._y=J||0,this._observer=X}clone(X){return new ObservablePoint(X!=null?X:this._observer,this._x,this._y)}set(X=0,K=X){return(this._x!==X||this._y!==K)&&(this._x=X,this._y=K,this._observer.onUpdate()),this}copyFrom(X){return(this._x!==X.x||this._y!==X.y)&&(this._x=X.x,this._y=X.y,this._observer.onUpdate()),this}copyTo(X){return X.set(this._x,this._y),X}equals(X){return X.x===this._x&&X.y===this._y}get x(){return this._x}set x(X){this._x!==X&&(this._x=X,this._observer.onUpdate(this))}get y(){return this._y}set y(X){this._y!==X&&(this._y=X,this._observer.onUpdate(this))}}const t$f={default:-1};function uid(Z="default"){return t$f[Z]===void 0&&(t$f[Z]=-1),++t$f[Z]}const r$a={},v8_0_0="8.0.0";function deprecation(Z,X,K=3){if(r$a[X])return;let J=new Error().stack;typeof J=="undefined"?console.warn("PixiJS Deprecation Warning: ",`${X}
Deprecated since v${Z}`):(J=J.split(`
`).splice(K).join(`
`),console.groupCollapsed?(console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s","color:#614108;background:#fffbe6","font-weight:normal;color:#614108;background:#fffbe6",`${X}
Deprecated since v${Z}`),console.warn(J),console.groupEnd()):(console.warn("PixiJS Deprecation Warning: ",`${X}
Deprecated since v${Z}`),console.warn(J))),r$a[X]=!0}const childrenHelperMixin={allowChildren:!0,removeChildren(Z=0,X){const K=X!=null?X:this.children.length,J=K-Z,Q=[];if(J>0&&J<=K){for(let ee=K-1;ee>=Z;ee--){const te=this.children[ee];te&&(this.layerGroup&&this.layerGroup.removeChild(te),Q.push(te),te.parent=null)}removeItems(this.children,Z,K);for(let ee=0;ee<Q.length;++ee)this.emit("childRemoved",Q[ee],this,ee),Q[ee].emit("removed",this);return Q}else if(J===0&&this.children.length===0)return Q;throw new RangeError("removeChildren: numeric values are outside the acceptable range.")},removeChildAt(Z){const X=this.getChildAt(Z);return this.removeChild(X)},getChildAt(Z){if(Z<0||Z>=this.children.length)throw new Error(`getChildAt: Index (${Z}) does not exist.`);return this.children[Z]},setChildIndex(Z,X){if(X<0||X>=this.children.length)throw new Error(`The index ${X} supplied is out of bounds ${this.children.length}`);this.getChildIndex(Z),this.addChildAt(Z,X)},getChildIndex(Z){const X=this.children.indexOf(Z);if(X===-1)throw new Error("The supplied Container must be a child of the caller");return X},addChildAt(Z,X){this.allowChildren||deprecation(v8_0_0,"addChildAt: Only Containers will be allowed to add children in v8.0.0");const{children:K}=this;if(X<0||X>K.length)throw new Error(`${Z}addChildAt: The index ${X} supplied is out of bounds ${K.length}`);if(Z.parent){const J=Z.parent.children.indexOf(Z);if(Z.parent===this&&J===X)return Z;J!==-1&&Z.parent.children.splice(J,1)}return X===K.length?K.push(Z):K.splice(X,0,Z),Z.parent=this,Z.didChange=!0,Z.didViewUpdate=!1,Z._updateFlags=15,this.layerGroup&&this.layerGroup.addChild(Z),this.sortableChildren&&(this.sortDirty=!0),this.emit("childAdded",Z,this,X),Z.emit("added",this),Z},swapChildren(Z,X){if(Z===X)return;const K=this.getChildIndex(Z),J=this.getChildIndex(X);this.children[K]=X,this.children[J]=Z},removeFromParent(){var Z;(Z=this.parent)==null||Z.removeChild(this)}};class FilterEffect{constructor(X){this.pipe="filter",this.priority=1,this.filters=X==null?void 0:X.filters,this.filterArea=X==null?void 0:X.filterArea}destroy(){for(let X=0;X<this.filters.length;X++)this.filters[X].destroy();this.filters=null,this.filterArea=null}}const l$s=[];function getFilterEffect(Z,X){const K=l$s.pop()||new FilterEffect;return K.filters=Z,K.filterArea=X,K}function returnFilterEffect(Z){Z.filters=null,l$s.push(Z)}class Pool{constructor(X,K){this._pool=[],this._count=0,this._index=0,this._classType=X,K&&this.prepopulate(K)}prepopulate(X){for(let K=0;K<X;K++)this._pool[this._index++]=new this._classType;this._count+=X}get(X){var K;let J;return this._index>0?J=this._pool[--this._index]:J=new this._classType,(K=J.init)==null||K.call(J,X),J}return(X){var K;(K=X.reset)==null||K.call(X),this._pool[this._index++]=X}get totalSize(){return this._count}get totalFree(){return this._index}get totalUsed(){return this._count-this._index}}class PoolGroupClass{constructor(){this._poolsByClass=new Map}prepopulate(X,K){this.getPool(X).prepopulate(K)}get(X,K){return this.getPool(X).get(K)}return(X){this.getPool(X.constructor).return(X)}getPool(X){return this._poolsByClass.has(X)||this._poolsByClass.set(X,new Pool(X)),this._poolsByClass.get(X)}stats(){const X={};return this._poolsByClass.forEach(K=>{const J=X[K._classType.name]?K._classType.name+K._classType.ID:K._classType.name;X[J]={free:K.totalFree,used:K.totalUsed,size:K.totalSize}}),X}}const BigPool=new PoolGroupClass;class MaskEffectManagerClass{constructor(){this._effectClasses=[],this._tests=[],this._initialized=!1}init(){this._initialized||(this._initialized=!0,this._effectClasses.forEach(X=>{this.add({test:X.test,maskClass:X})}))}add(X){this._tests.push(X)}getMaskEffect(X){this._initialized||this.init();for(let K=0;K<this._tests.length;K++){const J=this._tests[K];if(J.test(X))return BigPool.get(J.maskClass,X)}return X}returnMaskEffect(X){BigPool.return(X)}}const MaskEffectManager=new MaskEffectManagerClass;b$p.handleByList(u$v.MaskEffect,MaskEffectManager._effectClasses);const effectsMixin={_mask:null,_filters:null,effects:[],addEffect(Z){this.effects.indexOf(Z)===-1&&(this.effects.push(Z),this.effects.sort((X,K)=>X.priority-K.priority),!this.isLayerRoot&&this.layerGroup&&(this.layerGroup.structureDidChange=!0),this._updateIsSimple())},removeEffect(Z){const X=this.effects.indexOf(Z);X!==-1&&(this.effects.splice(X,1),!this.isLayerRoot&&this.layerGroup&&(this.layerGroup.structureDidChange=!0),this._updateIsSimple())},set mask(Z){if(this._mask||(this._mask={mask:null,effect:null}),this._mask.mask===Z||(this._mask.effect&&(this.removeEffect(this._mask.effect),MaskEffectManager.returnMaskEffect(this._mask.effect),this._mask.effect=null),this._mask.mask=Z,Z==null))return;const X=MaskEffectManager.getMaskEffect(Z);this._mask.effect=X,this.addEffect(X)},get mask(){var Z;return(Z=this._mask)==null?void 0:Z.mask},set filters(Z){if(!Array.isArray(Z)&&Z!==null&&(Z=[Z]),this._filters||(this._filters={filters:null,effect:null,filterArea:null}),this._filters.filters===Z||(this._filters.effect&&(this.removeEffect(this._filters.effect),returnFilterEffect(this._filters.effect),this._filters.effect=null),this._filters.filters=Z,!Z))return;const X=getFilterEffect(Z,this.filterArea);this._filters.effect=X,this.addEffect(X)},get filters(){var Z;return(Z=this._filters)==null?void 0:Z.filters},set filterArea(Z){this._filters||(this._filters={filters:null,effect:null,filterArea:null}),this._filters.filterArea=Z},get filterArea(){var Z;return(Z=this._filters)==null?void 0:Z.filterArea}},findMixin={label:null,get name(){return deprecation(v8_0_0,"Container.name property has been removed, use Container.label instead"),this.label},set name(Z){deprecation(v8_0_0,"Container.name property has been removed, use Container.label instead"),this.label=Z},getChildByName(Z,X=!1){return this.getChildByLabel(Z,X)},getChildByLabel(Z,X=!1){const K=this.children;for(let J=0;J<K.length;J++){const Q=K[J];if(Q.label===Z||Z instanceof RegExp&&Z.test(Q.label))return Q}if(X)for(let J=0;J<K.length;J++){const Q=K[J].getChildByLabel(Z,!0);if(Q)return Q}return null},getChildrenByLabel(Z,X=!1,K=[]){const J=this.children;for(let Q=0;Q<J.length;Q++){const ee=J[Q];(ee.label===Z||Z instanceof RegExp&&Z.test(ee.label))&&K.push(ee)}if(X)for(let Q=0;Q<J.length;Q++)J[Q].getChildrenByLabel(Z,!0,K);return K}},l$r=[new Point,new Point,new Point,new Point];class Rectangle{constructor(X=0,K=0,J=0,Q=0){this.type="rectangle",this.x=Number(X),this.y=Number(K),this.width=Number(J),this.height=Number(Q)}get left(){return this.x}get right(){return this.x+this.width}get top(){return this.y}get bottom(){return this.y+this.height}static get EMPTY(){return new Rectangle(0,0,0,0)}clone(){return new Rectangle(this.x,this.y,this.width,this.height)}copyFromBounds(X){return this.x=X.minX,this.y=X.minY,this.width=X.maxX-X.minX,this.height=X.maxY-X.minY,this}copyFrom(X){return this.x=X.x,this.y=X.y,this.width=X.width,this.height=X.height,this}copyTo(X){return X.copyFrom(this),X}contains(X,K){return this.width<=0||this.height<=0?!1:X>=this.x&&X<this.x+this.width&&K>=this.y&&K<this.y+this.height}intersects(X,K){if(!K){const xe=this.x<X.x?X.x:this.x;if((this.right>X.right?X.right:this.right)<=xe)return!1;const be=this.y<X.y?X.y:this.y;return(this.bottom>X.bottom?X.bottom:this.bottom)>be}const J=this.left,Q=this.right,ee=this.top,te=this.bottom;if(Q<=J||te<=ee)return!1;const re=l$r[0].set(X.left,X.top),ie=l$r[1].set(X.left,X.bottom),ne=l$r[2].set(X.right,X.top),se=l$r[3].set(X.right,X.bottom);if(ne.x<=re.x||ie.y<=re.y)return!1;const oe=Math.sign(K.a*K.d-K.b*K.c);if(oe===0||(K.apply(re,re),K.apply(ie,ie),K.apply(ne,ne),K.apply(se,se),Math.max(re.x,ie.x,ne.x,se.x)<=J||Math.min(re.x,ie.x,ne.x,se.x)>=Q||Math.max(re.y,ie.y,ne.y,se.y)<=ee||Math.min(re.y,ie.y,ne.y,se.y)>=te))return!1;const ae=oe*(ie.y-re.y),le=oe*(re.x-ie.x),ce=ae*J+le*ee,de=ae*Q+le*ee,he=ae*J+le*te,pe=ae*Q+le*te;if(Math.max(ce,de,he,pe)<=ae*re.x+le*re.y||Math.min(ce,de,he,pe)>=ae*se.x+le*se.y)return!1;const fe=oe*(re.y-ne.y),ge=oe*(ne.x-re.x),me=fe*J+ge*ee,ye=fe*Q+ge*ee,_e=fe*J+ge*te,Ce=fe*Q+ge*te;return!(Math.max(me,ye,_e,Ce)<=fe*re.x+ge*re.y||Math.min(me,ye,_e,Ce)>=fe*se.x+ge*se.y)}pad(X=0,K=X){return this.x-=X,this.y-=K,this.width+=X*2,this.height+=K*2,this}fit(X){const K=Math.max(this.x,X.x),J=Math.min(this.x+this.width,X.x+X.width),Q=Math.max(this.y,X.y),ee=Math.min(this.y+this.height,X.y+X.height);return this.x=K,this.width=Math.max(J-K,0),this.y=Q,this.height=Math.max(ee-Q,0),this}ceil(X=1,K=.001){const J=Math.ceil((this.x+this.width-K)*X)/X,Q=Math.ceil((this.y+this.height-K)*X)/X;return this.x=Math.floor((this.x+K)*X)/X,this.y=Math.floor((this.y+K)*X)/X,this.width=J-this.x,this.height=Q-this.y,this}enlarge(X){const K=Math.min(this.x,X.x),J=Math.max(this.x+this.width,X.x+X.width),Q=Math.min(this.y,X.y),ee=Math.max(this.y+this.height,X.y+X.height);return this.x=K,this.width=J-K,this.y=Q,this.height=ee-Q,this}getBounds(X){return X=X||new Rectangle,X.copyFrom(this),X}}class Bounds{constructor(X=1/0,K=1/0,J=-1/0,Q=-1/0){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this._matrixStack=[],this.matrix=new Matrix,this.minX=X,this.minY=K,this.maxX=J,this.maxY=Q}get rectangle(){this._rectangle||(this._rectangle=new Rectangle);const X=this._rectangle;return this.minX>this.maxX||this.minY>this.maxY?(X.x=0,X.y=0,X.width=0,X.height=0):X.copyFromBounds(this),X}clear(){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this._matrixStack.length=0,this.matrix.identity()}pushMatrix(X){this._matrixStack.push(X),this._matrixStack.length>1?(this.matrix.copyFrom(this._matrixStack[this._matrixStack.length-2]),this.matrix.append(X)):this.matrix.copyFrom(X)}popMatrix(){this._matrixStack.pop(),this._matrixStack.length>1?(this.matrix.copyFrom(this._matrixStack[this._matrixStack.length-2]),this.matrix.append(this._matrixStack[this._matrixStack.length-1])):this._matrixStack.length===1?this.matrix.copyFrom(this._matrixStack[0]):this.matrix.identity()}setMatrix(X){this.matrix.copyFrom(X)}set(X,K,J,Q){this.minX=X,this.minY=K,this.maxX=J,this.maxY=Q}addFrame(X,K,J,Q){const ee=this.matrix,te=ee.a,re=ee.b,ie=ee.c,ne=ee.d,se=ee.tx,oe=ee.ty;let ae=this.minX,le=this.minY,ce=this.maxX,de=this.maxY,he=te*X+ie*K+se,pe=re*X+ne*K+oe;ae=he<ae?he:ae,le=pe<le?pe:le,ce=he>ce?he:ce,de=pe>de?pe:de,he=te*J+ie*K+se,pe=re*J+ne*K+oe,ae=he<ae?he:ae,le=pe<le?pe:le,ce=he>ce?he:ce,de=pe>de?pe:de,he=te*X+ie*Q+se,pe=re*X+ne*Q+oe,ae=he<ae?he:ae,le=pe<le?pe:le,ce=he>ce?he:ce,de=pe>de?pe:de,he=te*J+ie*Q+se,pe=re*J+ne*Q+oe,ae=he<ae?he:ae,le=pe<le?pe:le,ce=he>ce?he:ce,de=pe>de?pe:de,this.minX=ae,this.minY=le,this.maxX=ce,this.maxY=de}addRect(X){this.addFrame(X.x,X.y,X.x+X.width,X.y+X.height)}addBounds(X){this.addFrame(X.minX,X.minY,X.maxX,X.maxY)}addBoundsMask(X){this.minX=this.minX>X.minX?this.minX:X.minX,this.minY=this.minY>X.minY?this.minY:X.minY,this.maxX=this.maxX<X.maxX?this.maxX:X.maxX,this.maxY=this.maxY<X.maxY?this.maxY:X.maxY}applyMatrix(X){const K=this.minX,J=this.minY,Q=this.maxX,ee=this.maxY,{a:te,b:re,c:ie,d:ne,tx:se,ty:oe}=X;let ae=te*K+ie*J+se,le=re*K+ne*J+oe;this.minX=ae,this.minY=le,this.maxX=ae,this.maxY=le,ae=te*Q+ie*J+se,le=re*Q+ne*J+oe,this.minX=ae<this.minX?ae:this.minX,this.minY=le<this.minY?le:this.minY,this.maxX=ae>this.maxX?ae:this.maxX,this.maxY=le>this.maxY?le:this.maxY,ae=te*K+ie*ee+se,le=re*K+ne*ee+oe,this.minX=ae<this.minX?ae:this.minX,this.minY=le<this.minY?le:this.minY,this.maxX=ae>this.maxX?ae:this.maxX,this.maxY=le>this.maxY?le:this.maxY,ae=te*Q+ie*ee+se,le=re*Q+ne*ee+oe,this.minX=ae<this.minX?ae:this.minX,this.minY=le<this.minY?le:this.minY,this.maxX=ae>this.maxX?ae:this.maxX,this.maxY=le>this.maxY?le:this.maxY}fit(X){return this.minX<X.left&&(this.minX=X.left),this.maxX>X.right&&(this.maxX=X.right),this.minY<X.top&&(this.minY=X.top),this.maxY>X.bottom&&(this.maxY=X.bottom),this}pad(X,K=X){return this.minX-=X,this.maxX+=X,this.minY-=K,this.maxY+=K,this}ceil(){return this.minX=Math.floor(this.minX),this.minY=Math.floor(this.minY),this.maxX=Math.ceil(this.maxX),this.maxY=Math.ceil(this.maxY),this}clone(){return new Bounds(this.minX,this.minY,this.maxX,this.maxY)}scale(X,K=X){return this.minX*=X,this.minY*=K,this.maxX*=X,this.maxY*=K,this}get x(){return this.minX}get y(){return this.minY}get width(){return this.maxX-this.minX}get height(){return this.maxY-this.minY}get isPositive(){return this.maxX-this.minX>0&&this.maxY-this.minY>0}get isValid(){return this.minX+this.minY!==1/0}addVertexData(X,K,J){let Q=this.minX,ee=this.minY,te=this.maxX,re=this.maxY;const ie=this.matrix,ne=ie.a,se=ie.b,oe=ie.c,ae=ie.d,le=ie.tx,ce=ie.ty;for(let de=K;de<J;de+=2){const he=X[de],pe=X[de+1],fe=ne*he+oe*pe+le,ge=se*he+ae*pe+ce;Q=fe<Q?fe:Q,ee=ge<ee?ge:ee,te=fe>te?fe:te,re=ge>re?ge:re}this.minX=Q,this.minY=ee,this.maxX=te,this.maxY=re}toString(){return`[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`}}function updateLocalTransform(Z,X){const K=X._scale,J=X._pivot,Q=X._position,ee=K._x,te=K._y,re=J._x,ie=J._y;Z.a=X._cx*ee,Z.b=X._sx*ee,Z.c=X._cy*te,Z.d=X._sy*te,Z.tx=Q._x-(re*Z.a+ie*Z.c),Z.ty=Q._y-(re*Z.b+ie*Z.d)}function getGlobalBounds(Z,X,K){K.clear();let J;return Z.parent?X?J=Z.parent.worldTransform:J=updateTransformBackwards(Z,new Matrix):J=Matrix.IDENTITY,_getGlobalBounds(Z,K,J,X),K.isValid||K.set(0,0,0,0),K}function _getGlobalBounds(Z,X,K,J){var Q,ee;if(!Z.visible||!Z.measurable)return;let te;J?te=Z.worldTransform:(Z.didChange&&updateLocalTransform(Z.localTransform,Z),te=Matrix.shared.appendFrom(Z.localTransform,K).clone());const re=X,ie=!!Z.effects.length;ie&&(X=X.clone()),Z.view&&(X.setMatrix(te),Z.view.addBounds(X));for(let ne=0;ne<Z.children.length;ne++)_getGlobalBounds(Z.children[ne],X,te,J);if(ie){for(let ne=0;ne<Z.effects.length;ne++)(ee=(Q=Z.effects[ne]).addBounds)==null||ee.call(Q,X);re.setMatrix(Matrix.IDENTITY),re.addBounds(X)}}function updateTransformBackwards(Z,X){const K=Z.parent;return K&&(updateTransformBackwards(K,X),K.didChange&&updateLocalTransform(K.localTransform,K),X.append(K.localTransform)),X}function getLocalBounds(Z,X,K){X.clear(),K||(K=new Matrix),Z.view&&(X.setMatrix(K),Z.view.addBounds(X));for(let J=0;J<Z.children.length;J++)p$H(Z.children[J],X,K,Z);return X.isValid||X.set(0,0,0,0),X}function p$H(Z,X,K,J){var Q,ee;if(!Z.visible||!Z.measurable)return;Z.didChange&&updateLocalTransform(Z.localTransform,Z);const te=Z.localTransform,re=Matrix.shared.appendFrom(te,K).clone(),ie=X,ne=!!Z.effects.length;ne&&(X=new Bounds),Z.view&&(X.setMatrix(re),Z.view.addBounds(X));for(let se=0;se<Z.children.length;se++)p$H(Z.children[se],X,re,J);if(ne){for(let se=0;se<Z.effects.length;se++)(ee=(Q=Z.effects[se]).addLocalBounds)==null||ee.call(Q,X,J);ie.setMatrix(Matrix.IDENTITY),ie.addBounds(X)}}function getParent(Z,X,K){const J=Z.parent;J&&J!==X&&(getParent(J,X,K),updateLocalTransform(J.localTransform,J),K.append(J.localTransform))}const o$w=new Bounds,i$t=new Matrix,measureMixin={get width(){return Math.abs(this.scale.x*getLocalBounds(this,o$w,i$t).width)},set width(Z){const X=getLocalBounds(this,o$w,i$t).width,K=Math.sign(this.scale.x)||1;X!==0?this.scale.x=Z/X*K:this.scale.x=K},get height(){return Math.abs(this.scale.y*getLocalBounds(this,o$w,i$t).height)},set height(Z){const X=getLocalBounds(this,o$w,i$t).height,K=Math.sign(this.scale.y)||1;X!==0?this.scale.y=Z/X*K:this.scale.y=K},getLocalBounds(Z){const X=getLocalBounds(this,new Bounds,i$t);return Z?Z.copyFromBounds(X):X.rectangle.clone()},getBounds(Z,X){const K=getGlobalBounds(this,Z,o$w);return X?X.copyFromBounds(K):K.rectangle.clone()}},onRenderMixin={_onRender:null,set onRender(Z){const X=this.layerGroup;if(!Z){this._onRender&&(X==null||X.removeOnRender(this)),this._onRender=null;return}this._onRender||X==null||X.addOnRender(this),this._onRender=Z},get onRender(){return this._onRender}},sortMixin={_zIndex:0,sortDirty:!1,sortableChildren:!1,get zIndex(){return this._zIndex},set zIndex(Z){this._zIndex!==Z&&(this._zIndex=Z,this.depthOfChildModified())},depthOfChildModified(){this.parent&&(this.parent.sortableChildren=!0,this.parent.sortDirty=!0),this.layerGroup&&!this.isLayerRoot&&(this.layerGroup.structureDidChange=!0)},sortChildren(){this.sortDirty&&(this.sortDirty=!1,this.children.sort(e$a))}};function e$a(Z,X){return Z._zIndex-X._zIndex}const toLocalGlobalMixin={getGlobalPosition(Z=new Point,X=!1){return this.parent?this.parent.toGlobal(this._position,Z,X):(Z.x=this._position.x,Z.y=this._position.y),Z},toGlobal(Z,X,K=!1){if(!K){this.didChange&&updateLocalTransform(this.localTransform,this);const J=updateTransformBackwards(this,new Matrix);return J.append(this.localTransform),J.apply(Z,X)}return this.worldTransform.apply(Z,X)},toLocal(Z,X,K,J){if(X&&(Z=X.toGlobal(Z,K,J)),!J){this.didChange&&updateLocalTransform(this.localTransform,this);const Q=updateTransformBackwards(this,new Matrix);return Q.append(this.localTransform),Q.applyInverse(Z,K)}return this.worldTransform.applyInverse(Z,K)}};class InstructionSet{constructor(){this.uid=uid("instructionSet"),this.instructions=[],this.instructionSize=0}reset(){this.instructionSize=0}add(X){this.instructions[this.instructionSize++]=X}log(){this.instructions.length=this.instructionSize,console.table(this.instructions,["type","action"])}}class LayerGroup{constructor(X){this.renderPipeId="layer",this.root=null,this.canBundle=!1,this.layerGroupParent=null,this.layerGroupChildren=[],this._children=[],this.worldTransform=new Matrix,this.worldColor=4294967295,this.childrenToUpdate=Object.create(null),this.updateTick=0,this.childrenRenderablesToUpdate={list:[],index:0},this.structureDidChange=!0,this.instructionSet=new InstructionSet,this._onRenderContainers=[],this.root=X,this.addChild(X)}get localTransform(){return this.root.localTransform}get layerTransform(){return this.root.layerTransform}addLayerGroupChild(X){X.layerGroupParent&&X.layerGroupParent._removeLayerGroupChild(X),X.layerGroupParent=this,this.onChildUpdate(X.root),this.layerGroupChildren.push(X)}_removeLayerGroupChild(X){X.root.didChange&&this._removeChildFromUpdate(X.root);const K=this.layerGroupChildren.indexOf(X);K>-1&&this.layerGroupChildren.splice(K,1),X.layerGroupParent=null}addChild(X){if(this.structureDidChange=!0,X!==this.root&&(this._children.push(X),X.updateTick=-1,X.parent===this.root?X.relativeLayerDepth=1:X.relativeLayerDepth=X.parent.relativeLayerDepth+1,X._onRender&&this.addOnRender(X)),X.layerGroup){if(X.layerGroup.root===X){this.addLayerGroupChild(X.layerGroup);return}}else X.layerGroup=this,X.didChange=!0;const K=X.children;X.isLayerRoot||this.onChildUpdate(X);for(let J=0;J<K.length;J++)this.addChild(K[J])}removeChild(X){if(this.structureDidChange=!0,X._onRender&&this.removeOnRender(X),X.layerGroup.root!==X){const J=X.children;for(let Q=0;Q<J.length;Q++)this.removeChild(J[Q]);X.didChange&&X.layerGroup._removeChildFromUpdate(X),X.layerGroup=null}else this._removeLayerGroupChild(X.layerGroup);const K=this._children.indexOf(X);K>-1&&this._children.splice(K,1)}onChildUpdate(X){let K=this.childrenToUpdate[X.relativeLayerDepth];K||(K=this.childrenToUpdate[X.relativeLayerDepth]={index:0,list:[]}),K.list[K.index++]=X}updateRenderable(X){X.layerVisibleRenderable<3||(X.didViewUpdate=!1,this.instructionSet.renderPipes[X.view.renderPipeId].updateRenderable(X))}onChildViewUpdate(X){this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++]=X}_removeChildFromUpdate(X){const K=this.childrenToUpdate[X.relativeLayerDepth];if(!K)return;const J=K.list.indexOf(X);J>-1&&K.list.splice(J,1),K.index--}get isRenderable(){const X=this.worldColor>>24&255;return this.root.localVisibleRenderable===3&&X>0}addOnRender(X){this._onRenderContainers.push(X)}removeOnRender(X){this._onRenderContainers.splice(this._onRenderContainers.indexOf(X),1)}runOnRender(){this._onRenderContainers.forEach(X=>{X._onRender()})}}function definedProps(Z){return Object.fromEntries(Object.entries(Z).filter(([X,K])=>K!==void 0))}const a$y=new ObservablePoint(null),s$C=new ObservablePoint(null),l$q=new ObservablePoint(null,1,1),UPDATE_COLOR=1,UPDATE_BLEND=2,UPDATE_VISIBLE=4,UPDATE_TRANSFORM=8;class Container extends eventemitter3{constructor(X={}){var K,J;super(),this.uid=uid("renderable"),this._updateFlags=15,this.isLayerRoot=!1,this.layerGroup=null,this.didChange=!1,this.didViewUpdate=!1,this.relativeLayerDepth=0,this.children=[],this.parent=null,this.includeInBuild=!0,this.measurable=!0,this.isSimple=!0,this.updateTick=-1,this.localTransform=new Matrix,this.layerTransform=new Matrix,this.destroyed=!1,this._position=new ObservablePoint(this,0,0),this._scale=l$q,this._pivot=s$C,this._skew=a$y,this._cx=1,this._sx=0,this._cy=0,this._sy=1,this._rotation=0,this.localColor=4294967295,this.layerColor=4294967295,this.localBlendMode="inherit",this.layerBlendMode="normal",this.localVisibleRenderable=3,this.layerVisibleRenderable=3,X.view&&(this.view=X.view,this.view.owner=this,X.view=void 0),Object.assign(this,definedProps(X)),this.children=[],(K=X.children)==null||K.forEach(Q=>this.addChild(Q)),this.effects=[],(J=X.effects)==null||J.forEach(Q=>this.addEffect(Q))}static mixin(X){Object.defineProperties(Container.prototype,Object.getOwnPropertyDescriptors(X))}addChild(...X){if(this.allowChildren||deprecation(v8_0_0,"addChild: Only Containers will be allowed to add children in v8.0.0"),X.length>1){for(let J=0;J<X.length;J++)this.addChild(X[J]);return X[0]}const K=X[0];return K.parent===this?(this.children.splice(this.children.indexOf(K),1),this.children.push(K),this.layerGroup&&!this.isLayerRoot&&(this.layerGroup.structureDidChange=!0),K):(K.parent&&K.parent.removeChild(K),this.children.push(K),this.sortableChildren&&(this.sortDirty=!0),K.parent=this,K.didChange=!0,K.didViewUpdate=!1,K._updateFlags=15,this.layerGroup&&this.layerGroup.addChild(K),this.emit("childAdded",K,this,this.children.length-1),K.emit("added",this),K._zIndex!==0&&K.depthOfChildModified(),K)}removeChild(...X){if(X.length>1){for(let Q=0;Q<X.length;Q++)this.removeChild(X[Q]);return X[0]}const K=X[0],J=this.children.indexOf(K);return J>-1&&(this.children.splice(J,1),this.layerGroup&&this.layerGroup.removeChild(K)),K.parent=null,this.emit("childRemoved",K,this,J),K.emit("removed",this),K}onUpdate(X){if(X&&X===this._skew&&this._updateSkew(),!this.didChange)if(this.didChange=!0,this.isLayerRoot){const K=this.layerGroup.layerGroupParent;K&&K.onChildUpdate(this)}else this.layerGroup&&this.layerGroup.onChildUpdate(this)}onViewUpdate(){this.didViewUpdate||(this.didViewUpdate=!0,this.layerGroup&&this.layerGroup.onChildViewUpdate(this))}set layer(X){if(this.isLayerRoot&&X===!1)throw new Error("[Pixi] cannot undo a layer just yet");X&&this.enableLayer()}get layer(){return this.isLayerRoot}enableLayer(){if(this.layerGroup&&this.layerGroup.root===this)return;this.isLayerRoot=!0;const X=this.layerGroup;if(X&&X.removeChild(this),this.layerGroup=new LayerGroup(this),X){for(let K=0;K<X.layerGroupChildren.length;K++){const J=X.layerGroupChildren[K];let Q=J.root;for(;Q;){if(Q===this){this.layerGroup.addLayerGroupChild(J);break}Q=Q.parent}}X.addLayerGroupChild(this.layerGroup)}this._updateIsSimple()}_updateIsSimple(){this.isSimple=!this.isLayerRoot&&this.effects.length===0}get worldTransform(){return this._worldTransform||(this._worldTransform=new Matrix),this.layerGroup&&(this.isLayerRoot?this._worldTransform.copyFrom(this.layerGroup.worldTransform):this._worldTransform.appendFrom(this.layerTransform,this.layerGroup.worldTransform)),this._worldTransform}get x(){return this._position.x}set x(X){this._position.x=X}get y(){return this._position.y}set y(X){this._position.y=X}get position(){return this._position}set position(X){this._position.copyFrom(X)}get rotation(){return this._rotation}set rotation(X){this._rotation!==X&&(this._rotation=X,this.onUpdate(this._skew))}get angle(){return this.rotation*RAD_TO_DEG}set angle(X){this.rotation=X*DEG_TO_RAD}get pivot(){return this._pivot===s$C&&(this._pivot=new ObservablePoint(this,0,0)),this._pivot}set pivot(X){this._pivot===s$C&&(this._pivot=new ObservablePoint(this,0,0)),this._pivot.copyFrom(X)}get skew(){return this._skew===a$y&&(this._skew=new ObservablePoint(this,0,0)),this._skew}get scale(){return this._scale===l$q&&(this._scale=new ObservablePoint(this,1,1)),this._scale}set scale(X){this._scale===l$q&&(this._scale=new ObservablePoint(this,0,0)),this._scale.copyFrom(X)}_updateSkew(){const X=this._rotation,K=this._skew;this._cx=Math.cos(X+K._y),this._sx=Math.sin(X+K._y),this._cy=-Math.sin(X-K._x),this._sy=Math.cos(X-K._x)}set alpha(X){X=X*255|0,X!==(this.localColor>>24&255)&&(this.localColor=this.localColor&16777215|X<<24,this._updateFlags|=UPDATE_COLOR,this.onUpdate())}get alpha(){return(this.localColor>>24&255)/255}set tint(X){const K=Color.shared.setValue(X).toBgrNumber();K!==(this.localColor&16777215)&&(this.localColor=this.localColor&4278190080|K&16777215,this._updateFlags|=UPDATE_COLOR,this.onUpdate())}get tint(){const X=this.localColor&16777215;return((X&255)<<16)+(X&65280)+(X>>16&255)}set blendMode(X){this.localBlendMode!==X&&(this.layerGroup&&!this.isLayerRoot&&(this.layerGroup.structureDidChange=!0),this._updateFlags|=UPDATE_BLEND,this.localBlendMode=X,this.onUpdate())}get blendMode(){return this.localBlendMode}get visible(){return!!(this.localVisibleRenderable&2)}set visible(X){const K=X?1:0;(this.localVisibleRenderable&2)>>1!==K&&(this.layerGroup&&!this.isLayerRoot&&(this.layerGroup.structureDidChange=!0),this._updateFlags|=UPDATE_VISIBLE,this.localVisibleRenderable=this.localVisibleRenderable&1|K<<1,this.onUpdate())}get renderable(){return!!(this.localVisibleRenderable&1)}set renderable(X){const K=X?1:0;(this.localVisibleRenderable&1)!==K&&(this.localVisibleRenderable=this.localVisibleRenderable&2|K,this._updateFlags|=UPDATE_VISIBLE,this.layerGroup&&!this.isLayerRoot&&(this.layerGroup.structureDidChange=!0),this.onUpdate())}get isRenderable(){const X=this.layerColor>>24&255;return this.localVisibleRenderable===3&&X>0}destroy(X=!1){if(this.destroyed)return;this.destroyed=!0,this.removeFromParent(),this.parent=null,this._mask=null,this._filters=null,this.effects=null,this._position=null,this._scale=null,this._pivot=null,this._skew=null,this.emit("destroyed"),this.removeAllListeners();const K=typeof X=="boolean"?X:X==null?void 0:X.children,J=this.removeChildren(0,this.children.length);if(K)for(let Q=0;Q<J.length;++Q)J[Q].destroy(X);this.view&&(this.view.destroy(X),this.view.owner=null)}}Container.mixin(childrenHelperMixin),Container.mixin(toLocalGlobalMixin),Container.mixin(onRenderMixin),Container.mixin(measureMixin),Container.mixin(effectsMixin),Container.mixin(findMixin),Container.mixin(sortMixin),b$p.add(AccessibilitySystem),Container.mixin(accessibilityTarget);const browserExt={extension:{type:u$v.Environment,name:"browser",priority:-1},test:()=>!0,load:async()=>{await Promise.resolve().then(function(){return browserAll})}},webworkerExt={extension:{type:u$v.Environment,name:"webworker",priority:0},test:()=>typeof self!="undefined"&&self.WorkerGlobalScope!==void 0,load:async()=>{await Promise.resolve().then(function(){return webworkerAll})}},o$v=[];b$p.handleByNamedList(u$v.Environment,o$v),b$p.add(browserExt,webworkerExt);async function autoDetectEnvironment(Z){if(Z)for(let X=0;X<o$v.length;X++){const K=o$v[X];if(K.value.test()){await K.value.load();return}}}const BrowserAdapter={createCanvas:(Z,X)=>{const K=document.createElement("canvas");return K.width=Z,K.height=X,K},getCanvasRenderingContext2D:()=>CanvasRenderingContext2D,getWebGLRenderingContext:()=>WebGLRenderingContext,getNavigator:()=>navigator,getBaseUrl:()=>{var Z;return(Z=document.baseURI)!=null?Z:window.location.href},getFontFaceSet:()=>document.fonts,fetch:(Z,X)=>fetch(Z,X),parseXML:Z=>new DOMParser().parseFromString(Z,"text/xml")};let e$9=BrowserAdapter;const DOMAdapter={get(){return e$9},set(Z){e$9=Z}};class SystemRunner{constructor(X){this.items=[],this._name=X}emit(X,K,J,Q,ee,te,re,ie){const{name:ne,items:se}=this;for(let oe=0,ae=se.length;oe<ae;oe++)se[oe][ne](X,K,J,Q,ee,te,re,ie);return this}add(X){return X[this._name]&&(this.remove(X),this.items.push(X)),this}remove(X){const K=this.items.indexOf(X);return K!==-1&&this.items.splice(K,1),this}contains(X){return this.items.indexOf(X)!==-1}removeAll(){return this.items.length=0,this}destroy(){this.removeAll(),this.items=null,this._name=null}get empty(){return this.items.length===0}get name(){return this._name}}var p$G=Object.defineProperty,l$p=Object.getOwnPropertySymbols,c$w=Object.prototype.hasOwnProperty,y$l=Object.prototype.propertyIsEnumerable,m$y=(Z,X,K)=>X in Z?p$G(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,i$s=(Z,X)=>{for(var K in X||(X={}))c$w.call(X,K)&&m$y(Z,K,X[K]);if(l$p)for(var K of l$p(X))y$l.call(X,K)&&m$y(Z,K,X[K]);return Z};const x$f=["init","destroy","contextChange","resolutionChange","reset","renderEnd","renderStart","render","update","postrender","prerender"],o$u=class{constructor(Z){this.runners=Object.create(null),this.renderPipes=Object.create(null),this._systemsHash=Object.create(null);var X;this.type=Z.type,this.name=Z.name;const K=[...x$f,...(X=Z.runners)!=null?X:[]];this._addRunners(...K),this._addSystems(Z.systems),this._addPipes(Z.renderPipes,Z.renderPipeAdaptors)}async init(Z={}){for(const X in this._systemsHash){const K=this._systemsHash[X].constructor.defaultOptions;Z=i$s(i$s({},K),Z)}Z=i$s(i$s({},o$u.defaultOptions),Z),this._roundPixels=Z.roundPixels?1:0;for(let X=0;X<this.runners.init.items.length;X++)await this.runners.init.items[X].init(Z)}render(Z,X){let K=Z;if(K instanceof Container&&(K={container:K},X&&(deprecation(v8_0_0,"passing a second argument is deprecated, please use render options instead"),K.target=X.renderTexture)),K.target||(K.target=this.view.texture),K.target===this.view.texture&&(this._lastObjectRendered=K.container),K.clearColor){const J=Array.isArray(K.clearColor)&&K.clearColor.length===4;K.clearColor=J?K.clearColor:Color.shared.setValue(K.clearColor).toArray()}this.runners.prerender.emit(K),this.runners.renderStart.emit(K),this.runners.render.emit(K),this.runners.renderEnd.emit(K),this.runners.postrender.emit(K)}resize(Z,X,K){this.view.resize(Z,X,K)}get resolution(){return this.view.resolution}set resolution(Z){this.view.resolution=Z,this.runners.resolutionChange.emit(Z)}get width(){return this.view.texture.frameWidth}get height(){return this.view.texture.frameHeight}get canvas(){return this.view.canvas}get lastObjectRendered(){return this._lastObjectRendered}get renderingToScreen(){return this.renderTarget.renderingToScreen}get screen(){return this.view.screen}_addRunners(...Z){Z.forEach(X=>{this.runners[X]=new SystemRunner(X)})}_addSystems(Z){let X;for(X in Z){const K=Z[X];this._addSystem(K.value,K.name)}}_addSystem(Z,X){const K=new Z(this);if(this[X])throw new Error(`Whoops! The name "${X}" is already in use`);this[X]=K,this._systemsHash[X]=K;for(const J in this.runners)this.runners[J].add(K);return this}_addPipes(Z,X){const K=X.reduce((J,Q)=>(J[Q.name]=Q.value,J),{});Z.forEach(J=>{const Q=J.value,ee=J.name,te=K[ee];this.renderPipes[ee]=new Q(this,te?new te:null)})}destroy(Z=!1){this.runners.destroy.items.reverse(),this.runners.destroy.emit(Z),Object.values(this.runners).forEach(X=>{X.destroy()}),this._systemsHash=null,this.renderPipes=null}generateTexture(Z){return this.textureGenerator.generateTexture(Z)}get roundPixels(){return!!this._roundPixels}};let AbstractRenderer=o$u;AbstractRenderer.defaultOptions={resolution:1,failIfMajorPerformanceCaveat:!1,roundPixels:!1};let e$8;function isWebGLSupported(Z){return e$8!==void 0||(e$8=(()=>{var X;const K={stencil:!0,failIfMajorPerformanceCaveat:Z!=null?Z:AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat};try{if(!DOMAdapter.get().getWebGLRenderingContext())return!1;let J=DOMAdapter.get().createCanvas().getContext("webgl2",K);const Q=!!((X=J==null?void 0:J.getContextAttributes())!=null&&X.stencil);if(J){const ee=J.getExtension("WEBGL_lose_context");ee&&ee.loseContext()}return J=null,Q}catch(J){return!1}})()),e$8}let e$7;async function isWebGPUSupported(Z={}){return e$7!==void 0||(e$7=await(async()=>{if(!DOMAdapter.get().getNavigator().gpu)return!1;try{return await(await navigator.gpu.requestAdapter(Z)).requestDevice(),!0}catch(X){return!1}})()),e$7}var d$n=Object.defineProperty,s$B=Object.getOwnPropertySymbols,u$s=Object.prototype.hasOwnProperty,w$5=Object.prototype.propertyIsEnumerable,c$v=(Z,X,K)=>X in Z?d$n(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,i$r=(Z,X)=>{for(var K in X||(X={}))u$s.call(X,K)&&c$v(Z,K,X[K]);if(s$B)for(var K of s$B(X))w$5.call(X,K)&&c$v(Z,K,X[K]);return Z};const m$x=["webgpu","webgl","canvas"];async function autoDetectRenderer(Z){var X,K;let J=[];Z.preference?(J.push(Z.preference),m$x.forEach(re=>{re!==Z.preference&&J.push(re)})):J=m$x.slice();let Q;await autoDetectEnvironment((X=Z.manageImports)!=null?X:!0);let ee={};for(let re=0;re<J.length;re++){const ie=J[re];if(ie==="webgpu"&&await isWebGPUSupported()){const{WebGPURenderer:ne}=await Promise.resolve().then(function(){return WebGPURenderer$1});Q=ne,ee=i$r(i$r({},Z),Z.webgpu);break}else if(ie==="webgl"&&isWebGLSupported((K=Z.failIfMajorPerformanceCaveat)!=null?K:AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat)){const{WebGLRenderer:ne}=await Promise.resolve().then(function(){return WebGLRenderer$1});Q=ne,ee=i$r(i$r({},Z),Z.webgl);break}else if(ie==="canvas"){ee=i$r({},Z);break}}delete ee.webgpu,delete ee.webgl;const te=new Q;return await te.init(ee),te}var p$F=Object.defineProperty,n$A=Object.getOwnPropertySymbols,c$u=Object.prototype.hasOwnProperty,l$o=Object.prototype.propertyIsEnumerable,s$A=(Z,X,K)=>X in Z?p$F(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$t=(Z,X)=>{for(var K in X||(X={}))c$u.call(X,K)&&s$A(Z,K,X[K]);if(n$A)for(var K of n$A(X))l$o.call(X,K)&&s$A(Z,K,X[K]);return Z};const i$q=class{constructor(){this.stage=new Container}async init(Z){Z=o$t({},Z),this.renderer=await autoDetectRenderer(Z),i$q._plugins.forEach(X=>{X.init.call(this,Z)})}render(){this.renderer.render({container:this.stage})}get canvas(){return this.renderer.canvas}get screen(){return this.renderer.screen}destroy(Z=!1){const X=i$q._plugins.slice(0);X.reverse(),X.forEach(K=>{K.destroy.call(this)}),this.stage.destroy(Z),this.stage=null,this.renderer.destroy(Z),this.renderer=null}};let Application=i$q;Application._plugins=[],b$p.handleByList(u$v.Application,Application._plugins);class ResizePlugin{static init(X){Object.defineProperty(this,"resizeTo",{set(K){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=K,K&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;this._cancelResize();let K,J;if(this._resizeTo===globalThis.window)K=globalThis.innerWidth,J=globalThis.innerHeight;else{const{clientWidth:Q,clientHeight:ee}=this._resizeTo;K=Q,J=ee}this.renderer.resize(K,J),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=X.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}ResizePlugin.extension=u$v.Application;var UPDATE_PRIORITY=(Z=>(Z[Z.INTERACTION=50]="INTERACTION",Z[Z.HIGH=25]="HIGH",Z[Z.NORMAL=0]="NORMAL",Z[Z.LOW=-25]="LOW",Z[Z.UTILITY=-50]="UTILITY",Z))(UPDATE_PRIORITY||{});class TickerListener{constructor(X,K=null,J=0,Q=!1){this.next=null,this.previous=null,this._destroyed=!1,this._fn=X,this._context=K,this.priority=J,this._once=Q}match(X,K=null){return this._fn===X&&this._context===K}emit(X){this._fn&&(this._context?this._fn.call(this._context,X):this._fn(X));const K=this.next;return this._once&&this.destroy(!0),this._destroyed&&(this.next=null),K}connect(X){this.previous=X,X.next&&(X.next.previous=this),this.next=X.next,X.next=this}destroy(X=!1){this._destroyed=!0,this._fn=null,this._context=null,this.previous&&(this.previous.next=this.next),this.next&&(this.next.previous=this.previous);const K=this.next;return this.next=X?null:K,this.previous=null,K}}const s$z=class{constructor(){this.autoStart=!1,this.deltaTime=1,this.lastTime=-1,this.speed=1,this.started=!1,this._requestId=null,this._maxElapsedMS=100,this._minElapsedMS=0,this._protected=!1,this._lastFrame=-1,this._head=new TickerListener(null,null,1/0),this.deltaMS=1/s$z.targetFPMS,this.elapsedMS=1/s$z.targetFPMS,this._tick=Z=>{this._requestId=null,this.started&&(this.update(Z),this.started&&this._requestId===null&&this._head.next&&(this._requestId=requestAnimationFrame(this._tick)))}}_requestIfNeeded(){this._requestId===null&&this._head.next&&(this.lastTime=performance.now(),this._lastFrame=this.lastTime,this._requestId=requestAnimationFrame(this._tick))}_cancelIfNeeded(){this._requestId!==null&&(cancelAnimationFrame(this._requestId),this._requestId=null)}_startIfPossible(){this.started?this._requestIfNeeded():this.autoStart&&this.start()}add(Z,X,K=UPDATE_PRIORITY.NORMAL){return this._addListener(new TickerListener(Z,X,K))}addOnce(Z,X,K=UPDATE_PRIORITY.NORMAL){return this._addListener(new TickerListener(Z,X,K,!0))}_addListener(Z){let X=this._head.next,K=this._head;if(!X)Z.connect(K);else{for(;X;){if(Z.priority>X.priority){Z.connect(K);break}K=X,X=X.next}Z.previous||Z.connect(K)}return this._startIfPossible(),this}remove(Z,X){let K=this._head.next;for(;K;)K.match(Z,X)?K=K.destroy():K=K.next;return this._head.next||this._cancelIfNeeded(),this}get count(){if(!this._head)return 0;let Z=0,X=this._head;for(;X=X.next;)Z++;return Z}start(){this.started||(this.started=!0,this._requestIfNeeded())}stop(){this.started&&(this.started=!1,this._cancelIfNeeded())}destroy(){if(!this._protected){this.stop();let Z=this._head.next;for(;Z;)Z=Z.destroy(!0);this._head.destroy(),this._head=null}}update(Z=performance.now()){let X;if(Z>this.lastTime){if(X=this.elapsedMS=Z-this.lastTime,X>this._maxElapsedMS&&(X=this._maxElapsedMS),X*=this.speed,this._minElapsedMS){const Q=Z-this._lastFrame|0;if(Q<this._minElapsedMS)return;this._lastFrame=Z-Q%this._minElapsedMS}this.deltaMS=X,this.deltaTime=this.deltaMS*s$z.targetFPMS;const K=this._head;let J=K.next;for(;J;)J=J.emit(this);K.next||this._cancelIfNeeded()}else this.deltaTime=this.deltaMS=this.elapsedMS=0;this.lastTime=Z}get FPS(){return 1e3/this.elapsedMS}get minFPS(){return 1e3/this._maxElapsedMS}set minFPS(Z){const X=Math.min(this.maxFPS,Z),K=Math.min(Math.max(0,X)/1e3,s$z.targetFPMS);this._maxElapsedMS=1/K}get maxFPS(){return this._minElapsedMS?Math.round(1e3/this._minElapsedMS):0}set maxFPS(Z){if(Z===0)this._minElapsedMS=0;else{const X=Math.max(this.minFPS,Z);this._minElapsedMS=1/(X/1e3)}}static get shared(){if(!s$z._shared){const Z=s$z._shared=new s$z;Z.autoStart=!0,Z._protected=!0}return s$z._shared}static get system(){if(!s$z._system){const Z=s$z._system=new s$z;Z.autoStart=!0,Z._protected=!0}return s$z._system}};let Ticker=s$z;Ticker.targetFPMS=.06;class TickerPlugin{static init(X){X=Object.assign({autoStart:!0,sharedTicker:!1},X),Object.defineProperty(this,"ticker",{set(K){this._ticker&&this._ticker.remove(this.render,this),this._ticker=K,K&&K.add(this.render,this,UPDATE_PRIORITY.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=X.sharedTicker?Ticker.shared:new Ticker,X.autoStart&&this.start()}static destroy(){if(this._ticker){const X=this._ticker;this.ticker=null,X.destroy()}}}TickerPlugin.extension=u$v.Application,b$p.add(ResizePlugin),b$p.add(TickerPlugin);class BackgroundLoader{constructor(X,K=!1){this._loader=X,this._assetList=[],this._isLoading=!1,this._maxConcurrent=1,this.verbose=K}add(X){X.forEach(K=>{this._assetList.push(K)}),this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList),this._isActive&&!this._isLoading&&this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=!0;const X=[],K=Math.min(this._assetList.length,this._maxConcurrent);for(let J=0;J<K;J++)X.push(this._assetList.pop());await this._loader.load(X),this._isLoading=!1,this._next()}}get active(){return this._isActive}set active(X){this._isActive!==X&&(this._isActive=X,X&&!this._isLoading&&this._next())}}const convertToList=(Z,X,K=!1)=>(Array.isArray(Z)||(Z=[Z]),X?Z.map(J=>typeof J=="string"||K?X(J):J):Z);class p$E{constructor(){this._parsers=[],this._cache=new Map,this._cacheMap=new Map}reset(){this._cacheMap.clear(),this._cache.clear()}has(X){return this._cache.has(X)}get(X){return this._cache.get(X)}set(X,K){const J=convertToList(X);let Q;for(let ie=0;ie<this.parsers.length;ie++){const ne=this.parsers[ie];if(ne.test(K)){Q=ne.getCacheableAssets(J,K);break}}const ee=new Map(Object.entries(Q||{}));Q||J.forEach(ie=>{ee.set(ie,K)});const te=[...ee.keys()],re={cacheKeys:te,keys:J};J.forEach(ie=>{this._cacheMap.set(ie,re)}),te.forEach(ie=>{this._cache.has(ie)&&this._cache.get(ie),this._cache.set(ie,ee.get(ie))})}remove(X){if(!this._cacheMap.has(X))return;const K=this._cacheMap.get(X);K.cacheKeys.forEach(J=>{this._cache.delete(J)}),K.keys.forEach(J=>{this._cacheMap.delete(J)})}get parsers(){return this._parsers}}const Cache=new p$E;function f$t(Z){if(typeof Z!="string")throw new TypeError(`Path must be a string. Received ${JSON.stringify(Z)}`)}function d$m(Z){return Z.split("?")[0].split("#")[0]}function b$m(Z){return Z.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function P$d(Z,X,K){return Z.replace(new RegExp(b$m(X),"g"),K)}function m$w(Z,X){let K="",J=0,Q=-1,ee=0,te=-1;for(let re=0;re<=Z.length;++re){if(re<Z.length)te=Z.charCodeAt(re);else{if(te===47)break;te=47}if(te===47){if(!(Q===re-1||ee===1))if(Q!==re-1&&ee===2){if(K.length<2||J!==2||K.charCodeAt(K.length-1)!==46||K.charCodeAt(K.length-2)!==46){if(K.length>2){const ie=K.lastIndexOf("/");if(ie!==K.length-1){ie===-1?(K="",J=0):(K=K.slice(0,ie),J=K.length-1-K.lastIndexOf("/")),Q=re,ee=0;continue}}else if(K.length===2||K.length===1){K="",J=0,Q=re,ee=0;continue}}X&&(K.length>0?K+="/..":K="..",J=2)}else K.length>0?K+=`/${Z.slice(Q+1,re)}`:K=Z.slice(Q+1,re),J=re-Q-1;Q=re,ee=0}else te===46&&ee!==-1?++ee:ee=-1}return K}const path={toPosix(Z){return P$d(Z,"\\","/")},isUrl(Z){return/^https?:/.test(this.toPosix(Z))},isDataUrl(Z){return/^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(Z)},isBlobUrl(Z){return Z.startsWith("blob:")},hasProtocol(Z){return/^[^/:]+:/.test(this.toPosix(Z))},getProtocol(Z){f$t(Z),Z=this.toPosix(Z);const X=/^file:\/\/\//.exec(Z);if(X)return X[0];const K=/^[^/:]+:\/{0,2}/.exec(Z);return K?K[0]:""},toAbsolute(Z,X,K){if(f$t(Z),this.isDataUrl(Z)||this.isBlobUrl(Z))return Z;const J=d$m(this.toPosix(X!=null?X:DOMAdapter.get().getBaseUrl())),Q=d$m(this.toPosix(K!=null?K:this.rootname(J)));return Z=this.toPosix(Z),Z.startsWith("/")?path.join(Q,Z.slice(1)):this.isAbsolute(Z)?Z:this.join(J,Z)},normalize(Z){if(f$t(Z),Z.length===0)return".";if(this.isDataUrl(Z)||this.isBlobUrl(Z))return Z;Z=this.toPosix(Z);let X="";const K=Z.startsWith("/");this.hasProtocol(Z)&&(X=this.rootname(Z),Z=Z.slice(X.length));const J=Z.endsWith("/");return Z=m$w(Z,!1),Z.length>0&&J&&(Z+="/"),K?`/${Z}`:X+Z},isAbsolute(Z){return f$t(Z),Z=this.toPosix(Z),this.hasProtocol(Z)?!0:Z.startsWith("/")},join(...Z){var X;if(Z.length===0)return".";let K;for(let J=0;J<Z.length;++J){const Q=Z[J];if(f$t(Q),Q.length>0)if(K===void 0)K=Q;else{const ee=(X=Z[J-1])!=null?X:"";this.extname(ee)?K+=`/../${Q}`:K+=`/${Q}`}}return K===void 0?".":this.normalize(K)},dirname(Z){if(f$t(Z),Z.length===0)return".";Z=this.toPosix(Z);let X=Z.charCodeAt(0);const K=X===47;let J=-1,Q=!0;const ee=this.getProtocol(Z),te=Z;Z=Z.slice(ee.length);for(let re=Z.length-1;re>=1;--re)if(X=Z.charCodeAt(re),X===47){if(!Q){J=re;break}}else Q=!1;return J===-1?K?"/":this.isUrl(te)?ee+Z:ee:K&&J===1?"//":ee+Z.slice(0,J)},rootname(Z){f$t(Z),Z=this.toPosix(Z);let X="";if(Z.startsWith("/")?X="/":X=this.getProtocol(Z),this.isUrl(Z)){const K=Z.indexOf("/",X.length);K!==-1?X=Z.slice(0,K):X=Z,X.endsWith("/")||(X+="/")}return X},basename(Z,X){f$t(Z),X&&f$t(X),Z=d$m(this.toPosix(Z));let K=0,J=-1,Q=!0,ee;if(X!==void 0&&X.length>0&&X.length<=Z.length){if(X.length===Z.length&&X===Z)return"";let te=X.length-1,re=-1;for(ee=Z.length-1;ee>=0;--ee){const ie=Z.charCodeAt(ee);if(ie===47){if(!Q){K=ee+1;break}}else re===-1&&(Q=!1,re=ee+1),te>=0&&(ie===X.charCodeAt(te)?--te===-1&&(J=ee):(te=-1,J=re))}return K===J?J=re:J===-1&&(J=Z.length),Z.slice(K,J)}for(ee=Z.length-1;ee>=0;--ee)if(Z.charCodeAt(ee)===47){if(!Q){K=ee+1;break}}else J===-1&&(Q=!1,J=ee+1);return J===-1?"":Z.slice(K,J)},extname(Z){f$t(Z),Z=d$m(this.toPosix(Z));let X=-1,K=0,J=-1,Q=!0,ee=0;for(let te=Z.length-1;te>=0;--te){const re=Z.charCodeAt(te);if(re===47){if(!Q){K=te+1;break}continue}J===-1&&(Q=!1,J=te+1),re===46?X===-1?X=te:ee!==1&&(ee=1):X!==-1&&(ee=-1)}return X===-1||J===-1||ee===0||ee===1&&X===J-1&&X===K+1?"":Z.slice(X,J)},parse(Z){f$t(Z);const X={root:"",dir:"",base:"",ext:"",name:""};if(Z.length===0)return X;Z=d$m(this.toPosix(Z));let K=Z.charCodeAt(0);const J=this.isAbsolute(Z);let Q;const ee="";X.root=this.rootname(Z),J||this.hasProtocol(Z)?Q=1:Q=0;let te=-1,re=0,ie=-1,ne=!0,se=Z.length-1,oe=0;for(;se>=Q;--se){if(K=Z.charCodeAt(se),K===47){if(!ne){re=se+1;break}continue}ie===-1&&(ne=!1,ie=se+1),K===46?te===-1?te=se:oe!==1&&(oe=1):te!==-1&&(oe=-1)}return te===-1||ie===-1||oe===0||oe===1&&te===ie-1&&te===re+1?ie!==-1&&(re===0&&J?X.base=X.name=Z.slice(1,ie):X.base=X.name=Z.slice(re,ie)):(re===0&&J?(X.name=Z.slice(1,te),X.base=Z.slice(1,ie)):(X.name=Z.slice(re,te),X.base=Z.slice(re,ie)),X.ext=Z.slice(te,ie)),X.dir=this.dirname(Z),ee&&(X.dir=ee+X.dir),X},sep:"/",delimiter:":"},isSingleItem=Z=>!Array.isArray(Z);var g$n=Object.defineProperty,A$6=Object.defineProperties,y$k=Object.getOwnPropertyDescriptors,c$t=Object.getOwnPropertySymbols,R$2=Object.prototype.hasOwnProperty,_$9=Object.prototype.propertyIsEnumerable,m$v=(Z,X,K)=>X in Z?g$n(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,h$r=(Z,X)=>{for(var K in X||(X={}))R$2.call(X,K)&&m$v(Z,K,X[K]);if(c$t)for(var K of c$t(X))_$9.call(X,K)&&m$v(Z,K,X[K]);return Z},P$c=(Z,X)=>A$6(Z,y$k(X));class Loader{constructor(){this._parsers=[],this._parsersValidated=!1,this.parsers=new Proxy(this._parsers,{set:(X,K,J)=>(this._parsersValidated=!1,X[K]=J,!0)}),this.promiseCache={}}reset(){this._parsersValidated=!1,this.promiseCache={}}_getLoadPromiseAndParser(X,K){const J={promise:null,parser:null};return J.promise=(async()=>{var Q,ee;let te=null,re=null;if(K.loadParser&&(re=this._parserHash[K.loadParser]),!re){for(let ie=0;ie<this.parsers.length;ie++){const ne=this.parsers[ie];if(ne.load&&(Q=ne.test)!=null&&Q.call(ne,X,K,this)){re=ne;break}}if(!re)return null}te=await re.load(X,K,this),J.parser=re;for(let ie=0;ie<this.parsers.length;ie++){const ne=this.parsers[ie];ne.parse&&ne.parse&&await((ee=ne.testParse)==null?void 0:ee.call(ne,te,K,this))&&(te=await ne.parse(te,K,this)||te,J.parser=ne)}return te})(),J}async load(X,K){this._parsersValidated||this._validateParsers();let J=0;const Q={},ee=isSingleItem(X),te=convertToList(X,ne=>({alias:[ne],src:ne})),re=te.length,ie=te.map(async ne=>{const se=path.toAbsolute(ne.src);if(!Q[ne.src])try{this.promiseCache[se]||(this.promiseCache[se]=this._getLoadPromiseAndParser(se,ne)),Q[ne.src]=await this.promiseCache[se].promise,K&&K(++J/re)}catch(oe){throw delete this.promiseCache[se],delete Q[ne.src],new Error(`[Loader.load] Failed to load ${se}.
${oe}`)}});return await Promise.all(ie),ee?Q[te[0].src]:Q}async unload(X){const K=convertToList(X,J=>({alias:[J],src:J})).map(async J=>{var Q,ee;const te=path.toAbsolute(J.src),re=this.promiseCache[te];if(re){const ie=await re.promise;delete this.promiseCache[te],(ee=(Q=re.parser)==null?void 0:Q.unload)==null||ee.call(Q,ie,J,this)}});await Promise.all(K)}_validateParsers(){this._parsersValidated=!0,this._parserHash=this._parsers.filter(X=>X.name).reduce((X,K)=>(K.name&&X[K.name],P$c(h$r({},X),{[K.name]:K})),{})}}function g$m(Z,X,K,J,Q){const ee=X[K];for(let te=0;te<ee.length;te++){const re=ee[te];K<X.length-1?g$m(Z.replace(J[K],re),X,K+1,J,Q):Q.push(Z.replace(J[K],re))}}function createStringVariations(Z){const X=/\{(.*?)\}/g,K=Z.match(X),J=[];if(K){const Q=[];K.forEach(ee=>{const te=ee.substring(1,ee.length-1).split(",");Q.push(te)}),g$m(Z,Q,0,K,J)}else J.push(Z);return J}var S$c=Object.defineProperty,U$4=Object.defineProperties,E$5=Object.getOwnPropertyDescriptors,B$7=Object.getOwnPropertySymbols,x$e=Object.prototype.hasOwnProperty,$$1=Object.prototype.propertyIsEnumerable,P$b=(Z,X,K)=>X in Z?S$c(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,p$D=(Z,X)=>{for(var K in X||(X={}))x$e.call(X,K)&&P$b(Z,K,X[K]);if(B$7)for(var K of B$7(X))$$1.call(X,K)&&P$b(Z,K,X[K]);return Z},O$5=(Z,X)=>U$4(Z,E$5(X));class Resolver{constructor(){this._defaultBundleIdentifierOptions={connector:"-",createBundleAssetId:(X,K)=>`${X}${this._bundleIdConnector}${K}`,extractAssetIdFromBundle:(X,K)=>K.replace(`${X}${this._bundleIdConnector}`,"")},this._bundleIdConnector=this._defaultBundleIdentifierOptions.connector,this._createBundleAssetId=this._defaultBundleIdentifierOptions.createBundleAssetId,this._extractAssetIdFromBundle=this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,this._assetMap={},this._preferredOrder=[],this._parsers=[],this._resolverHash={},this._bundles={}}setBundleIdentifier(X){var K,J,Q;if(this._bundleIdConnector=(K=X.connector)!=null?K:this._bundleIdConnector,this._createBundleAssetId=(J=X.createBundleAssetId)!=null?J:this._createBundleAssetId,this._extractAssetIdFromBundle=(Q=X.extractAssetIdFromBundle)!=null?Q:this._extractAssetIdFromBundle,this._extractAssetIdFromBundle("foo",this._createBundleAssetId("foo","bar"))!=="bar")throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")}prefer(...X){X.forEach(K=>{this._preferredOrder.push(K),K.priority||(K.priority=Object.keys(K.params))}),this._resolverHash={}}set basePath(X){this._basePath=X}get basePath(){return this._basePath}set rootPath(X){this._rootPath=X}get rootPath(){return this._rootPath}get parsers(){return this._parsers}reset(){this.setBundleIdentifier(this._defaultBundleIdentifierOptions),this._assetMap={},this._preferredOrder=[],this._resolverHash={},this._rootPath=null,this._basePath=null,this._manifest=null,this._bundles={},this._defaultSearchParams=null}setDefaultSearchParams(X){if(typeof X=="string")this._defaultSearchParams=X;else{const K=X;this._defaultSearchParams=Object.keys(K).map(J=>`${encodeURIComponent(J)}=${encodeURIComponent(K[J])}`).join("&")}}getAlias(X){const{alias:K,src:J}=X;return convertToList(K||J,Q=>typeof Q=="string"?Q:Array.isArray(Q)?Q.map(ee=>{var te;return(te=ee==null?void 0:ee.src)!=null?te:ee}):Q!=null&&Q.src?Q.src:Q,!0)}addManifest(X){this._manifest,this._manifest=X,X.bundles.forEach(K=>{this.addBundle(K.name,K.assets)})}addBundle(X,K){const J=[];K.forEach(Q=>{const ee=Q.src,te=Q.alias;let re;if(typeof te=="string"){const ie=this._createBundleAssetId(X,te);J.push(ie),re=[te,ie]}else{const ie=te.map(ne=>this._createBundleAssetId(X,ne));J.push(...ie),re=[...te,...ie]}this.add(O$5(p$D({},Q),{alias:re,src:ee}))}),this._bundles[X]=J}add(X){const K=[];Array.isArray(X)?K.push(...X):K.push(X);let J;convertToList(K).forEach(Q=>{const{src:ee}=Q;let{data:te,format:re,loadParser:ie}=Q;const ne=convertToList(ee).map(ae=>typeof ae=="string"?createStringVariations(ae):Array.isArray(ae)?ae:[ae]),se=this.getAlias(Q),oe=[];ne.forEach(ae=>{ae.forEach(le=>{var ce,de,he;let pe={};if(typeof le!="object"){pe.src=le;for(let fe=0;fe<this._parsers.length;fe++){const ge=this._parsers[fe];if(ge.test(le)){pe=ge.parse(le);break}}}else te=(ce=le.data)!=null?ce:te,re=(de=le.format)!=null?de:re,ie=(he=le.loadParser)!=null?he:ie,pe=p$D(p$D({},pe),le);if(!se)throw new Error(`[Resolver] alias is undefined for this asset: ${pe.src}`);pe=this._buildResolvedAsset(pe,{aliases:se,data:te,format:re,loadParser:ie}),oe.push(pe)})}),se.forEach(ae=>{this._assetMap[ae]=oe})})}resolveBundle(X){const K=isSingleItem(X);X=convertToList(X);const J={};return X.forEach(Q=>{const ee=this._bundles[Q];if(ee){const te=this.resolve(ee),re={};for(const ie in te){const ne=te[ie];re[this._extractAssetIdFromBundle(Q,ie)]=ne}J[Q]=re}}),K?J[X[0]]:J}resolveUrl(X){const K=this.resolve(X);if(typeof X!="string"){const J={};for(const Q in K)J[Q]=K[Q].src;return J}return K.src}resolve(X){const K=isSingleItem(X);X=convertToList(X);const J={};return X.forEach(Q=>{if(!this._resolverHash[Q])if(this._assetMap[Q]){let ee=this._assetMap[Q];const te=this._getPreferredOrder(ee);te==null||te.priority.forEach(re=>{te.params[re].forEach(ie=>{const ne=ee.filter(se=>se[re]?se[re]===ie:!1);ne.length&&(ee=ne)})}),this._resolverHash[Q]=ee[0]}else this._resolverHash[Q]=this._buildResolvedAsset({alias:[Q],src:Q},{});J[Q]=this._resolverHash[Q]}),K?J[X[0]]:J}hasKey(X){return!!this._assetMap[X]}hasBundle(X){return!!this._bundles[X]}_getPreferredOrder(X){for(let K=0;K<X.length;K++){const J=X[0],Q=this._preferredOrder.find(ee=>ee.params.format.includes(J.format));if(Q)return Q}return this._preferredOrder[0]}_appendDefaultSearchParams(X){if(!this._defaultSearchParams)return X;const K=/\?/.test(X)?"&":"?";return`${X}${K}${this._defaultSearchParams}`}_buildResolvedAsset(X,K){var J,Q;const{aliases:ee,data:te,loadParser:re,format:ie}=K;return(this._basePath||this._rootPath)&&(X.src=path.toAbsolute(X.src,this._basePath,this._rootPath)),X.alias=(J=ee!=null?ee:X.alias)!=null?J:[X.src],X.src=this._appendDefaultSearchParams(X.src),X.data=p$D(p$D({},te||{}),X.data),X.loadParser=re!=null?re:X.loadParser,X.format=(Q=ie!=null?ie:X.format)!=null?Q:getUrlExtension(X.src),X}}Resolver.RETINA_PREFIX=/@([0-9\.]+)x/;function getUrlExtension(Z){return Z.split(".").pop().split("?").shift().split("#").shift()}class AssetsClass{constructor(){this._detections=[],this._initialized=!1,this.resolver=new Resolver,this.loader=new Loader,this.cache=Cache,this._backgroundLoader=new BackgroundLoader(this.loader),this._backgroundLoader.active=!0,this.reset()}async init(X={}){var K,J,Q;if(this._initialized)return;if(this._initialized=!0,X.defaultSearchParams&&this.resolver.setDefaultSearchParams(X.defaultSearchParams),X.basePath&&(this.resolver.basePath=X.basePath),X.bundleIdentifier&&this.resolver.setBundleIdentifier(X.bundleIdentifier),X.manifest){let ie=X.manifest;typeof ie=="string"&&(ie=await this.load(ie)),this.resolver.addManifest(ie)}const ee=(J=(K=X.texturePreference)==null?void 0:K.resolution)!=null?J:1,te=typeof ee=="number"?[ee]:ee,re=await this._detectFormats({preferredFormats:(Q=X.texturePreference)==null?void 0:Q.format,skipDetections:X.skipDetections,detections:this._detections});this.resolver.prefer({params:{format:re,resolution:te}}),X.preferences&&this.setPreferences(X.preferences)}add(X){this.resolver.add(X)}async load(X,K){this._initialized||await this.init();const J=isSingleItem(X),Q=convertToList(X).map(re=>{if(typeof re!="string"){const ie=this.resolver.getAlias(re);return ie.some(ne=>!this.resolver.hasKey(ne))&&this.add(re),Array.isArray(ie)?ie[0]:ie}return this.resolver.hasKey(re)||this.add({alias:re,src:re}),re}),ee=this.resolver.resolve(Q),te=await this._mapLoadToResolve(ee,K);return J?te[Q[0]]:te}addBundle(X,K){this.resolver.addBundle(X,K)}async loadBundle(X,K){this._initialized||await this.init();let J=!1;typeof X=="string"&&(J=!0,X=[X]);const Q=this.resolver.resolveBundle(X),ee={},te=Object.keys(Q);let re=0,ie=0;const ne=()=>{K==null||K(++re/ie)},se=te.map(oe=>{const ae=Q[oe];return ie+=Object.keys(ae).length,this._mapLoadToResolve(ae,ne).then(le=>{ee[oe]=le})});return await Promise.all(se),J?ee[X[0]]:ee}async backgroundLoad(X){this._initialized||await this.init(),typeof X=="string"&&(X=[X]);const K=this.resolver.resolve(X);this._backgroundLoader.add(Object.values(K))}async backgroundLoadBundle(X){this._initialized||await this.init(),typeof X=="string"&&(X=[X]);const K=this.resolver.resolveBundle(X);Object.values(K).forEach(J=>{this._backgroundLoader.add(Object.values(J))})}reset(){this.resolver.reset(),this.loader.reset(),this.cache.reset(),this._initialized=!1}get(X){if(typeof X=="string")return Cache.get(X);const K={};for(let J=0;J<X.length;J++)K[J]=Cache.get(X[J]);return K}async _mapLoadToResolve(X,K){const J=Object.values(X),Q=Object.keys(X);this._backgroundLoader.active=!1;const ee=await this.loader.load(J,K);this._backgroundLoader.active=!0;const te={};return J.forEach((re,ie)=>{const ne=ee[re.src],se=[re.src];re.alias&&se.push(...re.alias),te[Q[ie]]=ne,Cache.set(se,ne)}),te}async unload(X){this._initialized||await this.init();const K=convertToList(X).map(Q=>typeof Q!="string"?Q.src:Q),J=this.resolver.resolve(K);await this._unloadFromResolved(J)}async unloadBundle(X){this._initialized||await this.init(),X=convertToList(X);const K=this.resolver.resolveBundle(X),J=Object.keys(K).map(Q=>this._unloadFromResolved(K[Q]));await Promise.all(J)}async _unloadFromResolved(X){const K=Object.values(X);K.forEach(J=>{Cache.remove(J.src)}),await this.loader.unload(K)}async _detectFormats(X){let K=[];X.preferredFormats&&(K=Array.isArray(X.preferredFormats)?X.preferredFormats:[X.preferredFormats]);for(const J of X.detections)X.skipDetections||await J.test()?K=await J.add(K):X.skipDetections||(K=await J.remove(K));return K=K.filter((J,Q)=>K.indexOf(J)===Q),K}get detections(){return this._detections}setPreferences(X){this.loader.parsers.forEach(K=>{K.config&&Object.keys(K.config).filter(J=>J in X).forEach(J=>{K.config[J]=X[J]})})}}const Assets=new AssetsClass;b$p.handleByList(u$v.LoadParser,Assets.loader.parsers).handleByList(u$v.ResolveParser,Assets.resolver.parsers).handleByList(u$v.CacheParser,Assets.cache.parsers).handleByList(u$v.DetectionParser,Assets.detections);const NOOP=()=>{},c$s=[];b$p.handleByList(u$v.TextureSource,c$s);function autoDetectSource(Z={}){for(let X=0;X<c$s.length;X++){const K=c$s[X];if(K.test(Z.resource))return new K(Z)}throw new Error(`Could not find a source type for resource: ${Z.resource}`)}function resourceToTexture(Z={},X=!1){const{resource:K}=Z;if(!X&&Cache.has(K))return Cache.get(K);const J=new Texture({source:autoDetectSource(Z)});return J.on("destroy",()=>{Cache.has(K)&&Cache.remove(K)}),X||Cache.set(K,J),J}const t$e=Object.create(null),i$p=Object.create(null);function createIdFromString(Z,X){let K=i$p[Z];return K===void 0&&(t$e[X]===void 0&&(t$e[X]=1),i$p[Z]=K=t$e[X]++),K}var u$r=Object.defineProperty,h$q=Object.getOwnPropertySymbols,c$r=Object.prototype.hasOwnProperty,_$8=Object.prototype.propertyIsEnumerable,n$z=(Z,X,K)=>X in Z?u$r(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,t$d=(Z,X)=>{for(var K in X||(X={}))c$r.call(X,K)&&n$z(Z,K,X[K]);if(h$q)for(var K of h$q(X))_$8.call(X,K)&&n$z(Z,K,X[K]);return Z};const d$l=class extends eventemitter3{constructor(Z={}){var X,K,J,Q,ee,te,re;super(),this._resourceType="textureSampler",this._touched=0,this._maxAnisotropy=1,Z=t$d(t$d({},d$l.defaultOptions),Z),this.addressMode=Z.addressMode,this.addressModeU=(X=Z.addressModeU)!=null?X:this.addressModeU,this.addressModeV=(K=Z.addressModeV)!=null?K:this.addressModeV,this.addressModeW=(J=Z.addressModeW)!=null?J:this.addressModeW,this.scaleMode=Z.scaleMode,this.magFilter=(Q=Z.magFilter)!=null?Q:this.magFilter,this.minFilter=(ee=Z.minFilter)!=null?ee:this.minFilter,this.mipmapFilter=(te=Z.mipmapFilter)!=null?te:this.mipmapFilter,this.lodMinClamp=Z.lodMinClamp,this.lodMaxClamp=Z.lodMaxClamp,this.compare=Z.compare,this.maxAnisotropy=(re=Z.maxAnisotropy)!=null?re:1}set addressMode(Z){this.addressModeU=Z,this.addressModeV=Z,this.addressModeW=Z}get addressMode(){return this.addressModeU}set wrapMode(Z){deprecation("8","TextureStyle.wrapMode is now TextureStyle.addressMode"),this.addressMode=Z}get wrapMode(){return this.addressMode}set scaleMode(Z){this.magFilter=Z,this.minFilter=Z,this.mipmapFilter=Z}get scaleMode(){return this.magFilter}set maxAnisotropy(Z){this._maxAnisotropy=Math.min(Z,16),this._maxAnisotropy>1&&(this.scaleMode="linear")}get maxAnisotropy(){return this._maxAnisotropy}get _resourceId(){return this._sharedResourceId||this._generateResourceId()}update(){this.emit("change",this),this._sharedResourceId=null}_generateResourceId(){const Z=`${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;return this._sharedResourceId=createIdFromString(Z,"sampler"),this._resourceId}destroy(){this.emit("destroy",this),this.removeAllListeners()}};let TextureStyle=d$l;TextureStyle.defaultOptions={addressMode:"clamp-to-edge",scaleMode:"linear"};var x$d=Object.defineProperty,m$u=Object.getOwnPropertySymbols,S$b=Object.prototype.hasOwnProperty,T$b=Object.prototype.propertyIsEnumerable,y$j=(Z,X,K)=>X in Z?x$d(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,a$x=(Z,X)=>{for(var K in X||(X={}))S$b.call(X,K)&&y$j(Z,K,X[K]);if(m$u)for(var K of m$u(X))T$b.call(X,K)&&y$j(Z,K,X[K]);return Z};const n$y=class extends eventemitter3{constructor(Z={}){var X,K,J,Q,ee,te;super(),this.options=Z,this.uid=uid("textureSource"),this.label="",this._resourceType="textureSource",this._resourceId=uid("textureResource"),this.uploadMethodId="unknown",this._resolution=1,this.pixelWidth=1,this.pixelHeight=1,this.width=1,this.height=1,this.sampleCount=1,this.mipLevelCount=1,this.autoGenerateMipmaps=!1,this.format="rgba8unorm",this.dimension="2d",this.antialias=!1,this.depthStencil=!0,this._touched=0,this._batchTick=-1,this._textureBindLocation=-1,Z=a$x(a$x({},n$y.defaultOptions),Z),(X=this.label)!=null||(this.label=Z.label),this.resource=Z.resource,this._resolution=Z.resolution,Z.width?this.pixelWidth=Z.width*this._resolution:this.pixelWidth=(J=(K=Z.resource)==null?void 0:K.width)!=null?J:1,Z.height?this.pixelHeight=Z.height*this._resolution:this.pixelHeight=(ee=(Q=Z.resource)==null?void 0:Q.height)!=null?ee:1,this.width=this.pixelWidth/this._resolution,this.height=this.pixelHeight/this._resolution,this.format=Z.format,this.dimension=Z.dimensions,this.mipLevelCount=Z.mipLevelCount,this.autoGenerateMipmaps=Z.autoGenerateMipmaps,this.sampleCount=Z.sampleCount,this.antialias=Z.antialias,this.alphaMode=Z.alphaMode;const re=(te=Z.style)!=null?te:{};this.style=re instanceof TextureStyle?re:new TextureStyle(re),this.destroyed=!1}get source(){return this}get style(){return this._style}set style(Z){var X,K;this.style!==Z&&((X=this._style)==null||X.off("change",this._onStyleChange,this),this._style=Z,(K=this._style)==null||K.on("change",this._onStyleChange,this),this._onStyleChange())}_onStyleChange(){this.emit("styleChange",this)}update(){this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this._style&&(this._style.destroy(),this._style=null),this.uploadMethodId=null,this.resource=null,this.removeAllListeners()}unload(){this._resourceId++,this.emit("change",this),this.emit("unload",this)}get resourceWidth(){const{resource:Z}=this;return Z.naturalWidth||Z.videoWidth||Z.displayWidth||Z.width}get resourceHeight(){const{resource:Z}=this;return Z.naturalHeight||Z.videoHeight||Z.displayHeight||Z.height}get resolution(){return this._resolution}set resolution(Z){this._resolution!==Z&&(this._resolution=Z,this.width=this.pixelWidth/Z,this.height=this.pixelHeight/Z)}resize(Z,X,K){K=K||this._resolution,Z=Z||this.width,X=X||this.height;const J=Math.round(Z*K),Q=Math.round(X*K);this.width=J/K,this.height=Q/K,this._resolution=K,!(this.pixelWidth===J&&this.pixelHeight===Q)&&(this.pixelWidth=J,this.pixelHeight=Q,this.emit("resize",this),this._resourceId++,this.emit("change",this))}set wrapMode(Z){deprecation(v8_0_0,"TextureSource.wrapMode property has been deprecated. Use TextureSource.style.addressMode instead."),this._style.wrapMode=Z}get wrapMode(){return deprecation(v8_0_0,"TextureSource.wrapMode property has been deprecated. Use TextureSource.style.addressMode instead."),this._style.wrapMode}set scaleMode(Z){deprecation(v8_0_0,"TextureSource.scaleMode property has been deprecated. Use TextureSource.style.scaleMode instead."),this._style.scaleMode=Z}get scaleMode(){return deprecation(v8_0_0,"TextureSource.scaleMode property has been deprecated. Use TextureSource.style.scaleMode instead."),this._style.scaleMode}static test(Z){throw new Error("Unimplemented")}};let TextureSource=n$y;TextureSource.defaultOptions={resolution:1,format:"bgra8unorm",alphaMode:"premultiply-alpha-on-upload",dimensions:"2d",mipLevelCount:1,autoGenerateMipmaps:!1,sampleCount:1,antialias:!1,style:{}};const n$x=[1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1],y$i=[0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1],i$o=[0,-1,-1,-1,0,1,1,1,0,1,1,1,0,-1,-1,-1],o$s=[1,1,0,-1,-1,-1,0,1,-1,-1,0,1,1,1,0,-1],a$w=[],D$1=[],u$q=Math.sign;function f$s(){for(let Z=0;Z<16;Z++){const X=[];a$w.push(X);for(let K=0;K<16;K++){const J=u$q(n$x[Z]*n$x[K]+i$o[Z]*y$i[K]),Q=u$q(y$i[Z]*n$x[K]+o$s[Z]*y$i[K]),ee=u$q(n$x[Z]*i$o[K]+i$o[Z]*o$s[K]),te=u$q(y$i[Z]*i$o[K]+o$s[Z]*o$s[K]);for(let re=0;re<16;re++)if(n$x[re]===J&&y$i[re]===Q&&i$o[re]===ee&&o$s[re]===te){X.push(re);break}}}for(let Z=0;Z<16;Z++){const X=new Matrix;X.set(n$x[Z],y$i[Z],i$o[Z],o$s[Z],0,0),D$1.push(X)}}f$s();const groupD8={E:0,SE:1,S:2,SW:3,W:4,NW:5,N:6,NE:7,MIRROR_VERTICAL:8,MAIN_DIAGONAL:10,MIRROR_HORIZONTAL:12,REVERSE_DIAGONAL:14,uX:Z=>n$x[Z],uY:Z=>y$i[Z],vX:Z=>i$o[Z],vY:Z=>o$s[Z],inv:Z=>Z&8?Z&15:-Z&7,add:(Z,X)=>a$w[Z][X],sub:(Z,X)=>a$w[Z][groupD8.inv(X)],rotate180:Z=>Z^4,isVertical:Z=>(Z&3)===2,byDirection:(Z,X)=>Math.abs(Z)*2<=Math.abs(X)?X>=0?groupD8.S:groupD8.N:Math.abs(X)*2<=Math.abs(Z)?Z>0?groupD8.E:groupD8.W:X>0?Z>0?groupD8.SE:groupD8.SW:Z>0?groupD8.NE:groupD8.NW,matrixAppendRotationInv:(Z,X,K=0,J=0)=>{const Q=D$1[groupD8.inv(X)];Q.tx=K,Q.ty=J,Z.append(Q)}};class TextureLayout extends eventemitter3{constructor(X={}){var K;super(),this.uvs={x0:0,y0:0,x1:0,y1:0,x2:0,y2:0,x3:0,y3:0},this.frame=X.frame||new Rectangle(0,0,1,1),this.orig=X.orig||this.frame,this.rotate=(K=X.rotate)!=null?K:0,this.trim=X.trim,this.defaultAnchor=X.defaultAnchor,this.defaultBorders=X.defaultBorders,this.updateUvs()}updateUvs(){const X=this.uvs,K=this.frame;let J=this.rotate;if(J){const Q=K.width/2,ee=K.height/2,te=K.x+Q,re=K.y+ee;J=groupD8.add(J,groupD8.NW),X.x0=te+Q*groupD8.uX(J),X.y0=re+ee*groupD8.uY(J),J=groupD8.add(J,2),X.x1=te+Q*groupD8.uX(J),X.y1=re+ee*groupD8.uY(J),J=groupD8.add(J,2),X.x2=te+Q*groupD8.uX(J),X.y2=re+ee*groupD8.uY(J),J=groupD8.add(J,2),X.x3=te+Q*groupD8.uX(J),X.y3=re+ee*groupD8.uY(J)}else X.x0=K.x,X.y0=K.y,X.x1=K.x+K.width,X.y1=K.y,X.x2=K.x+K.width,X.y2=K.y+K.height,X.x3=K.x,X.y3=K.y+K.height}update(){this.updateUvs(),this.emit("update",this)}destroy(){this.emit("destroy",this),this.removeAllListeners(),this.frame=null,this.orig=null,this.trim=null,this.defaultAnchor=null,this.uvs=null}}const p$C=new Matrix;class TextureMatrix{constructor(X,K){this.mapCoord=new Matrix,this.uClampFrame=new Float32Array(4),this.uClampOffset=new Float32Array(2),this._textureID=-1,this._updateID=0,this.clampOffset=0,typeof K=="undefined"?this.clampMargin=X.width<10?0:.5:this.clampMargin=K,this.isSimple=!1,this.texture=X}get texture(){return this._texture}set texture(X){var K;this.texture!==X&&((K=this._texture)==null||K.removeListener("update",this.update,this),this._texture=X,this._texture.addListener("update",this.update,this),this.update())}multiplyUvs(X,K){K===void 0&&(K=X);const J=this.mapCoord;for(let Q=0;Q<X.length;Q+=2){const ee=X[Q],te=X[Q+1];K[Q]=ee*J.a+te*J.c+J.tx,K[Q+1]=ee*J.b+te*J.d+J.ty}return K}update(){const X=this._texture;this._updateID++;const K=X.layout.uvs;this.mapCoord.set(K.x1-K.x0,K.y1-K.y0,K.x3-K.x0,K.y3-K.y0,K.x0,K.y0);const J=X.layout.orig,Q=X.layout.trim;Q&&(p$C.set(J.width/Q.width,0,0,J.height/Q.height,-Q.x/Q.width,-Q.y/Q.height),this.mapCoord.append(p$C));const ee=X.source,te=this.uClampFrame,re=this.clampMargin/ee._resolution,ie=this.clampOffset;return te[0]=(X.frameX+re+ie)/ee.width,te[1]=(X.frameY+re+ie)/ee.height,te[2]=(X.frameX+X.frameWidth-re+ie)/ee.width,te[3]=(X.frameY+X.frameHeight-re+ie)/ee.height,this.uClampOffset[0]=ie/ee.pixelWidth,this.uClampOffset[1]=ie/ee.pixelHeight,this.isSimple=X.frameWidth===ee.width&&X.frameHeight===ee.height&&X.layout.rotate===0,!0}}class Texture extends eventemitter3{constructor({source:X,layout:K,label:J,frame:Q}={}){var ee;if(super(),this.id=uid("texture"),this.styleSourceKey=0,this.label=J,this.source=(ee=X==null?void 0:X.source)!=null?ee:new TextureSource,K=K instanceof TextureLayout?K:new TextureLayout(K),Q){const{width:te,height:re}=this._source;K.frame.x=Q.x/te,K.frame.y=Q.y/re,K.frame.width=Q.width/te,K.frame.height=Q.height/re,K.updateUvs()}this.layout=K,this.destroyed=!1}static from(X,K=!1){return typeof X=="string"?Cache.get(X):X instanceof TextureSource?new Texture({source:X}):resourceToTexture(X,K)}set source(X){this._source&&this._source.off("resize",this.onUpdate,this),this._source=X,X.on("resize",this.onUpdate,this),this.emit("update",this)}get source(){return this._source}get layout(){return this._layout}set layout(X){var K;(K=this._layout)==null||K.off("update",this.onUpdate,this),this._layout=X,X.on("update",this.onUpdate,this),this.emit("update",this)}get textureMatrix(){return this._textureMatrix||(this._textureMatrix=new TextureMatrix(this)),this._textureMatrix}set frameWidth(X){this._layout.frame.width=X/this._source.width}get frameWidth(){return this._source.pixelWidth/this._source._resolution*this._layout.frame.width}set frameHeight(X){this._layout.frame.height=X/this._source.height}get frameHeight(){return this._source.pixelHeight/this._source._resolution*this._layout.frame.height}set frameX(X){if(X===0){this._layout.frame.x=0;return}this._layout.frame.x=this._source.width/X}get frameX(){return this._source.width*this._layout.frame.x}set frameY(X){if(X===0){this._layout.frame.y=0;return}this._layout.frame.y=this._source.height/X}get frameY(){return this._source.height*this._layout.frame.y}get width(){return this._source.width*this._layout.orig.width}get height(){return this._source.height*this._layout.orig.height}destroy(X=!1){this._layout&&(this._layout.destroy(),this._layout=null),this._source&&X&&(this._source.destroy(),this._source=null),this._textureMatrix=null,this.destroyed=!0,this.emit("destroy",this),this.removeAllListeners()}onUpdate(){this.emit("update",this)}get baseTexture(){return deprecation(v8_0_0,"Texture.baseTexture is now Texture.source"),this._source}}Texture.EMPTY=new Texture({}),Texture.EMPTY.label="EMPTY",Texture.EMPTY.destroy=NOOP;const cacheTextureArray={extension:u$v.CacheParser,test:Z=>Array.isArray(Z)&&Z.every(X=>X instanceof Texture),getCacheableAssets:(Z,X)=>{const K={};return Z.forEach(J=>{X.forEach((Q,ee)=>{K[J+(ee===0?"":ee+1)]=Q})}),K}};async function testImageFormat(Z){if("Image"in globalThis)return new Promise(X=>{const K=new Image;K.onload=()=>{X(!0)},K.onerror=()=>{X(!1)},K.src=Z});if("createImageBitmap"in globalThis&&"fetch"in globalThis){try{const X=await(await fetch(Z)).blob();await createImageBitmap(X)}catch(X){return!1}return!0}return!1}const detectAvif={extension:{type:u$v.DetectionParser,priority:1},test:async()=>testImageFormat("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),add:async Z=>[...Z,"avif"],remove:async Z=>Z.filter(X=>X!=="avif")},t$c=["png","jpg","jpeg"],detectDefaults={extension:{type:u$v.DetectionParser,priority:-1},test:()=>Promise.resolve(!0),add:async Z=>[...Z,...t$c],remove:async Z=>Z.filter(X=>!t$c.includes(X))},e$6="WorkerGlobalScope"in globalThis&&globalThis instanceof globalThis.WorkerGlobalScope;function testVideoFormat(Z){return e$6?!1:document.createElement("video").canPlayType(Z)!==""}const detectMp4={extension:{type:u$v.DetectionParser,priority:0},test:async()=>testVideoFormat("video/mp4"),add:async Z=>[...Z,"mp4","m4v"],remove:async Z=>Z.filter(X=>X!=="mp4"&&X!=="m4v")},detectOgv={extension:{type:u$v.DetectionParser,priority:0},test:async()=>testVideoFormat("video/ogg"),add:async Z=>[...Z,"ogv"],remove:async Z=>Z.filter(X=>X!=="ogv")},detectWebm={extension:{type:u$v.DetectionParser,priority:0},test:async()=>testVideoFormat("video/webm"),add:async Z=>[...Z,"webm"],remove:async Z=>Z.filter(X=>X!=="webm")},detectWebp={extension:{type:u$v.DetectionParser,priority:0},test:async()=>testImageFormat("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),add:async Z=>[...Z,"webp"],remove:async Z=>Z.filter(X=>X!=="webp")};var LoaderParserPriority=(Z=>(Z[Z.Low=0]="Low",Z[Z.Normal=1]="Normal",Z[Z.High=2]="High",Z))(LoaderParserPriority||{});const copySearchParams=(Z,X)=>{const K=X.split("?")[1];return K&&(Z+=`?${K}`),Z};class AbstractBitmapFont extends eventemitter3{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return deprecation(v8_0_0,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return deprecation(v8_0_0,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return deprecation(v8_0_0,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return deprecation(v8_0_0,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return deprecation(v8_0_0,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(){this.emit("destroy",this),this.removeAllListeners();for(const X in this.chars)this.chars[X].texture.destroy();this.chars=null}}class BitmapFont extends AbstractBitmapFont{constructor(X){var K;super();const{textures:J,data:Q}=X;Object.keys(Q.pages).forEach(ee=>{const te=Q.pages[parseInt(ee,10)],re=J[te.id];this.pages.push({texture:re})}),Object.keys(Q.chars).forEach(ee=>{var te;const re=Q.chars[ee],ie=J[re.page].source,ne=new Rectangle(re.x/ie.width,re.y/ie.height,re.width/ie.width,re.height/ie.height),se=new Texture({source:ie,layout:{frame:ne}});this.chars[ee]={id:ee.codePointAt(0),xOffset:re.xOffset,yOffset:re.yOffset,xAdvance:re.xAdvance,kerning:(te=re.kerning)!=null?te:{},texture:se}}),this.baseRenderedFontSize=Q.fontSize,this.baseMeasurementFontSize=Q.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:Q.fontSize},this.baseLineOffset=Q.baseLineOffset,this.lineHeight=Q.lineHeight,this.fontFamily=Q.fontFamily,this.distanceField=(K=Q.distanceField)!=null?K:{type:"none",range:0}}destroy(){super.destroy();for(let X=0;X<this.pages.length;X++){const{texture:K}=this.pages[X];K.destroy(!0)}this.pages=null}}const bitmapFontTextParser={test(Z){return typeof Z=="string"&&Z.startsWith("info face=")},parse(Z){var X,K,J;const Q=Z.match(/^[a-z]+\s+.+$/gm),ee={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const ce in Q){const de=Q[ce].match(/^[a-z]+/gm)[0],he=Q[ce].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),pe={};for(const fe in he){const ge=he[fe].split("="),me=ge[0],ye=ge[1].replace(/"/gm,""),_e=parseFloat(ye),Ce=isNaN(_e)?ye:_e;pe[me]=Ce}ee[de].push(pe)}const te={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},[re]=ee.info,[ie]=ee.common,[ne]=(X=ee.distanceField)!=null?X:[];ne&&(te.distanceField={range:parseInt(ne.distanceRange,10),type:ne.fieldType}),te.fontSize=parseInt(re.size,10),te.fontFamily=re.face,te.lineHeight=parseInt(ie.lineHeight,10);const se=ee.page;for(let ce=0;ce<se.length;ce++)te.pages.push({id:parseInt(se[ce].id,10)||0,file:se[ce].file});const oe={};te.baseLineOffset=te.lineHeight-parseInt(ie.base,10);const ae=ee.char;for(let ce=0;ce<ae.length;ce++){const de=ae[ce],he=parseInt(de.id,10);let pe=(J=(K=de.letter)!=null?K:de.char)!=null?J:String.fromCharCode(he);pe==="space"&&(pe=" "),oe[he]=pe,te.chars[pe]={id:he,page:parseInt(de.page,10)||0,x:parseInt(de.x,10),y:parseInt(de.y,10),width:parseInt(de.width,10),height:parseInt(de.height,10),xOffset:parseInt(de.xoffset,10),yOffset:parseInt(de.yoffset,10),xAdvance:parseInt(de.xadvance,10),kerning:{}}}const le=ee.kerning||[];for(let ce=0;ce<le.length;ce++){const de=parseInt(le[ce].first,10),he=parseInt(le[ce].second,10),pe=parseInt(le[ce].amount,10);te.chars[oe[he]].kerning[oe[de]]=pe}return te}},bitmapFontXMLParser={test(Z){const X=Z;return typeof X!="string"&&"getElementsByTagName"in X&&X.getElementsByTagName("page").length&&X.getElementsByTagName("info")[0].getAttribute("face")!==null},parse(Z){var X,K;const J={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},Q=Z.getElementsByTagName("info")[0],ee=Z.getElementsByTagName("common")[0],te=Z.getElementsByTagName("distanceField")[0];te&&(J.distanceField={type:te.getAttribute("fieldType"),range:parseInt(te.getAttribute("distanceRange"),10)});const re=Z.getElementsByTagName("page"),ie=Z.getElementsByTagName("char"),ne=Z.getElementsByTagName("kerning");J.fontSize=parseInt(Q.getAttribute("size"),10),J.fontFamily=Q.getAttribute("face"),J.lineHeight=parseInt(ee.getAttribute("lineHeight"),10);for(let oe=0;oe<re.length;oe++)J.pages.push({id:parseInt(re[oe].getAttribute("id"),10)||0,file:re[oe].getAttribute("file")});const se={};J.baseLineOffset=J.lineHeight-parseInt(ee.getAttribute("base"),10);for(let oe=0;oe<ie.length;oe++){const ae=ie[oe],le=parseInt(ae.getAttribute("id"),10);let ce=(K=(X=ae.getAttribute("letter"))!=null?X:ae.getAttribute("char"))!=null?K:String.fromCharCode(le);ce==="space"&&(ce=" "),se[le]=ce,J.chars[ce]={id:le,page:parseInt(ae.getAttribute("page"),10)||0,x:parseInt(ae.getAttribute("x"),10),y:parseInt(ae.getAttribute("y"),10),width:parseInt(ae.getAttribute("width"),10),height:parseInt(ae.getAttribute("height"),10),xOffset:parseInt(ae.getAttribute("xoffset"),10),yOffset:parseInt(ae.getAttribute("yoffset"),10),xAdvance:parseInt(ae.getAttribute("xadvance"),10),kerning:{}}}for(let oe=0;oe<ne.length;oe++){const ae=parseInt(ne[oe].getAttribute("first"),10),le=parseInt(ne[oe].getAttribute("second"),10),ce=parseInt(ne[oe].getAttribute("amount"),10);J.chars[se[le]].kerning[se[ae]]=ce}return J}},bitmapFontXMLStringParser={test(Z){return typeof Z=="string"&&Z.includes("<font>")?bitmapFontXMLParser.test(DOMAdapter.get().parseXML(Z)):!1},parse(Z){return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(Z))}},h$p=[".xml",".fnt"],bitmapFontCachePlugin={extension:u$v.CacheParser,test:Z=>Z instanceof BitmapFont,getCacheableAssets(Z,X){const K={};return Z.forEach(J=>{K[J]=X}),K[`${X.fontFamily}-bitmap`]=X,K}},xmlBitmapFontLoader={extension:{type:u$v.LoadParser,priority:LoaderParserPriority.Normal},test(Z){return h$p.includes(path.extname(Z).toLowerCase())},async testParse(Z){return bitmapFontTextParser.test(Z)||bitmapFontXMLStringParser.test(Z)},async parse(Z,X,K){const J=bitmapFontTextParser.test(Z)?bitmapFontTextParser.parse(Z):bitmapFontXMLStringParser.parse(Z),{src:Q}=X,{pages:ee}=J,te=[];for(let ne=0;ne<ee.length;++ne){const se=ee[ne].file;let oe=path.join(path.dirname(Q),se);oe=copySearchParams(oe,Q),te.push(oe)}const re=await K.load(te),ie=te.map(ne=>re[ne]);return new BitmapFont({data:J,textures:ie})},async load(Z,X){return await(await DOMAdapter.get().fetch(Z)).text()},unload(Z){Z.destroy()}};function checkDataUrl(Z,X){if(Array.isArray(X)){for(const K of X)if(Z.startsWith(`data:${K}`))return!0;return!1}return Z.startsWith(`data:${X}`)}function checkExtension(Z,X){const K=Z.split("?")[0],J=path.extname(K).toLowerCase();return Array.isArray(X)?X.includes(J):J===X}const a$v=".json",i$n="application/json",loadJson={extension:{type:u$v.LoadParser,priority:LoaderParserPriority.Low},name:"loadJson",test(Z){return checkDataUrl(Z,i$n)||checkExtension(Z,a$v)},async load(Z){return await(await DOMAdapter.get().fetch(Z)).json()}},n$w=".txt",i$m="text/plain",loadTxt={name:"loadTxt",extension:{type:u$v.LoadParser,priority:LoaderParserPriority.Low},test(Z){return checkDataUrl(Z,i$m)||checkExtension(Z,n$w)},async load(Z){return await(await DOMAdapter.get().fetch(Z)).text()}};var E$4=Object.defineProperty,L$5=Object.defineProperties,R$1=Object.getOwnPropertyDescriptors,p$B=Object.getOwnPropertySymbols,P$a=Object.prototype.hasOwnProperty,S$a=Object.prototype.propertyIsEnumerable,F$4=(Z,X,K)=>X in Z?E$4(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,h$o=(Z,X)=>{for(var K in X||(X={}))P$a.call(X,K)&&F$4(Z,K,X[K]);if(p$B)for(var K of p$B(X))S$a.call(X,K)&&F$4(Z,K,X[K]);return Z},y$h=(Z,X)=>L$5(Z,R$1(X));const k$3=["normal","bold","100","200","300","400","500","600","700","800","900"],C$4=[".ttf",".otf",".woff",".woff2"],D=["font/ttf","font/otf","font/woff","font/woff2"],I$6=/^(--|-?[A-Z_])[0-9A-Z_-]*$/i;function getFontFamilyName(Z){const X=path.extname(Z),K=path.basename(Z,X).replace(/(-|_)/g," ").toLowerCase().split(" ").map(ee=>ee.charAt(0).toUpperCase()+ee.slice(1));let J=K.length>0;for(const ee of K)if(!ee.match(I$6)){J=!1;break}let Q=K.join(" ");return J||(Q=`"${Q.replace(/[\\"]/g,"\\$&")}"`),Q}const N$2=/^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;function U$3(Z){return N$2.test(Z)?Z:encodeURI(Z)}const loadWebFont={extension:{type:u$v.LoadParser,priority:LoaderParserPriority.Low},name:"loadWebFont",test(Z){return checkDataUrl(Z,D)||checkExtension(Z,C$4)},async load(Z,X){var K,J,Q,ee,te,re;const ie=DOMAdapter.get().getFontFaceSet();if(ie){const ne=[],se=(J=(K=X.data)==null?void 0:K.family)!=null?J:getFontFamilyName(Z),oe=(te=(ee=(Q=X.data)==null?void 0:Q.weights)==null?void 0:ee.filter(le=>k$3.includes(le)))!=null?te:["normal"],ae=(re=X.data)!=null?re:{};for(let le=0;le<oe.length;le++){const ce=oe[le],de=new FontFace(se,`url(${U$3(Z)})`,y$h(h$o({},ae),{weight:ce}));await de.load(),ie.add(de),ne.push(de)}return Cache.set(se,{url:Z,fontFaces:ne}),ne.length===1?ne[0]:ne}return null},unload(Z){(Array.isArray(Z)?Z:[Z]).forEach(X=>{Cache.remove(X.family),DOMAdapter.get().getFontFaceSet().delete(X)})}};var parseSvgPath=parse$1,length={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},segment=/([astvzqmhlc])([^astvzqmhlc]*)/ig;function parse$1(Z){var X=[];return Z.replace(segment,function(K,J,Q){var ee=J.toLowerCase();for(Q=parseValues(Q),ee=="m"&&Q.length>2&&(X.push([J].concat(Q.splice(0,2))),ee="l",J=J=="m"?"l":"L");;){if(Q.length==length[ee])return Q.unshift(J),X.push(Q);if(Q.length<length[ee])throw new Error("malformed path data");X.push([J].concat(Q.splice(0,length[ee])))}}),X}var number=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;function parseValues(Z){var X=Z.match(number);return X?X.map(Number):[]}function SVGToGraphicsPath(Z,X){const K=parseSvgPath(Z),J=[];let Q=null,ee=0,te=0;for(let re=0;re<K.length;re++){const ie=K[re],ne=ie[0],se=ie;switch(ne){case"M":ee=se[1],te=se[2],X.moveTo(ee,te);break;case"m":ee+=se[1],te+=se[2],X.moveTo(ee,te);break;case"H":ee=se[1],X.lineTo(ee,te);break;case"h":ee+=se[1],X.lineTo(ee,te);break;case"V":te=se[1],X.lineTo(ee,te);break;case"v":te+=se[1],X.lineTo(ee,te);break;case"L":ee=se[1],te=se[2],X.lineTo(ee,te);break;case"l":ee+=se[1],te+=se[2],X.lineTo(ee,te);break;case"C":ee=se[5],te=se[6],X.bezierCurveTo(se[1],se[2],se[3],se[4],ee,te);break;case"c":X.bezierCurveTo(ee+se[1],te+se[2],ee+se[3],te+se[4],ee+se[5],te+se[6]),ee+=se[5],te+=se[6];break;case"S":ee=se[3],te=se[4],X.bezierCurveToShort(se[1],se[2],ee,te);break;case"s":X.bezierCurveToShort(ee+se[1],te+se[2],ee+se[3],te+se[4]),ee+=se[3],te+=se[4];break;case"Q":ee=se[3],te=se[4],X.quadraticCurveTo(se[1],se[2],ee,te);break;case"q":X.quadraticCurveTo(ee+se[1],te+se[2],ee+se[3],te+se[4]),ee+=se[3],te+=se[4];break;case"T":ee=se[1],te=se[2],X.quadraticCurveToShort(ee,te);break;case"t":ee+=se[1],te+=se[2],X.quadraticCurveToShort(ee,te);break;case"A":ee=se[6],te=se[7],X.arcToSvg(se[1],se[2],se[3],se[4],se[5],ee,te);break;case"a":ee+=se[6],te+=se[7],X.arcToSvg(se[1],se[2],se[3],se[4],se[5],ee,te);break;case"Z":case"z":X.closePath(),J.length>0&&(Q=J.pop(),Q?(ee=Q.startX,te=Q.startY):(ee=0,te=0)),Q=null;break;default:}ne!=="Z"&&ne!=="z"&&Q===null&&(Q={startX:ee,startY:te},J.push(Q))}return X}class Circle{constructor(X=0,K=0,J=0){this.type="circle",this.x=X,this.y=K,this.radius=J}clone(){return new Circle(this.x,this.y,this.radius)}contains(X,K){if(this.radius<=0)return!1;const J=this.radius*this.radius;let Q=this.x-X,ee=this.y-K;return Q*=Q,ee*=ee,Q+ee<=J}getBounds(X){return X=X||new Rectangle,X.x=this.x-this.radius,X.y=this.y-this.radius,X.width=this.radius*2,X.height=this.radius*2,X}copyFrom(X){return this.x=X.x,this.y=X.y,this.radius=X.radius,this}copyTo(X){return X.copyFrom(this),X}}class Ellipse{constructor(X=0,K=0,J=0,Q=0){this.type="ellipse",this.x=X,this.y=K,this.halfWidth=J,this.halfHeight=Q}clone(){return new Ellipse(this.x,this.y,this.halfWidth,this.halfHeight)}contains(X,K){if(this.halfWidth<=0||this.halfHeight<=0)return!1;let J=(X-this.x)/this.halfWidth,Q=(K-this.y)/this.halfHeight;return J*=J,Q*=Q,J+Q<=1}getBounds(){return new Rectangle(this.x-this.halfWidth,this.y-this.halfHeight,this.halfWidth*2,this.halfHeight*2)}copyFrom(X){return this.x=X.x,this.y=X.y,this.halfWidth=X.halfWidth,this.halfHeight=X.halfHeight,this}copyTo(X){return X.copyFrom(this),X}}class Polygon{constructor(...X){this.type="polygon";let K=Array.isArray(X[0])?X[0]:X;if(typeof K[0]!="number"){const J=[];for(let Q=0,ee=K.length;Q<ee;Q++)J.push(K[Q].x,K[Q].y);K=J}this.points=K,this.closePath=!0}clone(){const X=this.points.slice(),K=new Polygon(X);return K.closePath=this.closePath,K}contains(X,K){let J=!1;const Q=this.points.length/2;for(let ee=0,te=Q-1;ee<Q;te=ee++){const re=this.points[ee*2],ie=this.points[ee*2+1],ne=this.points[te*2],se=this.points[te*2+1];ie>K!=se>K&&X<(ne-re)*((K-ie)/(se-ie))+re&&(J=!J)}return J}getBounds(X){X=X||new Rectangle;const K=this.points;let J=1/0,Q=-1/0,ee=1/0,te=-1/0;for(let re=0,ie=K.length;re<ie;re+=2){const ne=K[re],se=K[re+1];J=ne<J?ne:J,Q=ne>Q?ne:Q,ee=se<ee?se:ee,te=se>te?se:te}return X.x=J,X.width=Q-J,X.y=ee,X.height=te-ee,X}copyFrom(X){return this.points=X.points.slice(),this.closePath=X.closePath,this}copyTo(X){return X.copyFrom(this),X}get lastX(){return this.points[this.points.length-2]}get lastY(){return this.points[this.points.length-1]}get x(){return this.points[this.points.length-2]}get y(){return this.points[this.points.length-1]}}class RoundedRectangle{constructor(X=0,K=0,J=0,Q=0,ee=20){this.type="roundedRectangle",this.x=X,this.y=K,this.width=J,this.height=Q,this.radius=ee}getBounds(X){return X=X||new Rectangle,X.x=this.x,X.y=this.y,X.width=this.width,X.height=this.height,X}clone(){return new RoundedRectangle(this.x,this.y,this.width,this.height,this.radius)}copyFrom(X){return this.x=X.x,this.y=X.y,this.width=X.width,this.height=X.height,this}copyTo(X){return X.copyFrom(this),X}contains(X,K){if(this.width<=0||this.height<=0)return!1;if(X>=this.x&&X<=this.x+this.width&&K>=this.y&&K<=this.y+this.height){const J=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(K>=this.y+J&&K<=this.y+this.height-J||X>=this.x+J&&X<=this.x+this.width-J)return!0;let Q=X-(this.x+J),ee=K-(this.y+J);const te=J*J;if(Q*Q+ee*ee<=te||(Q=X-(this.x+this.width-J),Q*Q+ee*ee<=te)||(ee=K-(this.y+this.height-J),Q*Q+ee*ee<=te)||(Q=X-(this.x+J),Q*Q+ee*ee<=te))return!0}return!1}}const k$2=8,_$7=11920929e-14,H$6=1,d$k=.01,S$9=0,E$3=0;function buildAdaptiveBezier(Z,X,K,J,Q,ee,te,re,ie){let ne=H$6/1;return ne*=ne,j$1(X,K,J,Q,ee,te,re,ie,Z,ne),Z}function j$1(Z,X,K,J,Q,ee,te,re,ie,ne){C$3(Z,X,K,J,Q,ee,te,re,ie,ne,0),ie.push(te,re)}function C$3(Z,X,K,J,Q,ee,te,re,ie,ne,se){if(se>8)return;const oe=Math.PI,ae=(Z+K)/2,le=(X+J)/2,ce=(K+Q)/2,de=(J+ee)/2,he=(Q+te)/2,pe=(ee+re)/2,fe=(ae+ce)/2,ge=(le+de)/2,me=(ce+he)/2,ye=(de+pe)/2,_e=(fe+me)/2,Ce=(ge+ye)/2;if(se>0){let xe=te-Z,be=re-X;const ve=Math.abs((K-te)*be-(J-re)*xe),Se=Math.abs((Q-te)*be-(ee-re)*xe);let Pe,Te;if(ve>_$7&&Se>_$7){if((ve+Se)*(ve+Se)<=ne*(xe*xe+be*be)){if(S$9<d$k){ie.push(_e,Ce);return}const Ae=Math.atan2(ee-J,Q-K);if(Pe=Math.abs(Ae-Math.atan2(J-X,K-Z)),Te=Math.abs(Math.atan2(re-ee,te-Q)-Ae),Pe>=oe&&(Pe=2*oe-Pe),Te>=oe&&(Te=2*oe-Te),Pe+Te<S$9){ie.push(_e,Ce);return}if(E$3!==0){if(Pe>E$3){ie.push(K,J);return}if(Te>E$3){ie.push(Q,ee);return}}}}else if(ve>_$7){if(ve*ve<=ne*(xe*xe+be*be)){if(S$9<d$k){ie.push(_e,Ce);return}if(Pe=Math.abs(Math.atan2(ee-J,Q-K)-Math.atan2(J-X,K-Z)),Pe>=oe&&(Pe=2*oe-Pe),Pe<S$9){ie.push(K,J),ie.push(Q,ee);return}if(E$3!==0&&Pe>E$3){ie.push(K,J);return}}}else if(Se>_$7){if(Se*Se<=ne*(xe*xe+be*be)){if(S$9<d$k){ie.push(_e,Ce);return}if(Pe=Math.abs(Math.atan2(re-ee,te-Q)-Math.atan2(ee-J,Q-K)),Pe>=oe&&(Pe=2*oe-Pe),Pe<S$9){ie.push(K,J),ie.push(Q,ee);return}if(E$3!==0&&Pe>E$3){ie.push(Q,ee);return}}}else if(xe=_e-(Z+te)/2,be=Ce-(X+re)/2,xe*xe+be*be<=ne){ie.push(_e,Ce);return}}C$3(Z,X,ae,le,fe,ge,_e,Ce,ie,ne,se+1),C$3(_e,Ce,me,ye,he,pe,te,re,ie,ne,se+1)}const P$9=8,S$8=11920929e-14,T$a=1,_$6=.01,N$1=0;function buildAdaptiveQuadratic(Z,X,K,J,Q,ee,te){let re=T$a/1;return re*=re,O$4(X,K,J,Q,ee,te,Z,re),Z}function O$4(Z,X,K,J,Q,ee,te,re){l$n(te,Z,X,K,J,Q,ee,re,0),te.push(Q,ee)}function l$n(Z,X,K,J,Q,ee,te,re,ie){if(ie>8)return;const ne=Math.PI,se=(X+J)/2,oe=(K+Q)/2,ae=(J+ee)/2,le=(Q+te)/2,ce=(se+ae)/2,de=(oe+le)/2;let he=ee-X,pe=te-K;const fe=Math.abs((J-ee)*pe-(Q-te)*he);if(fe>S$8){if(fe*fe<=re*(he*he+pe*pe)){if(N$1<_$6){Z.push(ce,de);return}let ge=Math.abs(Math.atan2(te-Q,ee-J)-Math.atan2(Q-K,J-X));if(ge>=ne&&(ge=2*ne-ge),ge<N$1){Z.push(ce,de);return}}}else if(he=ce-(X+ee)/2,pe=de-(K+te)/2,he*he+pe*pe<=re){Z.push(ce,de);return}l$n(Z,X,K,se,oe,ce,de,re,ie+1),l$n(Z,ce,de,ae,le,ee,te,re,ie+1)}function buildArc(Z,X,K,J,Q,ee,te,re){let ie=Math.abs(Q-ee);(!te&&Q>ee||te&&ee>Q)&&(ie=2*Math.PI-ie),re=re||Math.max(6,Math.floor(6*Math.pow(J,1/3)*(ie/Math.PI))),re=Math.max(re,3);let ne=ie/re,se=Q;ne*=te?-1:1;for(let oe=0;oe<re+1;oe++){const ae=Math.cos(se),le=Math.sin(se),ce=X+ae*J,de=K+le*J;Z.push(ce,de),se+=ne}}function buildArcTo(Z,X,K,J,Q,ee){const te=Z[Z.length-2],re=Z[Z.length-1]-K,ie=te-X,ne=Q-K,se=J-X,oe=Math.abs(re*se-ie*ne);if(oe<1e-8||ee===0){(Z[Z.length-2]!==X||Z[Z.length-1]!==K)&&Z.push(X,K);return}const ae=re*re+ie*ie,le=ne*ne+se*se,ce=re*ne+ie*se,de=ee*Math.sqrt(ae)/oe,he=ee*Math.sqrt(le)/oe,pe=de*ce/ae,fe=he*ce/le,ge=de*se+he*ie,me=de*ne+he*re,ye=ie*(he+pe),_e=re*(he+pe),Ce=se*(de+fe),xe=ne*(de+fe),be=Math.atan2(_e-me,ye-ge),ve=Math.atan2(xe-me,Ce-ge);buildArc(Z,ge+X,me+K,ee,be,ve,ie*ne>se*re)}const A$5=Math.PI*2,z$2={centerX:0,centerY:0,ang1:0,ang2:0},B$6=({x:Z,y:X},K,J,Q,ee,te,re,ie)=>{Z*=K,X*=J;const ne=Q*Z-ee*X,se=ee*Z+Q*X;return ie.x=ne+te,ie.y=se+re,ie};function G$2(Z,X){const K=X===-1.5707963267948966?-.551915024494:1.3333333333333333*Math.tan(X/4),J=X===1.5707963267948966?.551915024494:K,Q=Math.cos(Z),ee=Math.sin(Z),te=Math.cos(Z+X),re=Math.sin(Z+X);return[{x:Q-ee*J,y:ee+Q*J},{x:te+re*J,y:re-te*J},{x:te,y:re}]}const j=(Z,X,K,J)=>{const Q=Z*J-X*K<0?-1:1;let ee=Z*K+X*J;return ee>1&&(ee=1),ee<-1&&(ee=-1),Q*Math.acos(ee)},H$5=(Z,X,K,J,Q,ee,te,re,ie,ne,se,oe,ae)=>{const le=Math.pow(Q,2),ce=Math.pow(ee,2),de=Math.pow(se,2),he=Math.pow(oe,2);let pe=le*ce-le*he-ce*de;pe<0&&(pe=0),pe/=le*he+ce*de,pe=Math.sqrt(pe)*(te===re?-1:1);const fe=pe*Q/ee*oe,ge=pe*-ee/Q*se,me=ne*fe-ie*ge+(Z+K)/2,ye=ie*fe+ne*ge+(X+J)/2,_e=(se-fe)/Q,Ce=(oe-ge)/ee,xe=(-se-fe)/Q,be=(-oe-ge)/ee,ve=j(1,0,_e,Ce);let Se=j(_e,Ce,xe,be);re===0&&Se>0&&(Se-=A$5),re===1&&Se<0&&(Se+=A$5),ae.centerX=me,ae.centerY=ye,ae.ang1=ve,ae.ang2=Se};function buildArcToSvg(Z,X,K,J,Q,ee,te,re=0,ie=0,ne=0){if(ee===0||te===0)return;const se=Math.sin(re*A$5/360),oe=Math.cos(re*A$5/360),ae=oe*(X-J)/2+se*(K-Q)/2,le=-se*(X-J)/2+oe*(K-Q)/2;if(ae===0&&le===0)return;ee=Math.abs(ee),te=Math.abs(te);const ce=Math.pow(ae,2)/Math.pow(ee,2)+Math.pow(le,2)/Math.pow(te,2);ce>1&&(ee*=Math.sqrt(ce),te*=Math.sqrt(ce)),H$5(X,K,J,Q,ee,te,ie,ne,se,oe,ae,le,z$2);let{ang1:de,ang2:he}=z$2;const{centerX:pe,centerY:fe}=z$2;let ge=Math.abs(he)/(A$5/4);Math.abs(1-ge)<1e-7&&(ge=1);const me=Math.max(Math.ceil(ge),1);he/=me;let ye=Z[Z.length-2],_e=Z[Z.length-1];const Ce={x:0,y:0};for(let xe=0;xe<me;xe++){const be=G$2(de,he),{x:ve,y:Se}=B$6(be[0],ee,te,oe,se,pe,fe,Ce),{x:Pe,y:Te}=B$6(be[1],ee,te,oe,se,pe,fe,Ce),{x:Ae,y:Ie}=B$6(be[2],ee,te,oe,se,pe,fe,Ce);buildAdaptiveBezier(Z,ye,_e,ve,Se,Pe,Te,Ae,Ie),ye=Ae,_e=Ie,de+=he}}function roundedShapeArc(Z,X,K){var J;const Q=(re,ie)=>{const ne=ie.x-re.x,se=ie.y-re.y,oe=Math.sqrt(ne*ne+se*se),ae=ne/oe,le=se/oe;return{len:oe,nx:ae,ny:le}},ee=(re,ie)=>{re===0?Z.moveTo(ie.x,ie.y):Z.lineTo(ie.x,ie.y)};let te=X[X.length-1];for(let re=0;re<X.length;re++){const ie=X[re%X.length],ne=(J=ie.radius)!=null?J:K;if(ne<=0){ee(re,ie),te=ie;continue}const se=X[(re+1)%X.length],oe=Q(ie,te),ae=Q(ie,se);if(oe.len<1e-4||ae.len<1e-4){ee(re,ie),te=ie;continue}let le=Math.asin(oe.nx*ae.ny-oe.ny*ae.nx),ce=1,de=!1;oe.nx*ae.nx-oe.ny*-ae.ny<0?le<0?le=Math.PI+le:(le=Math.PI-le,ce=-1,de=!0):le>0&&(ce=-1,de=!0);const he=le/2;let pe,fe=Math.abs(Math.cos(he)*ne/Math.sin(he));fe>Math.min(oe.len/2,ae.len/2)?(fe=Math.min(oe.len/2,ae.len/2),pe=Math.abs(fe*Math.sin(he)/Math.cos(he))):pe=ne;const ge=ie.x+ae.nx*fe+-ae.ny*pe*ce,me=ie.y+ae.ny*fe+ae.nx*pe*ce,ye=Math.atan2(oe.ny,oe.nx)+Math.PI/2*ce,_e=Math.atan2(ae.ny,ae.nx)-Math.PI/2*ce;re===0&&Z.moveTo(ge+Math.cos(ye)*pe,me+Math.sin(ye)*pe),Z.arc(ge,me,pe,ye,_e,de),te=ie}}function roundedShapeQuadraticCurve(Z,X,K){var J;const Q=(re,ie)=>Math.sqrt((re.x-ie.x)**2+(re.y-ie.y)**2),ee=(re,ie,ne)=>({x:re.x+(ie.x-re.x)*ne,y:re.y+(ie.y-re.y)*ne}),te=X.length;for(let re=0;re<te;re++){const ie=X[(re+1)%te],ne=(J=ie.radius)!=null?J:K;if(ne<=0){re===0?Z.moveTo(ie.x,ie.y):Z.lineTo(ie.x,ie.y);continue}const se=X[re],oe=X[(re+2)%te],ae=Q(se,ie);let le;if(ae<1e-4)le=ie;else{const he=Math.min(ae/2,ne);le=ee(ie,se,he/ae)}const ce=Q(oe,ie);let de;if(ce<1e-4)de=ie;else{const he=Math.min(ce/2,ne);de=ee(ie,oe,he/ce)}re===0?Z.moveTo(le.x,le.y):Z.lineTo(le.x,le.y),Z.quadraticCurveTo(ie.x,ie.y,de.x,de.y)}}const B$5=new Rectangle;class ShapePath{constructor(X){this.shapePrimitives=[],this._currentPoly=null,this._bounds=new Bounds,this._graphicsPath2D=X}moveTo(X,K){return this.startPoly(X,K),this}lineTo(X,K){this._ensurePoly();const J=this._currentPoly.points,Q=J[J.length-2],ee=J[J.length-1];return(Q!==X||ee!==K)&&J.push(X,K),this}arc(X,K,J,Q,ee,te){this._ensurePoly(!1);const re=this._currentPoly.points;return buildArc(re,X,K,J,Q,ee,te),this}arcTo(X,K,J,Q,ee){this._ensurePoly();const te=this._currentPoly.points;return buildArcTo(te,X,K,J,Q,ee),this}arcToSvg(X,K,J,Q,ee,te,re){const ie=this._currentPoly.points;return buildArcToSvg(ie,this._currentPoly.lastX,this._currentPoly.lastY,te,re,X,K,J,Q,ee),this}bezierCurveTo(X,K,J,Q,ee,te){this._ensurePoly();const re=this._currentPoly;return buildAdaptiveBezier(this._currentPoly.points,re.lastX,re.lastY,X,K,J,Q,ee,te),this}quadraticCurveTo(X,K,J,Q){this._ensurePoly();const ee=this._currentPoly;return buildAdaptiveQuadratic(this._currentPoly.points,ee.lastX,ee.lastY,X,K,J,Q),this}closePath(){return this.endPoly(!0),this}addPath(X,K){this.endPoly(),K&&!K.isIdentity()&&(X=X.clone(!0),X.transform(K));for(let J=0;J<X.instructions.length;J++){const Q=X.instructions[J];this[Q.action](...Q.data)}return this}finish(X=!1){this.endPoly(X)}rect(X,K,J,Q,ee){return this.drawShape(new Rectangle(X,K,J,Q),ee),this}circle(X,K,J,Q){return this.drawShape(new Circle(X,K,J),Q),this}poly(X,K,J){const Q=new Polygon(X);return Q.closePath=K,this.drawShape(Q,J),this}regularPoly(X,K,J,Q,ee=0,te){Q=Math.max(Q|0,3);const re=-1*Math.PI/2+ee,ie=Math.PI*2/Q,ne=[];for(let se=0;se<Q;se++){const oe=se*ie+re;ne.push(X+J*Math.cos(oe),K+J*Math.sin(oe))}return this.poly(ne,!1,te),this}roundPoly(X,K,J,Q,ee,te=0){if(Q=Math.max(Q|0,3),ee<=0)return this.regularPoly(X,K,J,Q,te);const re=J*Math.sin(Math.PI/Q)-.001;ee=Math.min(ee,re);const ie=-1*Math.PI/2+te,ne=Math.PI*2/Q,se=(Q-2)*Math.PI/Q/2;for(let oe=0;oe<Q;oe++){const ae=oe*ne+ie,le=X+J*Math.cos(ae),ce=K+J*Math.sin(ae),de=ae+Math.PI+se,he=ae-Math.PI-se,pe=le+ee*Math.cos(de),fe=ce+ee*Math.sin(de),ge=le+ee*Math.cos(he),me=ce+ee*Math.sin(he);oe===0?this.moveTo(pe,fe):this.lineTo(pe,fe),this.quadraticCurveTo(le,ce,ge,me)}return this.closePath()}roundShape(X,K,J=!1){return X.length<3?this:(J?roundedShapeQuadraticCurve(this,X,K):roundedShapeArc(this,X,K),this.closePath())}filletRect(X,K,J,Q,ee){if(ee===0)return this.rect(X,K,J,Q);const te=Math.min(J,Q)/2,re=Math.min(te,Math.max(-te,ee)),ie=X+J,ne=K+Q,se=re<0?-re:0,oe=Math.abs(re);return this.moveTo(X,K+oe).arcTo(X+se,K+se,X+oe,K,oe).lineTo(ie-oe,K).arcTo(ie-se,K+se,ie,K+oe,oe).lineTo(ie,ne-oe).arcTo(ie-se,ne-se,X+J-oe,ne,oe).lineTo(X+oe,ne).arcTo(X+se,ne-se,X,ne-oe,oe).closePath()}chamferRect(X,K,J,Q,ee,te){if(ee<=0)return this.rect(X,K,J,Q);const re=Math.min(ee,Math.min(J,Q)/2),ie=X+J,ne=K+Q,se=[X+re,K,ie-re,K,ie,K+re,ie,ne-re,ie-re,ne,X+re,ne,X,ne-re,X,K+re];for(let oe=se.length-1;oe>=2;oe-=2)se[oe]===se[oe-2]&&se[oe-1]===se[oe-3]&&se.splice(oe-1,2);return this.poly(se,void 0,te)}ellipse(X,K,J,Q,ee){return this.drawShape(new Ellipse(X,K,J,Q),ee),this}roundRect(X,K,J,Q,ee,te){return this.drawShape(new RoundedRectangle(X,K,J,Q,ee),te),this}drawShape(X,K){return this.endPoly(),this.shapePrimitives.push({shape:X,transform:K}),this}startPoly(X,K){let J=this._currentPoly;return J&&this.endPoly(),J=new Polygon,J.points.push(X,K),this._currentPoly=J,this}endPoly(X=!1){const K=this._currentPoly;return K&&K.points.length>2&&(K.closePath=X,this.shapePrimitives.push({shape:K})),this._currentPoly=null,this}_ensurePoly(X=!0){if(!this._currentPoly&&(this._currentPoly=new Polygon,X)){const K=this.shapePrimitives[this.shapePrimitives.length-1];if(K){let J=K.shape.x,Q=K.shape.y;if(!K.transform.isIdentity()){const ee=K.transform,te=J;J=ee.a*J+ee.c*Q+ee.tx,Q=ee.b*te+ee.d*Q+ee.ty}this._currentPoly.points.push(J,Q)}else this._currentPoly.points.push(0,0)}}buildPath(){const X=this._graphicsPath2D;this.shapePrimitives.length=0,this._currentPoly=null;for(let K=0;K<X.instructions.length;K++){const J=X.instructions[K];this[J.action](...J.data)}this.finish()}get bounds(){const X=this._bounds;X.clear();const K=this.shapePrimitives;for(let J=0;J<K.length;J++){const Q=K[J],ee=Q.shape.getBounds(B$5);Q.transform?(X.pushMatrix(Q.transform),X.addRect(ee),X.popMatrix()):X.addRect(ee)}return X}}class GraphicsPath{constructor(X){this.instructions=[],this.uid=uid("graphicsPath"),this._dirty=!0;var K;typeof X=="string"?SVGToGraphicsPath(X,this):this.instructions=(K=X==null?void 0:X.slice())!=null?K:[]}get shapePath(){return this._shapePath||(this._shapePath=new ShapePath(this)),this._dirty&&(this._dirty=!1,this._shapePath.buildPath()),this._shapePath}addPath(X,K){return X=X.clone(),this.instructions.push({action:"addPath",data:[X,K]}),this._dirty=!0,this}arc(...X){return this.instructions.push({action:"arc",data:X}),this._dirty=!0,this}arcTo(...X){return this.instructions.push({action:"arcTo",data:X}),this._dirty=!0,this}arcToSvg(...X){return this.instructions.push({action:"arcToSvg",data:X}),this._dirty=!0,this}bezierCurveTo(...X){return this.instructions.push({action:"bezierCurveTo",data:X}),this._dirty=!0,this}bezierCurveToShort(X,K,J,Q){const ee=this.instructions[this.instructions.length-1],te=this.getLastPoint(Point.shared);let re=0,ie=0;if(!ee||ee.action!=="bezierCurveTo")re=te.x,ie=te.y;else{re=ee.data[2],ie=ee.data[3];const ne=te.x,se=te.y;re=ne+(ne-re),ie=se+(se-ie)}return this.instructions.push({action:"bezierCurveTo",data:[re,ie,X,K,J,Q]}),this._dirty=!0,this}closePath(){return this.instructions.push({action:"closePath",data:[]}),this._dirty=!0,this}ellipse(...X){return this.instructions.push({action:"ellipse",data:X}),this._dirty=!0,this}lineTo(...X){return this.instructions.push({action:"lineTo",data:X}),this._dirty=!0,this}moveTo(...X){return this.instructions.push({action:"moveTo",data:X}),this}quadraticCurveTo(...X){return this.instructions.push({action:"quadraticCurveTo",data:X}),this._dirty=!0,this}quadraticCurveToShort(X,K){const J=this.instructions[this.instructions.length-1],Q=this.getLastPoint(Point.shared);let ee=0,te=0;if(!J||J.action!=="quadraticCurveTo")ee=Q.x,te=Q.y;else{ee=J.data[0],te=J.data[1];const re=Q.x,ie=Q.y;ee=re+(re-ee),te=ie+(ie-te)}return this.instructions.push({action:"quadraticCurveTo",data:[ee,te,X,K]}),this._dirty=!0,this}rect(X,K,J,Q,ee){return this.instructions.push({action:"rect",data:[X,K,J,Q,ee]}),this._dirty=!0,this}circle(X,K,J,Q){return this.instructions.push({action:"circle",data:[X,K,J,Q]}),this._dirty=!0,this}roundRect(...X){return this.instructions.push({action:"roundRect",data:X}),this._dirty=!0,this}poly(...X){return this.instructions.push({action:"poly",data:X}),this._dirty=!0,this}regularPoly(...X){return this.instructions.push({action:"regularPoly",data:X}),this._dirty=!0,this}roundPoly(...X){return this.instructions.push({action:"roundPoly",data:X}),this._dirty=!0,this}roundShape(...X){return this.instructions.push({action:"roundShape",data:X}),this._dirty=!0,this}filletRect(...X){return this.instructions.push({action:"filletRect",data:X}),this._dirty=!0,this}chamferRect(...X){return this.instructions.push({action:"chamferRect",data:X}),this._dirty=!0,this}star(X,K,J,Q,ee,te,re){ee=ee||Q/2;const ie=-1*Math.PI/2+te,ne=J*2,se=Math.PI*2/ne,oe=[];for(let ae=0;ae<ne;ae++){const le=ae%2?ee:Q,ce=ae*se+ie;oe.push(X+le*Math.cos(ce),K+le*Math.sin(ce))}return this.poly(oe,!0,re),this}clone(X=!1){const K=new GraphicsPath;if(!X)K.instructions=this.instructions.slice();else for(let J=0;J<this.instructions.length;J++){const Q=this.instructions[J];K.instructions.push({action:Q.action,data:Q.data.slice()})}return K}clear(){return this.instructions.length=0,this._dirty=!0,this}transform(X){if(X.isIdentity())return this;const K=X.a,J=X.b,Q=X.c,ee=X.d,te=X.tx,re=X.ty;let ie=0,ne=0,se=0,oe=0,ae=0,le=0,ce=0,de=0;for(let he=0;he<this.instructions.length;he++){const pe=this.instructions[he],fe=pe.data;switch(pe.action){case"moveTo":case"lineTo":ie=fe[0],ne=fe[1],fe[0]=K*ie+Q*ne+te,fe[1]=J*ie+ee*ne+re;break;case"bezierCurveTo":se=fe[0],oe=fe[1],ae=fe[2],le=fe[3],ie=fe[4],ne=fe[5],fe[0]=K*se+Q*oe+te,fe[1]=J*se+ee*oe+re,fe[2]=K*ae+Q*le+te,fe[3]=J*ae+ee*le+re,fe[4]=K*ie+Q*ne+te,fe[5]=J*ie+ee*ne+re;break;case"quadraticCurveTo":se=fe[0],oe=fe[1],ie=fe[2],ne=fe[3],fe[0]=K*se+Q*oe+te,fe[1]=J*se+ee*oe+re,fe[2]=K*ie+Q*ne+te,fe[3]=J*ie+ee*ne+re;break;case"arcToSvg":ie=fe[5],ne=fe[6],ce=fe[0],de=fe[1],fe[0]=K*ce+Q*de,fe[1]=J*ce+ee*de,fe[5]=K*ie+Q*ne+te,fe[6]=J*ie+ee*ne+re;break;case"rect":fe[4]=x$c(fe[4],X);break;case"ellipse":fe[8]=x$c(fe[8],X);break;case"roundRect":fe[5]=x$c(fe[5],X);break;case"addPath":fe[0].transform(X);break;default:break}}return this._dirty=!0,this}get bounds(){return this.shapePath.bounds}getLastPoint(X){let K=this.instructions.length-1,J=this.instructions[K];if(!J)return X.x=0,X.y=0,X;for(;J.action==="closePath";){if(K--,K<0)return X.x=0,X.y=0,X;J=this.instructions[K]}let Q,ee,te;switch(J.action){case"moveTo":case"lineTo":X.x=J.data[0],X.y=J.data[1];break;case"quadraticCurveTo":X.x=J.data[2],X.y=J.data[3];break;case"bezierCurveTo":X.x=J.data[4],X.y=J.data[5];break;case"arc":case"arcToSvg":X.x=J.data[5],X.y=J.data[6];break;case"addPath":J.data[0].getLastPoint(X);break;case"rect":if(te=J.data[4],Q=J.data[0],ee=J.data[1],te){const{a:re,b:ie,c:ne,d:se,tx:oe,ty:ae}=te;X.x=re*Q+ne*ee+oe,X.y=ie*Q+se*ee+ae}else X.x=Q,X.y=ee;break;case"poly":break;default:break}return X}}function x$c(Z,X){return Z?Z.prepend(X):X.clone()}var L$4=Object.defineProperty,P$8=Object.getOwnPropertySymbols,q=Object.prototype.hasOwnProperty,H$4=Object.prototype.propertyIsEnumerable,s$y=(Z,X,K)=>X in Z?L$4(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,b$l=(Z,X)=>{for(var K in X||(X={}))q.call(X,K)&&s$y(Z,K,X[K]);if(P$8)for(var K of P$8(X))H$4.call(X,K)&&s$y(Z,K,X[K]);return Z};function SVGParser(Z,X){if(typeof Z=="string"){const J=document.createElement("div");J.innerHTML=Z.trim(),Z=J.querySelector("svg")}const K={context:X,path:new GraphicsPath};return I$5(Z,K,null,null),X}function I$5(Z,X,K,J){const Q=Z.children,{fillStyle:ee,strokeStyle:te}=M$5(Z);ee&&K?K=b$l(b$l({},K),ee):ee&&(K=ee),te&&J?J=b$l(b$l({},J),te):te&&(J=te),X.context.fillStyle=K,X.context.strokeStyle=J;let re,ie,ne,se,oe,ae,le,ce,de,he,pe,fe,ge,me,ye,_e,Ce;switch(Z.nodeName.toLowerCase()){case"path":me=Z.getAttribute("d"),ye=new GraphicsPath(me),X.context.path(ye),K&&X.context.fill(),J&&X.context.stroke();break;case"circle":le=o$r(Z,"cx",0),ce=o$r(Z,"cy",0),de=o$r(Z,"r",0),X.context.ellipse(le,ce,de,de),K&&X.context.fill(),J&&X.context.stroke();break;case"rect":re=o$r(Z,"x",0),ie=o$r(Z,"y",0),_e=o$r(Z,"width",0),Ce=o$r(Z,"height",0),he=o$r(Z,"rx",0),pe=o$r(Z,"ry",0),he||pe?X.context.roundRect(re,ie,_e,Ce,he||pe):X.context.rect(re,ie,_e,Ce),K&&X.context.fill(),J&&X.context.stroke();break;case"ellipse":le=o$r(Z,"cx",0),ce=o$r(Z,"cy",0),he=o$r(Z,"rx",0),pe=o$r(Z,"ry",0),X.context.beginPath(),X.context.ellipse(le,ce,he,pe),K&&X.context.fill(),J&&X.context.stroke();break;case"line":ne=o$r(Z,"x1",0),se=o$r(Z,"y1",0),oe=o$r(Z,"x2",0),ae=o$r(Z,"y2",0),X.context.beginPath(),X.context.moveTo(ne,se),X.context.lineTo(oe,ae),J&&X.context.stroke();break;case"polygon":ge=Z.getAttribute("points"),fe=ge.match(/\d+/g).map(xe=>parseInt(xe,10)),X.context.poly(fe,!0),K&&X.context.fill(),J&&X.context.stroke();break;case"polyline":ge=Z.getAttribute("points"),fe=ge.match(/\d+/g).map(xe=>parseInt(xe,10)),X.context.poly(fe,!1),J&&X.context.stroke();break;case"g":case"svg":break;default:{console.info(`[SVG parser] <${Z.nodeName}> elements unsupported`);break}}for(let xe=0;xe<Q.length;xe++)I$5(Q[xe],X,K,J)}function o$r(Z,X,K){const J=Z.getAttribute(X);return J?Number(J):K}function M$5(Z){const X=Z.getAttribute("style"),K={},J={};let Q=!1,ee=!1;if(X){const te=X.split(";");for(let re=0;re<te.length;re++){const ie=te[re],[ne,se]=ie.split(":");switch(ne){case"stroke":se!=="none"&&(K.color=Color.shared.setValue(se).toNumber(),ee=!0);break;case"stroke-width":K.width=Number(se);break;case"fill":se!=="none"&&(Q=!0,J.color=Color.shared.setValue(se).toNumber());break;case"fill-opacity":J.alpha=Number(se);break;case"stroke-opacity":K.alpha=Number(se);break;case"opacity":J.alpha=Number(se),K.alpha=Number(se);break}}}else{const te=Z.getAttribute("stroke");te&&te!=="none"&&(ee=!0,K.color=Color.shared.setValue(te).toNumber(),K.width=o$r(Z,"stroke-width",1));const re=Z.getAttribute("fill");re&&re!=="none"&&(Q=!0,J.color=Color.shared.setValue(re).toNumber())}return{strokeStyle:ee?K:null,fillStyle:Q?J:null}}class ImageSource extends TextureSource{constructor(){super(...arguments),this.uploadMethodId="image"}static test(X){return typeof HTMLImageElement!="undefined"&&X instanceof HTMLImageElement||typeof ImageBitmap!="undefined"&&X instanceof ImageBitmap}}ImageSource.extension=u$v.TextureSource;const o$q=DOMAdapter.get().createCanvas(),t$b=1;o$q.width=t$b,o$q.height=t$b;const e$5=o$q.getContext("2d");e$5.fillStyle="#ffffff",e$5.fillRect(0,0,t$b,t$b),e$5.beginPath(),e$5.moveTo(0,0),e$5.lineTo(t$b,0),e$5.lineTo(t$b,t$b),e$5.closePath(),e$5.fillStyle="#ffffff",e$5.fill(),Texture.WHITE=new Texture({source:new ImageSource({resource:o$q,alphaMode:"premultiply-alpha-on-upload"})}),Texture.WHITE.label="WHITE",Texture.WHITE.destroy=NOOP;const n$v=class{constructor(Z,X,K,J){this.uid=uid("fillGradient"),this.type="linear",this.gradientStops=[],this.x0=Z,this.y0=X,this.x1=K,this.y1=J}addColorStop(Z,X){return this.gradientStops.push({offset:Z,color:Color.shared.setValue(X).toHex()}),this}buildLinearGradient(){const Z=n$v.defaultTextureSize,{gradientStops:X}=this,K=DOMAdapter.get().createCanvas();K.width=Z,K.height=Z;const J=K.getContext("2d"),Q=J.createLinearGradient(0,0,n$v.defaultTextureSize,1);for(let ce=0;ce<X.length;ce++){const de=X[ce];Q.addColorStop(de.offset,de.color)}J.fillStyle=Q,J.fillRect(0,0,Z,Z),this.texture=new Texture({source:new ImageSource({resource:K,style:{addressModeU:"clamp-to-edge",addressModeV:"repeat"}})});const{x0:ee,y0:te,x1:re,y1:ie}=this,ne=new Matrix,se=re-ee,oe=ie-te,ae=Math.sqrt(se*se+oe*oe),le=Math.atan2(oe,se);ne.translate(-ee,-te),ne.scale(1/Z,1/Z),ne.rotate(-le),ne.scale(256/ae,1),this.transform=ne}};let FillGradient=n$v;FillGradient.defaultTextureSize=256;const t$a={repeat:{addressModeU:"repeat",addressModeV:"repeat"},"repeat-x":{addressModeU:"repeat",addressModeV:"clamp-to-edge"},"repeat-y":{addressModeU:"clamp-to-edge",addressModeV:"repeat"},"no-repeat":{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}};class FillPattern{constructor(X,K){this.uid=uid("fillPattern"),this.transform=new Matrix,this.texture=X,this.transform.scale(1/X.frameWidth,1/X.frameHeight),K&&(X.source.style.addressModeU=t$a[K].addressModeU,X.source.style.addressModeV=t$a[K].addressModeV)}setTransform(X){const K=this.texture;this.transform.copyFrom(X),this.transform.invert(),this.transform.scale(1/K.frameWidth,1/K.frameHeight)}}var x$b=Object.defineProperty,S$7=Object.defineProperties,u$p=Object.getOwnPropertyDescriptors,p$A=Object.getOwnPropertySymbols,y$g=Object.prototype.hasOwnProperty,C$2=Object.prototype.propertyIsEnumerable,c$q=(Z,X,K)=>X in Z?x$b(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,n$u=(Z,X)=>{for(var K in X||(X={}))y$g.call(X,K)&&c$q(Z,K,X[K]);if(p$A)for(var K of p$A(X))C$2.call(X,K)&&c$q(Z,K,X[K]);return Z},f$r=(Z,X)=>S$7(Z,u$p(X));function convertFillInputToFillStyle(Z,X){var K;if(!Z)return null;let J,Q;if(Z!=null&&Z.fill?(Q=Z.fill,J=n$u(n$u({},X),Z)):(Q=Z,J=X),Color.isColorLike(Q)){const re=Color.shared.setValue(Q!=null?Q:0);return f$r(n$u({},J),{color:re.toNumber(),alpha:re.alpha===1?J.alpha:re.alpha,texture:Texture.WHITE})}else if(Q instanceof FillPattern){const re=Q;return f$r(n$u({},J),{color:16777215,texture:re.texture,matrix:re.transform,fill:(K=J.fill)!=null?K:null})}else if(Q instanceof FillGradient){const re=Q;return re.buildLinearGradient(),f$r(n$u({},J),{color:16777215,texture:re.texture,matrix:re.transform})}const ee=n$u(n$u({},X),Z);if(ee.texture!==Texture.WHITE){const re=ee.matrix||new Matrix;re.scale(1/ee.texture.frameWidth,1/ee.texture.frameHeight),ee.matrix=re,ee.color=16777215}const te=Color.shared.setValue(ee.color);return ee.alpha*=te.alpha,ee.color=te.toNumber(),ee}var g$l=Object.defineProperty,x$a=Object.getOwnPropertySymbols,I$4=Object.prototype.hasOwnProperty,M$4=Object.prototype.propertyIsEnumerable,v$5=(Z,X,K)=>X in Z?g$l(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,m$t=(Z,X)=>{for(var K in X||(X={}))I$4.call(X,K)&&v$5(Z,K,X[K]);if(x$a)for(var K of x$a(X))M$4.call(X,K)&&v$5(Z,K,X[K]);return Z};const c$p=new Point,F$3=new Matrix,u$o=class extends eventemitter3{constructor(){super(...arguments),this.uid=uid("graphicsContext"),this.dirty=!0,this.batchMode="auto",this.instructions=[],this._activePath=new GraphicsPath,this._transform=new Matrix,this._fillStyle=m$t({},u$o.defaultFillStyle),this._strokeStyle=m$t({},u$o.defaultStrokeStyle),this._stateStack=[],this._tick=0,this._bounds=new Bounds,this._boundsDirty=!0}get fillStyle(){return this._fillStyle}set fillStyle(Z){this._fillStyle=convertFillInputToFillStyle(Z,u$o.defaultFillStyle)}get strokeStyle(){return this._strokeStyle}set strokeStyle(Z){this._strokeStyle=convertFillInputToFillStyle(Z,u$o.defaultStrokeStyle)}texture(Z,X,K,J,Q,ee){return this.instructions.push({action:"texture",data:{image:Z,dx:K||0,dy:J||0,dw:Q||Z.frameWidth,dh:ee||Z.frameHeight,transform:this._transform.clone(),alpha:this._fillStyle.alpha,style:X?Color.shared.setValue(X).toNumber():0}}),this.onUpdate(),this}beginPath(){return this._activePath=new GraphicsPath,this}fill(Z,X){let K;const J=this.instructions[this.instructions.length-1];return this._tick===0&&J&&J.action==="stroke"?K=J.data.path:K=this._activePath.clone(),K?(Z&&(X!==void 0&&typeof Z=="number"&&(deprecation("8.0.0","GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"),Z={color:Z,alpha:X}),this._fillStyle=convertFillInputToFillStyle(Z,u$o.defaultFillStyle)),this.instructions.push({action:"fill",data:{style:this.fillStyle,path:K}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}_initNextPathLocation(){const{x:Z,y:X}=this._activePath.getLastPoint(Point.shared);this._activePath.clear(),this._activePath.moveTo(Z,X)}stroke(Z){let X;const K=this.instructions[this.instructions.length-1];return this._tick===0&&K&&K.action==="fill"?X=K.data.path:X=this._activePath.clone(),X?(Z&&(this._strokeStyle=convertFillInputToFillStyle(Z,u$o.defaultStrokeStyle)),this.instructions.push({action:"stroke",data:{style:this.strokeStyle,path:X}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}cut(){for(let Z=0;Z<2;Z++){const X=this.instructions[this.instructions.length-1-Z],K=this._activePath.clone();X&&(X.action==="stroke"||X.action==="fill")&&(X.data.hole?X.data.hole.addPath(K):X.data.hole=K)}return this._initNextPathLocation(),this}arc(Z,X,K,J,Q,ee){this._tick++;const te=this._transform;return this._activePath.arc(te.a*Z+te.c*X+te.tx,te.b*Z+te.d*X+te.ty,K,J,Q,ee),this}arcTo(Z,X,K,J,Q){this._tick++;const ee=this._transform;return this._activePath.arcTo(ee.a*Z+ee.c*X+ee.tx,ee.b*Z+ee.d*X+ee.ty,ee.a*K+ee.c*J+ee.tx,ee.b*K+ee.d*J+ee.ty,Q),this}arcToSvg(Z,X,K,J,Q,ee,te){this._tick++;const re=this._transform;return this._activePath.arcToSvg(Z,X,K,J,Q,re.a*ee+re.c*te+re.tx,re.b*ee+re.d*te+re.ty),this}bezierCurveTo(Z,X,K,J,Q,ee){this._tick++;const te=this._transform;return this._activePath.bezierCurveTo(te.a*Z+te.c*X+te.tx,te.b*Z+te.d*X+te.ty,te.a*K+te.c*J+te.tx,te.b*K+te.d*J+te.ty,te.a*Q+te.c*ee+te.tx,te.b*Q+te.d*ee+te.ty),this}closePath(){var Z;return this._tick++,(Z=this._activePath)==null||Z.closePath(),this}ellipse(Z,X,K,J){return this._tick++,this._activePath.ellipse(Z,X,K,J,this._transform.clone()),this}circle(Z,X,K){return this._tick++,this._activePath.circle(Z,X,K,this._transform.clone()),this}path(Z){return this._tick++,this._activePath.addPath(Z,this._transform.clone()),this}lineTo(Z,X){this._tick++;const K=this._transform;return this._activePath.lineTo(K.a*Z+K.c*X+K.tx,K.b*Z+K.d*X+K.ty),this}moveTo(Z,X){this._tick++;const K=this._transform,J=this._activePath.instructions,Q=K.a*Z+K.c*X+K.tx,ee=K.b*Z+K.d*X+K.ty;return J.length===1&&J[0].action==="moveTo"?(J[0].data[0]=Q,J[0].data[1]=ee,this):(this._activePath.moveTo(Q,ee),this)}quadraticCurveTo(Z,X,K,J){this._tick++;const Q=this._transform;this._activePath.quadraticCurveTo(Q.a*Z+Q.c*X+Q.tx,Q.b*Z+Q.d*X+Q.ty,Q.a*K+Q.c*J+Q.tx,Q.b*K+Q.d*J+Q.ty)}rect(Z,X,K,J){return this._tick++,this._activePath.rect(Z,X,K,J,this._transform.clone()),this}roundRect(Z,X,K,J,Q){return this._tick++,this._activePath.roundRect(Z,X,K,J,Q,this._transform.clone()),this}poly(Z,X){return this._tick++,this._activePath.poly(Z,X,this._transform.clone()),this}regularPoly(Z,X,K,J,Q=0,ee){return this._tick++,this._activePath.regularPoly(Z,X,K,J,Q,ee),this}roundPoly(Z,X,K,J,Q,ee){return this._tick++,this._activePath.roundPoly(Z,X,K,J,Q,ee),this}roundShape(Z,X,K){return this._tick++,this._activePath.roundShape(Z,X,K),this}filletRect(Z,X,K,J,Q){return this._tick++,this._activePath.filletRect(Z,X,K,J,Q),this}chamferRect(Z,X,K,J,Q,ee){return this._tick++,this._activePath.chamferRect(Z,X,K,J,Q,ee),this}star(Z,X,K,J,Q,ee){return this._tick++,this._activePath.star(Z,X,K,J,Q,ee,this._transform.clone()),this}svg(Z){this._tick++,SVGParser(Z,this)}restore(){const Z=this._stateStack.pop();Z&&(this._transform=Z.transform,this._fillStyle=Z.fillStyle,this._strokeStyle=Z.strokeStyle)}save(){this._stateStack.push({transform:this._transform.clone(),fillStyle:m$t({},this._fillStyle),strokeStyle:m$t({},this._strokeStyle)})}getTransform(){return this._transform}resetTransform(){return this._transform.identity(),this}rotate(Z){return this._transform.rotate(Z),this}scale(Z,X=Z){return this._transform.scale(Z,X),this}setTransform(Z,X,K,J,Q,ee){return Z instanceof Matrix?(this._transform.set(Z.a,Z.b,Z.c,Z.d,Z.tx,Z.ty),this):(this._transform.set(Z,X,K,J,Q,ee),this)}transform(Z,X,K,J,Q,ee){return Z instanceof Matrix?(this._transform.append(Z),this):(F$3.set(Z,X,K,J,Q,ee),this._transform.append(F$3),this)}translate(Z,X){return this._transform.translate(Z,X),this}clear(){return this.instructions.length=0,this.resetTransform(),this.onUpdate(),this}onUpdate(){this.dirty||(this.emit("update",this,16),this.dirty=!0,this._boundsDirty=!0)}get bounds(){if(!this._boundsDirty)return this._bounds;const Z=this._bounds;Z.clear();for(let X=0;X<this.instructions.length;X++){const K=this.instructions[X],J=K.action;if(J==="fill"){const Q=K.data;Z.addBounds(Q.path.bounds)}else if(J==="texture"){const Q=K.data;Z.pushMatrix(Q.transform),Z.addFrame(Q.dx,Q.dy,Q.dx+Q.dw,Q.dy+Q.dh),Z.popMatrix()}}return Z}containsPoint(Z){const X=this.instructions;let K=!1;return X.forEach(J=>{var Q;const ee=J.data,te=ee.path;if(!J.action||!te)return;const re=ee.style,ie=(Q=te.shapePath)==null?void 0:Q.shapePrimitives;this._forEachShape(ie,ne=>{var se;if(!re||!ne)return;typeof re!="number"&&re.matrix?re.matrix.applyInverse(Z,c$p):c$p.copyFrom(Z),K=ne.contains(c$p.x,c$p.y);const oe=ee.hole;if(!oe)return;const ae=(se=oe.shapePath)==null?void 0:se.shapePrimitives;ae&&this._forEachShape(ae,le=>{le.contains(c$p.x,c$p.y)&&(K=!1)})})}),K}_forEachShape(Z,X){Z==null||Z.forEach(K=>{const J=K==null?void 0:K.shape;J&&X(J)})}destroy(Z=!1){if(this._stateStack.length=0,this._transform=null,this.emit("destroy",this),this.removeAllListeners(),typeof Z=="boolean"?Z:Z==null?void 0:Z.texture){const X=typeof Z=="boolean"?Z:Z==null?void 0:Z.textureSource;this._fillStyle.texture&&this._fillStyle.texture.destroy(X),this._strokeStyle.texture&&this._strokeStyle.texture.destroy(X)}this._fillStyle=null,this._strokeStyle=null,this.instructions=null,this._activePath=null,this._bounds=null,this._stateStack=null,this.customShader=null,this._transform=null}};let GraphicsContext=u$o;GraphicsContext.defaultFillStyle={color:16777215,alpha:1,texture:Texture.WHITE,matrix:null,fill:null},GraphicsContext.defaultStrokeStyle={width:1,color:16777215,alpha:1,alignment:.5,miterLimit:10,cap:"butt",join:"miter",texture:Texture.WHITE,matrix:null,fill:null};const m$s=/^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m,p$z=".svg",c$o="image/svg+xml",loadSvg={extension:{type:u$v.LoadParser,priority:LoaderParserPriority.Low},name:"loadSVG",test(Z){return checkDataUrl(Z,c$o)||checkExtension(Z,p$z)},async testParse(Z){return typeof Z=="string"&&Z.startsWith("data:image/svg+xml")||typeof Z=="string"&&m$s.test(Z)},async parse(Z){const X=new GraphicsContext;return X.svg(Z),X},async load(Z){return(await DOMAdapter.get().fetch(Z)).text()},unload(Z){Z.destroy(!0)}};function getResolutionOfUrl(Z,X=1){var K;const J=(K=Resolver.RETINA_PREFIX)==null?void 0:K.exec(Z);return J?parseFloat(J[1]):X}let o$p=0,i$l;const p$y="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=",m$r={id:"checkImageBitmap",code:`
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${p$y}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `},u$n={id:"loadImageBitmap",code:`
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`};let s$x;class c$n{constructor(){this._initialized=!1,this._createdWorkers=0,this._workerPool=[],this._queue=[],this._resolveHash={}}isImageBitmapSupported(){return this._isImageBitmapSupported!==void 0?this._isImageBitmapSupported:(this._isImageBitmapSupported=new Promise(X=>{const K=URL.createObjectURL(new Blob([m$r.code],{type:"application/javascript"})),J=new Worker(K);J.addEventListener("message",Q=>{J.terminate(),URL.revokeObjectURL(K),X(Q.data)})}),this._isImageBitmapSupported)}loadImageBitmap(X){return this._run("loadImageBitmap",[X])}async _initWorkers(){this._initialized||(this._initialized=!0)}_getWorker(){i$l===void 0&&(i$l=navigator.hardwareConcurrency||4);let X=this._workerPool.pop();return!X&&this._createdWorkers<i$l&&(s$x||(s$x=URL.createObjectURL(new Blob([u$n.code],{type:"application/javascript"}))),this._createdWorkers++,X=new Worker(s$x),X.addEventListener("message",K=>{this._complete(K.data),this._returnWorker(K.target),this._next()})),X}_returnWorker(X){this._workerPool.push(X)}_complete(X){X.error!==void 0?this._resolveHash[X.uuid].reject(X.error):this._resolveHash[X.uuid].resolve(X.data),this._resolveHash[X.uuid]=null}async _run(X,K){await this._initWorkers();const J=new Promise((Q,ee)=>{this._queue.push({id:X,arguments:K,resolve:Q,reject:ee})});return this._next(),J}_next(){if(!this._queue.length)return;const X=this._getWorker();if(!X)return;const K=this._queue.pop(),J=K.id;this._resolveHash[o$p]={resolve:K.resolve,reject:K.reject},X.postMessage({data:K.arguments,uuid:o$p++,id:J})}}const d$j=new c$n;function createTexture(Z,X,K){Z.label=K;const J=new Texture({source:Z,label:K}),Q=()=>{delete X.promiseCache[K],Cache.has(K)&&Cache.remove(K)};return J.once("destroy",()=>{K in X.promiseCache&&Q()}),J.source.once("destroy",()=>{Z.destroyed||Q()}),J}var c$m=Object.defineProperty,s$w=Object.getOwnPropertySymbols,d$i=Object.prototype.hasOwnProperty,f$q=Object.prototype.propertyIsEnumerable,m$q=(Z,X,K)=>X in Z?c$m(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,n$t=(Z,X)=>{for(var K in X||(X={}))d$i.call(X,K)&&m$q(Z,K,X[K]);if(s$w)for(var K of s$w(X))f$q.call(X,K)&&m$q(Z,K,X[K]);return Z};const B$4=[".jpeg",".jpg",".png",".webp",".avif"],L$3=["image/jpeg","image/png","image/webp","image/avif"];async function loadImageBitmap(Z){const X=await DOMAdapter.get().fetch(Z);if(!X.ok)throw new Error(`[loadImageBitmap] Failed to fetch ${Z}: ${X.status} ${X.statusText}`);const K=await X.blob();return await createImageBitmap(K)}const loadTextures={name:"loadTextures",extension:{type:u$v.LoadParser,priority:LoaderParserPriority.High},config:{preferWorkers:!0,preferCreateImageBitmap:!0,crossOrigin:"anonymous"},test(Z){return checkDataUrl(Z,L$3)||checkExtension(Z,B$4)},async load(Z,X,K){var J;let Q=null;globalThis.createImageBitmap&&this.config.preferCreateImageBitmap?this.config.preferWorkers&&await d$j.isImageBitmapSupported()?Q=await d$j.loadImageBitmap(Z):Q=await loadImageBitmap(Z):Q=await new Promise(te=>{Q=new Image,Q.crossOrigin=this.config.crossOrigin,Q.src=Z,Q.complete?te(Q):Q.onload=()=>{te(Q)}});const ee=new ImageSource(n$t({resource:Q,alphaMode:"premultiply-alpha-on-upload",resolution:((J=X.data)==null?void 0:J.resolution)||getResolutionOfUrl(Z)},X.data));return createTexture(ee,K,Z)},unload(Z){Z.destroy(!0)}};let t$9;async function detectVideoAlphaMode(){return t$9!=null||(t$9=(async()=>{var Z;const X=document.createElement("canvas").getContext("webgl");if(!X)return"premultiply-alpha-on-upload";const K=await new Promise(te=>{const re=document.createElement("video");re.onloadeddata=()=>te(re),re.onerror=()=>te(null),re.autoplay=!1,re.crossOrigin="anonymous",re.preload="auto",re.src="data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=",re.load()});if(!K)return"premultiply-alpha-on-upload";const J=X.createTexture();X.bindTexture(X.TEXTURE_2D,J);const Q=X.createFramebuffer();X.bindFramebuffer(X.FRAMEBUFFER,Q),X.framebufferTexture2D(X.FRAMEBUFFER,X.COLOR_ATTACHMENT0,X.TEXTURE_2D,J,0),X.pixelStorei(X.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),X.pixelStorei(X.UNPACK_COLORSPACE_CONVERSION_WEBGL,X.NONE),X.texImage2D(X.TEXTURE_2D,0,X.RGBA,X.RGBA,X.UNSIGNED_BYTE,K);const ee=new Uint8Array(4);return X.readPixels(0,0,1,1,X.RGBA,X.UNSIGNED_BYTE,ee),X.deleteFramebuffer(Q),X.deleteTexture(J),(Z=X.getExtension("WEBGL_lose_context"))==null||Z.loseContext(),ee[0]<=ee[3]?"premultiplied-alpha":"premultiply-alpha-on-upload"})()),t$9}var c$l=Object.defineProperty,_$5=Object.defineProperties,m$p=Object.getOwnPropertyDescriptors,d$h=Object.getOwnPropertySymbols,v$4=Object.prototype.hasOwnProperty,y$f=Object.prototype.propertyIsEnumerable,l$m=(Z,X,K)=>X in Z?c$l(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$o=(Z,X)=>{for(var K in X||(X={}))v$4.call(X,K)&&l$m(Z,K,X[K]);if(d$h)for(var K of d$h(X))y$f.call(X,K)&&l$m(Z,K,X[K]);return Z},u$m=(Z,X)=>_$5(Z,m$p(X));const r$9=class extends TextureSource{constructor(Z){var X;super(Z),this.isReady=!1,this.uploadMethodId="video",Z=o$o(o$o({},r$9.defaultOptions),Z),this._autoUpdate=!0,this._isConnectedToTicker=!1,this._updateFPS=Z.updateFPS||0,this._msToNextUpdate=0,this.autoPlay=Z.autoPlay!==!1,this.alphaMode=(X=Z.alphaMode)!=null?X:"premultiply-alpha-on-upload",this._videoFrameRequestCallback=this._videoFrameRequestCallback.bind(this),this._videoFrameRequestCallbackHandle=null,this._load=null,this._resolve=null,this._reject=null,this._onCanPlay=this._onCanPlay.bind(this),this._onCanPlayThrough=this._onCanPlayThrough.bind(this),this._onError=this._onError.bind(this),this._onPlayStart=this._onPlayStart.bind(this),this._onPlayStop=this._onPlayStop.bind(this),this._onSeeked=this._onSeeked.bind(this),Z.autoLoad!==!1&&this.load()}updateFrame(){if(!this.destroyed){if(this._updateFPS){const Z=Ticker.shared.elapsedMS*this.resource.playbackRate;this._msToNextUpdate=Math.floor(this._msToNextUpdate-Z)}(!this._updateFPS||this._msToNextUpdate<=0)&&(this._msToNextUpdate=this._updateFPS?Math.floor(1e3/this._updateFPS):0),this.isValid&&this.update()}}_videoFrameRequestCallback(){this.updateFrame(),this.destroyed?this._videoFrameRequestCallbackHandle=null:this._videoFrameRequestCallbackHandle=this.source.requestVideoFrameCallback(this._videoFrameRequestCallback)}get isValid(){return!!this.resource.videoWidth&&!!this.resource.videoHeight}async load(){if(this._load)return this._load;const Z=this.resource,X=this.options;return(Z.readyState===Z.HAVE_ENOUGH_DATA||Z.readyState===Z.HAVE_FUTURE_DATA)&&Z.width&&Z.height&&(Z.complete=!0),Z.addEventListener("play",this._onPlayStart),Z.addEventListener("pause",this._onPlayStop),Z.addEventListener("seeked",this._onSeeked),this._isSourceReady()?this._mediaReady():(X.preload||Z.addEventListener("canplay",this._onCanPlay),Z.addEventListener("canplaythrough",this._onCanPlayThrough),Z.addEventListener("error",this._onError,!0)),this.alphaMode=await detectVideoAlphaMode(),this._load=new Promise((K,J)=>{this.isValid?K(this):(this._resolve=K,this._reject=J,X.preloadTimeoutMs!==void 0&&(this._preloadTimeout=setTimeout(()=>{this._onError(new ErrorEvent(`Preload exceeded timeout of ${X.preloadTimeoutMs}ms`))})),Z.load())}),this._load}_onError(Z){this.resource.removeEventListener("error",this._onError,!0),this.emit("error",Z),this._reject&&(this._reject(Z),this._reject=null,this._resolve=null)}_isSourcePlaying(){const Z=this.resource;return!Z.paused&&!Z.ended}_isSourceReady(){return this.resource.readyState>2}_onPlayStart(){this.isValid||this._mediaReady(),this._configureAutoUpdate()}_onPlayStop(){this._configureAutoUpdate()}_onSeeked(){this._autoUpdate&&!this._isSourcePlaying()&&(this._msToNextUpdate=0,this.updateFrame(),this._msToNextUpdate=0)}_onCanPlay(){this.resource.removeEventListener("canplay",this._onCanPlay),this._mediaReady()}_onCanPlayThrough(){this.resource.removeEventListener("canplaythrough",this._onCanPlay),this._preloadTimeout&&(clearTimeout(this._preloadTimeout),this._preloadTimeout=void 0),this._mediaReady()}_mediaReady(){const Z=this.resource;this.isValid&&(this.isReady=!0,this.resize(Z.videoWidth,Z.videoHeight)),this._msToNextUpdate=0,this.updateFrame(),this._msToNextUpdate=0,this._resolve&&(this._resolve(this),this._resolve=null,this._reject=null),this._isSourcePlaying()?this._onPlayStart():this.autoPlay&&this.resource.play()}destroy(){this._configureAutoUpdate();const Z=this.resource;Z&&(Z.removeEventListener("play",this._onPlayStart),Z.removeEventListener("pause",this._onPlayStop),Z.removeEventListener("seeked",this._onSeeked),Z.removeEventListener("canplay",this._onCanPlay),Z.removeEventListener("canplaythrough",this._onCanPlayThrough),Z.removeEventListener("error",this._onError,!0),Z.pause(),Z.src="",Z.load()),super.destroy()}get autoUpdate(){return this._autoUpdate}set autoUpdate(Z){Z!==this._autoUpdate&&(this._autoUpdate=Z,this._configureAutoUpdate())}get updateFPS(){return this._updateFPS}set updateFPS(Z){Z!==this._updateFPS&&(this._updateFPS=Z,this._configureAutoUpdate())}_configureAutoUpdate(){this._autoUpdate&&this._isSourcePlaying()?!this._updateFPS&&this.source.requestVideoFrameCallback?(this._isConnectedToTicker&&(Ticker.shared.remove(this.updateFrame,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0),this._videoFrameRequestCallbackHandle===null&&(this._videoFrameRequestCallbackHandle=this.source.requestVideoFrameCallback(this._videoFrameRequestCallback))):(this._videoFrameRequestCallbackHandle!==null&&(this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker||(Ticker.shared.add(this.updateFrame,this),this._isConnectedToTicker=!0,this._msToNextUpdate=0)):(this._videoFrameRequestCallbackHandle!==null&&(this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker&&(Ticker.shared.remove(this.updateFrame,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0))}static test(Z){return globalThis.HTMLVideoElement&&Z instanceof HTMLVideoElement||globalThis.VideoFrame&&Z instanceof VideoFrame}};let VideoSource=r$9;VideoSource.extension=u$v.TextureSource,VideoSource.defaultOptions=u$m(o$o({},TextureSource.defaultOptions),{autoLoad:!0,autoPlay:!0,updateFPS:0,crossorigin:!0,loop:!1,muted:!0,playsinline:!0,preload:!1}),VideoSource.MIME_TYPES={ogv:"video/ogg",mov:"video/quicktime",m4v:"video/mp4"};var x$9=Object.defineProperty,E$2=Object.defineProperties,L$2=Object.getOwnPropertyDescriptors,v$3=Object.getOwnPropertySymbols,V=Object.prototype.hasOwnProperty,b$k=Object.prototype.propertyIsEnumerable,y$e=(Z,X,K)=>X in Z?x$9(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,p$x=(Z,X)=>{for(var K in X||(X={}))V.call(X,K)&&y$e(Z,K,X[K]);if(v$3)for(var K of v$3(X))b$k.call(X,K)&&y$e(Z,K,X[K]);return Z},u$l=(Z,X)=>E$2(Z,L$2(X));const g$k=[".mp4",".m4v",".webm",".ogg",".ogv",".h264",".avi",".mov"],U$2=g$k.map(Z=>`video/${Z.substring(1)}`);function crossOrigin(Z,X,K){K===void 0&&!X.startsWith("data:")?Z.crossOrigin=determineCrossOrigin(X):K!==!1&&(Z.crossOrigin=typeof K=="string"?K:"anonymous")}function preloadVideo(Z){return new Promise((X,K)=>{Z.addEventListener("canplaythrough",J),Z.addEventListener("error",Q),Z.load();function J(){ee(),X()}function Q(te){ee(),K(te)}function ee(){Z.removeEventListener("canplaythrough",J),Z.removeEventListener("error",Q)}})}function determineCrossOrigin(Z,X=globalThis.location){if(Z.startsWith("data:"))return"";X=X||globalThis.location;const K=new URL(Z,document.baseURI);return K.hostname!==X.hostname||K.port!==X.port||K.protocol!==X.protocol?"anonymous":""}const loadVideoTextures={name:"loadVideo",extension:{type:u$v.LoadParser},config:null,test(Z){const X=checkDataUrl(Z,U$2),K=checkExtension(Z,g$k);return X||K},async load(Z,X,K){var J,Q;const ee=p$x(u$l(p$x({},VideoSource.defaultOptions),{resolution:((J=X.data)==null?void 0:J.resolution)||getResolutionOfUrl(Z),alphaMode:((Q=X.data)==null?void 0:Q.alphaMode)||await detectVideoAlphaMode()}),X.data),te=document.createElement("video"),re={preload:ee.autoLoad!==!1?"auto":void 0,"webkit-playsinline":ee.playsinline!==!1?"":void 0,playsinline:ee.playsinline!==!1?"":void 0,muted:ee.muted===!0?"":void 0,loop:ee.loop===!0?"":void 0,autoplay:ee.autoPlay!==!1?"":void 0};Object.keys(re).forEach(oe=>{const ae=re[oe];ae!==void 0&&te.setAttribute(oe,ae)}),ee.muted===!0&&(te.muted=!0),crossOrigin(te,Z,ee.crossorigin);const ie=document.createElement("source");let ne;if(Z.startsWith("data:"))ne=Z.slice(5,Z.indexOf(";"));else if(!Z.startsWith("blob:")){const oe=Z.split("?")[0].slice(Z.lastIndexOf(".")+1).toLowerCase();ne=VideoSource.MIME_TYPES[oe]||`video/${oe}`}ie.src=Z,ne&&(ie.type=ne),te.appendChild(ie);const se=new VideoSource(u$l(p$x({},ee),{resource:te}));return X.data.preload&&await preloadVideo(te),createTexture(se,K,Z)},unload(Z){Z.destroy(!0)}},resolveTextureUrl={extension:u$v.ResolveParser,test:loadTextures.test,parse:Z=>{var X,K;return{resolution:parseFloat((K=(X=Resolver.RETINA_PREFIX.exec(Z))==null?void 0:X[1])!=null?K:"1"),format:Z.split(".").pop(),src:Z}}};b$p.add(cacheTextureArray,detectDefaults,detectAvif,detectWebp,detectMp4,detectOgv,detectWebm,loadJson,loadTxt,loadWebFont,loadSvg,loadTextures,loadVideoTextures,resolveTextureUrl,xmlBitmapFontLoader,bitmapFontCachePlugin);const a$u={loader:u$v.LoadParser,resolver:u$v.ResolveParser,cache:u$v.CacheParser,detection:u$v.DetectionParser};b$p.handle(u$v.Asset,Z=>{const X=Z.ref;Object.entries(a$u).filter(([K])=>!!X[K]).forEach(([K,J])=>{var Q;return b$p.add(Object.assign(X[K],{extension:(Q=X[K].extension)!=null?Q:J}))})},Z=>{const X=Z.ref;Object.keys(a$u).filter(K=>!!X[K]).forEach(K=>b$p.remove(X[K]))});const detectBasis={extension:{type:u$v.DetectionParser,priority:3},test:async()=>!!(await isWebGPUSupported()||isWebGLSupported()),add:async Z=>[...Z,"basis"],remove:async Z=>Z.filter(X=>X!=="basis")};class CompressedSource extends TextureSource{constructor(X){super(X),this.uploadMethodId="compressed",this.resource=X.resource,this.mipLevelCount=this.resource.length}}let s$v;function getSupportedGlCompressedTextureFormats(){if(s$v)return s$v;const Z=document.createElement("canvas").getContext("webgl");return Z?(s$v=[...Z.getExtension("WEBGL_compressed_texture_s3tc")?["bc2-rgba-unorm","bc3-rgba-unorm","bc7-rgba-unorm"]:[],...Z.getExtension("WEBGL_compressed_texture_s3tc_srgb")?["bc2-rgba-unorm-srgb","bc3-rgba-unorm-srgb","bc7-rgba-unorm-srgb"]:[],...Z.getExtension("WEBGL_compressed_texture_astc")?["etc2-rgb8unorm","etc2-rgb8unorm-srgb","etc2-rgba8unorm","etc2-rgba8unorm-srgb","etc2-rgb8a1unorm","etc2-rgb8a1unorm-srgb","eac-r11unorm","eac-rg11unorm"]:[],...Z.getExtension("WEBGL_compressed_texture_astc")?["astc-4x4-unorm","astc-4x4-unorm-srgb","astc-5x4-unorm","astc-5x4-unorm-srgb","astc-5x5-unorm","astc-5x5-unorm-srgb","astc-6x5-unorm","astc-6x5-unorm-srgb","astc-6x6-unorm","astc-6x6-unorm-srgb","astc-8x5-unorm","astc-8x5-unorm-srgb","astc-8x6-unorm","astc-8x6-unorm-srgb","astc-8x8-unorm","astc-8x8-unorm-srgb","astc-10x5-unorm","astc-10x5-unorm-srgb","astc-10x6-unorm","astc-10x6-unorm-srgb","astc-10x8-unorm","astc-10x8-unorm-srgb","astc-10x10-unorm","astc-10x10-unorm-srgb","astc-12x10-unorm","astc-12x10-unorm-srgb","astc-12x12-unorm","astc-12x12-unorm-srgb"]:[]],s$v):[]}let r$8;async function getSupportedGPUCompressedTextureFormats(){if(r$8)return r$8;const Z=await navigator.gpu.requestAdapter();return r$8=[...Z.features.has("texture-compression-bc")?["bc1-rgba-unorm","bc1-rgba-unorm-srgb","bc2-rgba-unorm","bc2-rgba-unorm-srgb","bc3-rgba-unorm","bc3-rgba-unorm-srgb","bc4-r-unorm","bc4-r-snorm","bc5-rg-unorm","bc5-rg-snorm","bc6h-rgb-ufloat","bc6h-rgb-float","bc7-rgba-unorm","bc7-rgba-unorm-srgb"]:[],...Z.features.has("texture-compression-etc2")?["etc2-rgb8unorm","etc2-rgb8unorm-srgb","etc2-rgb8a1unorm","etc2-rgb8a1unorm-srgb","etc2-rgba8unorm","etc2-rgba8unorm-srgb","eac-r11unorm","eac-r11snorm","eac-rg11unorm","eac-rg11snorm"]:[],...Z.features.has("texture-compression-astc")?["astc-4x4-unorm","astc-4x4-unorm-srgb","astc-5x4-unorm","astc-5x4-unorm-srgb","astc-5x5-unorm","astc-5x5-unorm-srgb","astc-6x5-unorm","astc-6x5-unorm-srgb","astc-6x6-unorm","astc-6x6-unorm-srgb","astc-8x5-unorm","astc-8x5-unorm-srgb","astc-8x6-unorm","astc-8x6-unorm-srgb","astc-8x8-unorm","astc-8x8-unorm-srgb","astc-10x5-unorm","astc-10x5-unorm-srgb","astc-10x6-unorm","astc-10x6-unorm-srgb","astc-10x8-unorm","astc-10x8-unorm-srgb","astc-10x10-unorm","astc-10x10-unorm-srgb","astc-12x10-unorm","astc-12x10-unorm-srgb","astc-12x12-unorm","astc-12x12-unorm-srgb"]:[]],r$8}let e$4;async function getSupportedCompressedTextureFormats(){return e$4!==void 0||(e$4=await(async()=>{const Z=await isWebGPUSupported(),X=isWebGLSupported();if(Z&&X){const K=await getSupportedGPUCompressedTextureFormats(),J=getSupportedGlCompressedTextureFormats();return K.filter(Q=>J.includes(Q))}else{if(Z)return await getSupportedGPUCompressedTextureFormats();if(X)return getSupportedGlCompressedTextureFormats()}return[]})()),e$4}const nonCompressedFormats=["r8unorm","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8unorm-srgb","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","bgra8unorm-srgb","rgb9e5ufloat","rgb10a2unorm","rg11b10ufloat","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","stencil8","depth16unorm","depth24plus","depth24plus-stencil8","depth32float","depth32float-stencil8"];let r$7;async function getSupportedTextureFormats(){if(r$7!==void 0)return r$7;const Z=await getSupportedCompressedTextureFormats();return r$7=[...nonCompressedFormats,...Z],r$7}function decodeBase64(Z,X){var K=atob(Z);if(X){for(var J=new Uint8Array(K.length),Q=0,ee=K.length;Q<ee;++Q)J[Q]=K.charCodeAt(Q);return new TextDecoder("utf-16le").decode(new Uint16Array(J.buffer))}return K}function createURL(Z,X,K){var J=X===void 0?null:X,Q=K===void 0?!1:K,ee=decodeBase64(Z,Q),te=ee.indexOf(`
`,10)+1,re=ee.substring(te)+(J?"//# sourceMappingURL="+J:""),ie=new Blob([re],{type:"application/javascript"});return URL.createObjectURL(ie)}function createBase64WorkerFactory(Z,X,K){var J;return function(ee){return J=J||createURL(Z,X,K),new Worker(J,ee)}}var WorkerFactory$1=createBase64WorkerFactory("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICAgJ3VzZSBzdHJpY3QnOwoKICAgIGZ1bmN0aW9uIGNyZWF0ZUxldmVsQnVmZmVycyhiYXNpc1RleHR1cmUsIGJhc2lzVHJhbnNjb2RlckZvcm1hdCkgewogICAgICBjb25zdCBpbWFnZXMgPSBiYXNpc1RleHR1cmUuZ2V0TnVtSW1hZ2VzKCk7CiAgICAgIGNvbnN0IGxldmVscyA9IGJhc2lzVGV4dHVyZS5nZXROdW1MZXZlbHMoMCk7CiAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBiYXNpc1RleHR1cmUuc3RhcnRUcmFuc2NvZGluZygpOwogICAgICBpZiAoIXN1Y2Nlc3MpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInN0YXJ0VHJhbnNjb2RpbmcgZmFpbGVkIik7CiAgICAgIH0KICAgICAgY29uc3QgbGV2ZWxCdWZmZXJzID0gW107CiAgICAgIGZvciAobGV0IGxldmVsSW5kZXggPSAwOyBsZXZlbEluZGV4IDwgbGV2ZWxzOyArK2xldmVsSW5kZXgpIHsKICAgICAgICBmb3IgKGxldCBzbGljZUluZGV4ID0gMDsgc2xpY2VJbmRleCA8IGltYWdlczsgKytzbGljZUluZGV4KSB7CiAgICAgICAgICBjb25zdCB0cmFuc2NvZGVTaXplID0gYmFzaXNUZXh0dXJlLmdldEltYWdlVHJhbnNjb2RlZFNpemVJbkJ5dGVzKHNsaWNlSW5kZXgsIGxldmVsSW5kZXgsIGJhc2lzVHJhbnNjb2RlckZvcm1hdCk7CiAgICAgICAgICBjb25zdCBsZXZlbEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRyYW5zY29kZVNpemUpOwogICAgICAgICAgY29uc3Qgc3VjY2VzczIgPSBiYXNpc1RleHR1cmUudHJhbnNjb2RlSW1hZ2UobGV2ZWxCdWZmZXIsIHNsaWNlSW5kZXgsIGxldmVsSW5kZXgsIGJhc2lzVHJhbnNjb2RlckZvcm1hdCwgMSwgMCk7CiAgICAgICAgICBpZiAoIXN1Y2Nlc3MyKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigidHJhbnNjb2RlSW1hZ2UgZmFpbGVkIik7CiAgICAgICAgICB9CiAgICAgICAgICBsZXZlbEJ1ZmZlcnMucHVzaChsZXZlbEJ1ZmZlcik7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBsZXZlbEJ1ZmZlcnM7CiAgICB9CgogICAgY29uc3QgZ3B1Rm9ybWF0VG9CYXNpc1RyYW5zY29kZXJGb3JtYXRNYXAgPSB7CiAgICAgICJiYzMtcmdiYS11bm9ybSI6IDMsCiAgICAgIC8vIGNURkJDM19SR0JBCiAgICAgICJiYzctcmdiYS11bm9ybSI6IDYsCiAgICAgIC8vIGNURkJDN19SR0JBLAogICAgICAiZXRjMi1yZ2JhOHVub3JtIjogMSwKICAgICAgLy8gY1RGRVRDMl9SR0JBLAogICAgICAiYXN0Yy00eDQtdW5vcm0iOiAxMCwKICAgICAgLy8gY1RGQVNUQ180eDRfUkdCQSwKICAgICAgLy8gVW5jb21wcmVzc2VkCiAgICAgIHJnYmE4dW5vcm06IDEzLAogICAgICAvLyBjVEZSR0JBMzIsCiAgICAgIHJnYmE0dW5vcm06IDE2CiAgICAgIC8vIGNURlJHQkE0NDQ0LAogICAgfTsKICAgIGZ1bmN0aW9uIGdwdUZvcm1hdFRvQmFzaXNUcmFuc2NvZGVyRm9ybWF0KHRyYW5zY29kZXJGb3JtYXQpIHsKICAgICAgY29uc3QgZm9ybWF0ID0gZ3B1Rm9ybWF0VG9CYXNpc1RyYW5zY29kZXJGb3JtYXRNYXBbdHJhbnNjb2RlckZvcm1hdF07CiAgICAgIGlmIChmb3JtYXQpIHsKICAgICAgICByZXR1cm4gZm9ybWF0OwogICAgICB9CiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHJhbnNjb2RlckZvcm1hdDogJHt0cmFuc2NvZGVyRm9ybWF0fWApOwogICAgfQoKICAgIGNvbnN0IHNldHRpbmdzID0gewogICAgICBqc1VybDogImJhc2lzL2Jhc2lzX3RyYW5zY29kZXIuanMiLAogICAgICB3YXNtVXJsOiAiYmFzaXMvYmFzaXNfdHJhbnNjb2Rlci53YXNtIgogICAgfTsKICAgIGxldCBiYXNpc1RyYW5zY29kZXJGb3JtYXQ7CiAgICBsZXQgYmFzaXNUcmFuc2NvZGVkVGV4dHVyZUZvcm1hdDsKICAgIGxldCBiYXNpc1Byb21pc2U7CiAgICBhc3luYyBmdW5jdGlvbiBnZXRCYXNpcygpIHsKICAgICAgaWYgKCFiYXNpc1Byb21pc2UpIHsKICAgICAgICBjb25zdCBhYnNvbHV0ZUpzVXJsID0gbmV3IFVSTChzZXR0aW5ncy5qc1VybCwgbG9jYXRpb24ub3JpZ2luKS5ocmVmOwogICAgICAgIGNvbnN0IGFic29sdXRlV2FzbVVybCA9IG5ldyBVUkwoc2V0dGluZ3Mud2FzbVVybCwgbG9jYXRpb24ub3JpZ2luKS5ocmVmOwogICAgICAgIHRyeSB7CiAgICAgICAgICBpbXBvcnRTY3JpcHRzKGFic29sdXRlSnNVcmwpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGNvbnNvbGUud2FybigiW1BpeGkuanNdIEZhaWxlZCB0byBsb2FkIEJhc2lzIGluIHdvcmtlciB2aWEgaW1wb3J0U2NyaXB0cy4gRmFsbGluZyBiYWNrIHRvIGV2YWwuIik7CiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFic29sdXRlSnNVcmwpOwogICAgICAgICAgbGV0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7CiAgICAgICAgICB0ZXh0ICs9ICJcbnNlbGYuQkFTSVMgPSBCQVNJUzsiOwogICAgICAgICAgZXZhbCh0ZXh0KTsKICAgICAgICB9CiAgICAgICAgYmFzaXNQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsKICAgICAgICAgIEJBU0lTKHsKICAgICAgICAgICAgbG9jYXRlRmlsZTogKF9maWxlKSA9PiBhYnNvbHV0ZVdhc21VcmwKICAgICAgICAgIH0pLnRoZW4oKG1vZHVsZSkgPT4gewogICAgICAgICAgICBtb2R1bGUuaW5pdGlhbGl6ZUJhc2lzKCk7CiAgICAgICAgICAgIHJlc29sdmUobW9kdWxlLkJhc2lzRmlsZSk7CiAgICAgICAgICB9KTsKICAgICAgICB9KTsKICAgICAgfQogICAgICByZXR1cm4gYmFzaXNQcm9taXNlOwogICAgfQogICAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hCYXNpc1RleHR1cmUodXJsLCBCYXNpc1RleHR1cmUpIHsKICAgICAgY29uc3QgYmFzaXNSZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7CiAgICAgIGlmIChiYXNpc1Jlc3BvbnNlLm9rKSB7CiAgICAgICAgY29uc3QgYmFzaXNBcnJheUJ1ZmZlciA9IGF3YWl0IGJhc2lzUmVzcG9uc2UuYXJyYXlCdWZmZXIoKTsKICAgICAgICByZXR1cm4gbmV3IEJhc2lzVGV4dHVyZShuZXcgVWludDhBcnJheShiYXNpc0FycmF5QnVmZmVyKSk7CiAgICAgIH0KICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBCYXNpcyB0ZXh0dXJlOiAke3VybH1gKTsKICAgIH0KICAgIGNvbnN0IHByZWZlcnJlZFRyYW5zY29kZWRGb3JtYXQgPSBbCiAgICAgICJldGMyLXJnYmE4dW5vcm0iLAogICAgICAiYmM3LXJnYmEtdW5vcm0iLAogICAgICAiYmMzLXJnYmEtdW5vcm0iLAogICAgICAiYXN0Yy00eDQtdW5vcm0iLAogICAgICAicmdiYTh1bm9ybSIKICAgIF07CiAgICBhc3luYyBmdW5jdGlvbiBsb2FkKHVybCkgewogICAgICBjb25zdCBCYXNpc1RleHR1cmUgPSBhd2FpdCBnZXRCYXNpcygpOwogICAgICBjb25zdCBiYXNpc1RleHR1cmUgPSBhd2FpdCBmZXRjaEJhc2lzVGV4dHVyZSh1cmwsIEJhc2lzVGV4dHVyZSk7CiAgICAgIGNvbnN0IGxldmVsQnVmZmVycyA9IGNyZWF0ZUxldmVsQnVmZmVycyhiYXNpc1RleHR1cmUsIGJhc2lzVHJhbnNjb2RlckZvcm1hdCk7CiAgICAgIHJldHVybiB7CiAgICAgICAgd2lkdGg6IGJhc2lzVGV4dHVyZS5nZXRJbWFnZVdpZHRoKDAsIDApLAogICAgICAgIGhlaWdodDogYmFzaXNUZXh0dXJlLmdldEltYWdlSGVpZ2h0KDAsIDApLAogICAgICAgIGZvcm1hdDogYmFzaXNUcmFuc2NvZGVkVGV4dHVyZUZvcm1hdCwKICAgICAgICByZXNvdXJjZTogbGV2ZWxCdWZmZXJzLAogICAgICAgIGFscGhhTW9kZTogIm5vLXByZW11bHRpcGx5LWFscGhhIgogICAgICB9OwogICAgfQogICAgYXN5bmMgZnVuY3Rpb24gaW5pdChqc1VybCwgd2FzbVVybCwgc3VwcG9ydGVkVGV4dHVyZXMpIHsKICAgICAgaWYgKGpzVXJsKQogICAgICAgIHNldHRpbmdzLmpzVXJsID0ganNVcmw7CiAgICAgIGlmICh3YXNtVXJsKQogICAgICAgIHNldHRpbmdzLndhc21VcmwgPSB3YXNtVXJsOwogICAgICBiYXNpc1RyYW5zY29kZWRUZXh0dXJlRm9ybWF0ID0gcHJlZmVycmVkVHJhbnNjb2RlZEZvcm1hdC5maWx0ZXIoKGZvcm1hdCkgPT4gc3VwcG9ydGVkVGV4dHVyZXMuaW5jbHVkZXMoZm9ybWF0KSlbMF07CiAgICAgIGJhc2lzVHJhbnNjb2RlckZvcm1hdCA9IGdwdUZvcm1hdFRvQmFzaXNUcmFuc2NvZGVyRm9ybWF0KGJhc2lzVHJhbnNjb2RlZFRleHR1cmVGb3JtYXQpOwogICAgICBhd2FpdCBnZXRCYXNpcygpOwogICAgfQogICAgY29uc3QgbWVzc2FnZUhhbmRsZXJzID0gewogICAgICBpbml0OiBhc3luYyAoZGF0YSkgPT4gewogICAgICAgIGNvbnN0IHsganNVcmwsIHdhc21VcmwsIHN1cHBvcnRlZFRleHR1cmVzIH0gPSBkYXRhOwogICAgICAgIGF3YWl0IGluaXQoanNVcmwsIHdhc21VcmwsIHN1cHBvcnRlZFRleHR1cmVzKTsKICAgICAgfSwKICAgICAgbG9hZDogYXN5bmMgKGRhdGEpID0+IHsKICAgICAgICB0cnkgewogICAgICAgICAgY29uc3QgdGV4dHVyZU9wdGlvbnMgPSBhd2FpdCBsb2FkKGRhdGEudXJsKTsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHR5cGU6ICJsb2FkIiwKICAgICAgICAgICAgdXJsOiBkYXRhLnVybCwKICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSwKICAgICAgICAgICAgdGV4dHVyZU9wdGlvbnMsCiAgICAgICAgICAgIHRyYW5zZmVyYWJsZXM6IHRleHR1cmVPcHRpb25zLnJlc291cmNlPy5tYXAoKGFycikgPT4gYXJyLmJ1ZmZlcikKICAgICAgICAgIH07CiAgICAgICAgfSBjYXRjaCAoZTIpIHsKICAgICAgICAgIHRocm93IGUyOwogICAgICAgIH0KICAgICAgfQogICAgfTsKICAgIHNlbGYub25tZXNzYWdlID0gYXN5bmMgKG1lc3NhZ2VFdmVudCkgPT4gewogICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZUV2ZW50LmRhdGE7CiAgICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IG1lc3NhZ2VIYW5kbGVyc1ttZXNzYWdlLnR5cGVdKG1lc3NhZ2UpOwogICAgICBpZiAocmVzcG9uc2UyKSB7CiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShyZXNwb25zZTIsIHJlc3BvbnNlMi50cmFuc2ZlcmFibGVzKTsKICAgICAgfQogICAgfTsKCn0pKCk7Cgo=",null,!1);const basisTranscoderUrls={jsUrl:"https://files.pixijs.download/transcoders/basis/basis_transcoder.js",wasmUrl:"https://files.pixijs.download/transcoders/basis/basis_transcoder.wasm"};function setBasisTranscoderPath(Z){Object.assign(basisTranscoderUrls,Z)}let r$6;const i$k={};function c$k(Z){return r$6||(r$6=new WorkerFactory$1,r$6.onmessage=X=>{const{success:K,url:J,textureOptions:Q}=X.data;K||console.warn("Failed to load Basis texture",J),i$k[J](Q)},r$6.postMessage({type:"init",jsUrl:basisTranscoderUrls.jsUrl,wasmUrl:basisTranscoderUrls.wasmUrl,supportedTextures:Z})),r$6}function loadBasisOnWorker(Z,X){const K=c$k(X);return new Promise(J=>{i$k[Z]=J,K.postMessage({type:"load",url:Z})})}const loadBasis={extension:{type:u$v.LoadParser,priority:LoaderParserPriority.High},name:"loadBasis",test(Z){return checkExtension(Z,[".basis"])},async load(Z,X,K){const J=await getSupportedTextureFormats(),Q=await loadBasisOnWorker(Z,J),ee=new CompressedSource(Q);return createTexture(ee,K,Z)},unload(Z){Array.isArray(Z)?Z.forEach(X=>X.destroy(!0)):Z.destroy(!0)}};b$p.add(loadBasis,detectBasis);function createLevelBuffers(Z,X){const K=Z.getNumImages(),J=Z.getNumLevels(0);if(!Z.startTranscoding())throw new Error("startTranscoding failed");const Q=[];for(let ee=0;ee<J;++ee)for(let te=0;te<K;++te){const re=Z.getImageTranscodedSizeInBytes(te,ee,X),ie=new Uint8Array(re);if(!Z.transcodeImage(ie,te,ee,X,1,0))throw new Error("transcodeImage failed");Q.push(ie)}return Q}const n$s={"bc3-rgba-unorm":3,"bc7-rgba-unorm":6,"etc2-rgba8unorm":1,"astc-4x4-unorm":10,rgba8unorm:13,rgba4unorm:16};function gpuFormatToBasisTranscoderFormat(Z){const X=n$s[Z];if(X)return X;throw new Error(`Unsupported transcoderFormat: ${Z}`)}const settings$1={jsUrl:"basis/basis_transcoder.js",wasmUrl:"basis/basis_transcoder.wasm"};let basisTranscoderFormat$1,basisTranscodedTextureFormat$1,basisPromise;async function getBasis(){if(!basisPromise){const absoluteJsUrl=new URL(settings$1.jsUrl,location.origin).href,absoluteWasmUrl=new URL(settings$1.wasmUrl,location.origin).href;try{importScripts(absoluteJsUrl)}catch(e){const response=await fetch(absoluteJsUrl);let text=await response.text();text+=`
self.BASIS = BASIS;`,eval(text)}basisPromise=new Promise(Z=>{BASIS({locateFile:X=>absoluteWasmUrl}).then(X=>{X.initializeBasis(),Z(X.BasisFile)})})}return basisPromise}async function fetchBasisTexture(Z,X){const K=await fetch(Z);if(K.ok){const J=await K.arrayBuffer();return new X(new Uint8Array(J))}throw new Error(`Failed to load Basis texture: ${Z}`)}const preferredTranscodedFormat$1=["etc2-rgba8unorm","bc7-rgba-unorm","bc3-rgba-unorm","astc-4x4-unorm","rgba8unorm"];async function load$1(Z){const X=await getBasis(),K=await fetchBasisTexture(Z,X),J=createLevelBuffers(K,basisTranscoderFormat$1);return{width:K.getImageWidth(0,0),height:K.getImageHeight(0,0),format:basisTranscodedTextureFormat$1,resource:J,alphaMode:"no-premultiply-alpha"}}async function init$1(Z,X,K){Z&&(settings$1.jsUrl=Z),X&&(settings$1.wasmUrl=X),basisTranscodedTextureFormat$1=preferredTranscodedFormat$1.filter(J=>K.includes(J))[0],basisTranscoderFormat$1=gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat$1),await getBasis()}const messageHandlers$1={init:async Z=>{const{jsUrl:X,wasmUrl:K,supportedTextures:J}=Z;await init$1(X,K,J)},load:async Z=>{var X;try{const K=await load$1(Z.url);return{type:"load",url:Z.url,success:!0,textureOptions:K,transferables:(X=K.resource)==null?void 0:X.map(J=>J.buffer)}}catch(K){throw K}}};self.onmessage=async Z=>{const X=Z.data,K=await messageHandlers$1[X.type](X);K&&self.postMessage(K,K.transferables)};const validFormats=["basis","etc2","bc7","bc6h","bc5","bc4","bc3","bc2","bc1","eac","astc"],resolveCompressedTextureUrl={extension:u$v.ResolveParser,test:Z=>checkExtension(Z,[".ktx",".ktx2",".dds"]),parse:Z=>{var X,K;let J;const Q=Z.split(".");if(Q.length>2){const ee=Q[Q.length-2];validFormats.includes(ee),J=ee}else J=Q[Q.length-1];return{resolution:parseFloat((K=(X=Resolver.RETINA_PREFIX.exec(Z))==null?void 0:X[1])!=null?K:"1"),format:J,src:Z}}};let s$u;const detectCompressed={extension:{type:u$v.DetectionParser,priority:2},test:async()=>!!(await isWebGPUSupported()||isWebGLSupported()),add:async Z=>{const X=await getSupportedCompressedTextureFormats();return s$u=f$p(X),[...s$u,...Z]},remove:async Z=>s$u?Z.filter(X=>!(X in s$u)):Z};function f$p(Z){const X=["basis"],K={};return Z.forEach(J=>{const Q=J.split("-")[0];Q&&!K[Q]&&(K[Q]=!0,X.push(Q))}),X.sort((J,Q)=>{const ee=validFormats.indexOf(J),te=validFormats.indexOf(Q);return ee===-1?1:te===-1?-1:ee-te}),X}const G$1=542327876,H$3=131072,L$1=4;function p$w(Z){return Z.charCodeAt(0)+(Z.charCodeAt(1)<<8)+(Z.charCodeAt(2)<<16)+(Z.charCodeAt(3)<<24)}function l$l(Z){return String.fromCharCode(Z&255,Z>>8&255,Z>>16&255,Z>>24&255)}const T$9=p$w("DXT1"),g$j=p$w("DXT3"),O$3=p$w("DXT5"),b$j=31,A$4=0,F$2=1,S$6=2,U$1=3,B$3=4,R=7,y$d=20,_$4=21,w$4=22,k$1=23,I$3=24,P$7=25;function parseDDS(Z,X){const K=new Int32Array(Z,0,b$j);if(K[A$4]!==542327876)throw new Error("Invalid magic number in DDS header");if((K[y$d]===0?1:0)&4)throw new Error("Unsupported format, must contain a FourCC code");const J=K[_$4];let Q=0,ee=0,te;switch(J){case T$9:Q=8,te="bc1-rgba-unorm";break;case g$j:Q=16,te="bc2-rgba-unorm";break;case O$3:Q=16,te="bc3-rgba-unorm";break;default:{const ce=K[w$4],de=K[k$1],he=K[I$3],pe=K[P$7];ce===32&&(de&255&&he&65280&&pe&16711680?(te="rgba8unorm",ee=4):de&16711680&&he&65280&&pe&255&&(te="bgra8unorm",ee=4))}}const re=K[B$3],ie=K[U$1];let ne=K[F$2]+4;if(X.indexOf(te)===-1)throw new Error(`Unsupported texture format: ${l$l(J)} ${te}`);if(Q===0)return{format:te,width:re,height:ie,resource:[new Uint8Array(Z,ne,re*ie*ee)],alphaMode:"no-premultiply-alpha"};let se=1;K[S$6]&131072&&(se=Math.max(1,K[R]));const oe=[];let ae=re,le=ie;for(let ce=0;ce<se;++ce){const de=Q?Math.max(4,ae)/4*Math.max(4,le)/4*Q:ae*le*4,he=new Uint8Array(Z,ne,de);oe.push(he),ne+=de,ae=Math.max(ae>>1,1),le=Math.max(le>>1,1)}return{format:te,width:re,height:ie,resource:oe,alphaMode:"no-premultiply-alpha"}}const loadDDS={extension:{type:u$v.LoadParser,priority:LoaderParserPriority.High},name:"loadDDS",test(Z){return checkExtension(Z,[".dds"])},async load(Z,X,K){const J=await getSupportedTextureFormats(),Q=await(await fetch(Z)).arrayBuffer(),ee=parseDDS(Q,J),te=new CompressedSource(ee);return createTexture(te,K,Z)},unload(Z){Array.isArray(Z)?Z.forEach(X=>X.destroy(!0)):Z.destroy(!0)}};b$p.add(loadDDS,detectCompressed,resolveCompressedTextureUrl);var WorkerFactory=createBase64WorkerFactory("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICAgJ3VzZSBzdHJpY3QnOwoKICAgIGNvbnN0IGNvbnZlcnRlcnMgPSB7CiAgICAgIHJnYjh1bm9ybTogewogICAgICAgIGNvbnZlcnRlZEZvcm1hdDogInJnYmE4dW5vcm0iLAogICAgICAgIGNvbnZlcnRGdW5jdGlvbjogY29udmVydFJHQnRvUkdCQQogICAgICB9LAogICAgICAicmdiOHVub3JtLXNyZ2IiOiB7CiAgICAgICAgY29udmVydGVkRm9ybWF0OiAicmdiYTh1bm9ybS1zcmdiIiwKICAgICAgICBjb252ZXJ0RnVuY3Rpb246IGNvbnZlcnRSR0J0b1JHQkEKICAgICAgfQogICAgfTsKICAgIGZ1bmN0aW9uIGNvbnZlcnRGb3JtYXRJZlJlcXVpcmVkKHRleHR1cmVPcHRpb25zKSB7CiAgICAgIGNvbnN0IGZvcm1hdCA9IHRleHR1cmVPcHRpb25zLmZvcm1hdDsKICAgICAgaWYgKGNvbnZlcnRlcnNbZm9ybWF0XSkgewogICAgICAgIGNvbnN0IGNvbnZlcnRGdW5jdGlvbiA9IGNvbnZlcnRlcnNbZm9ybWF0XS5jb252ZXJ0RnVuY3Rpb247CiAgICAgICAgY29uc3QgbGV2ZWxCdWZmZXJzID0gdGV4dHVyZU9wdGlvbnMucmVzb3VyY2U7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbEJ1ZmZlcnMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGxldmVsQnVmZmVyc1tpXSA9IGNvbnZlcnRGdW5jdGlvbihsZXZlbEJ1ZmZlcnNbaV0pOwogICAgICAgIH0KICAgICAgICB0ZXh0dXJlT3B0aW9ucy5mb3JtYXQgPSBjb252ZXJ0ZXJzW2Zvcm1hdF0uY29udmVydGVkRm9ybWF0OwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBjb252ZXJ0UkdCdG9SR0JBKGxldmVsQnVmZmVyKSB7CiAgICAgIGNvbnN0IHBpeGVsQ291bnQgPSBsZXZlbEJ1ZmZlci5ieXRlTGVuZ3RoIC8gMzsKICAgICAgY29uc3QgbGV2ZWxCdWZmZXJXaXRoQWxwaGEgPSBuZXcgVWludDMyQXJyYXkocGl4ZWxDb3VudCk7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGl4ZWxDb3VudDsgKytpKSB7CiAgICAgICAgbGV2ZWxCdWZmZXJXaXRoQWxwaGFbaV0gPSBsZXZlbEJ1ZmZlcltpICogM10gKyAobGV2ZWxCdWZmZXJbaSAqIDMgKyAxXSA8PCA4KSArIChsZXZlbEJ1ZmZlcltpICogMyArIDJdIDw8IDE2KSArIDQyNzgxOTAwODA7CiAgICAgIH0KICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGxldmVsQnVmZmVyV2l0aEFscGhhLmJ1ZmZlcik7CiAgICB9CgogICAgZnVuY3Rpb24gY3JlYXRlTGV2ZWxCdWZmZXJzRnJvbUtUWChrdHhUZXh0dXJlKSB7CiAgICAgIGNvbnN0IGxldmVsQnVmZmVycyA9IFtdOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGt0eFRleHR1cmUubnVtTGV2ZWxzOyBpKyspIHsKICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBrdHhUZXh0dXJlLmdldEltYWdlRGF0YShpLCAwLCAwKTsKICAgICAgICBjb25zdCBsZXZlbEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGltYWdlRGF0YS5ieXRlTGVuZ3RoKTsKICAgICAgICBsZXZlbEJ1ZmZlci5zZXQoaW1hZ2VEYXRhKTsKICAgICAgICBsZXZlbEJ1ZmZlcnMucHVzaChsZXZlbEJ1ZmZlcik7CiAgICAgIH0KICAgICAgcmV0dXJuIGxldmVsQnVmZmVyczsKICAgIH0KCiAgICBjb25zdCBnbEZvcm1hdFRvR1BVRm9ybWF0TWFwID0gewogICAgICA2NDA4OiAicmdiYTh1bm9ybSIsCiAgICAgIDMyODU2OiAiYmdyYTh1bm9ybSIsCiAgICAgIC8vCiAgICAgIDMyODU3OiAicmdiMTBhMnVub3JtIiwKICAgICAgMzMxODk6ICJkZXB0aDE2dW5vcm0iLAogICAgICAzMzE5MDogImRlcHRoMjRwbHVzIiwKICAgICAgMzMzMjE6ICJyOHVub3JtIiwKICAgICAgMzMzMjM6ICJyZzh1bm9ybSIsCiAgICAgIDMzMzI1OiAicjE2ZmxvYXQiLAogICAgICAzMzMyNjogInIzMmZsb2F0IiwKICAgICAgMzMzMjc6ICJyZzE2ZmxvYXQiLAogICAgICAzMzMyODogInJnMzJmbG9hdCIsCiAgICAgIDMzMzI5OiAicjhzaW50IiwKICAgICAgMzMzMzA6ICJyOHVpbnQiLAogICAgICAzMzMzMTogInIxNnNpbnQiLAogICAgICAzMzMzMjogInIxNnVpbnQiLAogICAgICAzMzMzMzogInIzMnNpbnQiLAogICAgICAzMzMzNDogInIzMnVpbnQiLAogICAgICAzMzMzNTogInJnOHNpbnQiLAogICAgICAzMzMzNjogInJnOHVpbnQiLAogICAgICAzMzMzNzogInJnMTZzaW50IiwKICAgICAgMzMzMzg6ICJyZzE2dWludCIsCiAgICAgIDMzMzM5OiAicmczMnNpbnQiLAogICAgICAzMzM0MDogInJnMzJ1aW50IiwKICAgICAgMzM3Nzg6ICJiYzItcmdiYS11bm9ybSIsCiAgICAgIDMzNzc5OiAiYmMzLXJnYmEtdW5vcm0iLAogICAgICAzNDgzNjogInJnYmEzMmZsb2F0IiwKICAgICAgMzQ4NDI6ICJyZ2JhMTZmbG9hdCIsCiAgICAgIDM1MDU2OiAiZGVwdGgyNHBsdXMtc3RlbmNpbDgiLAogICAgICAzNTg5ODogInJnMTFiMTB1ZmxvYXQiLAogICAgICAzNTkwMTogInJnYjllNXVmbG9hdCIsCiAgICAgIDM1OTA3OiAicmdiYTh1bm9ybS1zcmdiIiwKICAgICAgLy8gYmdyYTh1bm9ybS1zcmdiCiAgICAgIDM2MDEyOiAiZGVwdGgzMmZsb2F0IiwKICAgICAgMzYwMTM6ICJkZXB0aDMyZmxvYXQtc3RlbmNpbDgiLAogICAgICAzNjE2ODogInN0ZW5jaWw4IiwKICAgICAgMzYyMDg6ICJyZ2JhMzJ1aW50IiwKICAgICAgMzYyMTQ6ICJyZ2JhMTZ1aW50IiwKICAgICAgMzYyMjA6ICJyZ2JhOHVpbnQiLAogICAgICAzNjIyNjogInJnYmEzMnNpbnQiLAogICAgICAzNjIzMjogInJnYmExNnNpbnQiLAogICAgICAzNjIzODogInJnYmE4c2ludCIsCiAgICAgIDM2NDkyOiAiYmM3LXJnYmEtdW5vcm0iLAogICAgICAzNjc1NjogInI4c25vcm0iLAogICAgICAzNjc1NzogInJnOHNub3JtIiwKICAgICAgMzY3NTk6ICJyZ2JhOHNub3JtIiwKICAgICAgMzc0OTY6ICJldGMyLXJnYmE4dW5vcm0iLAogICAgICAzNzgwODogImFzdGMtNHg0LXVub3JtIgogICAgfTsKICAgIGZ1bmN0aW9uIGdsRm9ybWF0VG9HUFVGb3JtYXQoZ2xJbnRlcm5hbEZvcm1hdCkgewogICAgICBjb25zdCBmb3JtYXQgPSBnbEZvcm1hdFRvR1BVRm9ybWF0TWFwW2dsSW50ZXJuYWxGb3JtYXRdOwogICAgICBpZiAoZm9ybWF0KSB7CiAgICAgICAgcmV0dXJuIGZvcm1hdDsKICAgICAgfQogICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGdsSW50ZXJuYWxGb3JtYXQ6ICR7Z2xJbnRlcm5hbEZvcm1hdH1gKTsKICAgIH0KCiAgICBjb25zdCB2a0Zvcm1hdFRvR1BVRm9ybWF0TWFwID0gewogICAgICAyMzogInJnYjh1bm9ybSIsCiAgICAgIC8vIFZLX0ZPUk1BVF9SOEc4QjhfVU5PUk0KICAgICAgMzc6ICJyZ2JhOHVub3JtIiwKICAgICAgLy8gVktfRk9STUFUX1I4RzhCOEE4X1VOT1JNCiAgICAgIDQzOiAicmdiYTh1bm9ybS1zcmdiIgogICAgICAvLyBWS19GT1JNQVRfUjhHOEI4QThfU1JHQgogICAgICAvLyBUT0RPIGFkZCBtb3JlIQogICAgfTsKICAgIGZ1bmN0aW9uIHZrRm9ybWF0VG9HUFVGb3JtYXQodmtGb3JtYXQpIHsKICAgICAgY29uc3QgZm9ybWF0ID0gdmtGb3JtYXRUb0dQVUZvcm1hdE1hcFt2a0Zvcm1hdF07CiAgICAgIGlmIChmb3JtYXQpIHsKICAgICAgICByZXR1cm4gZm9ybWF0OwogICAgICB9CiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgVmtGb3JtYXQ6ICR7dmtGb3JtYXR9YCk7CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0VGV4dHVyZUZvcm1hdEZyb21LVFhUZXh0dXJlKGt0eFRleHR1cmUpIHsKICAgICAgaWYgKGt0eFRleHR1cmUuY2xhc3NJZCA9PT0gMikgewogICAgICAgIHJldHVybiB2a0Zvcm1hdFRvR1BVRm9ybWF0KGt0eFRleHR1cmUudmtGb3JtYXQpOwogICAgICB9CiAgICAgIHJldHVybiBnbEZvcm1hdFRvR1BVRm9ybWF0KGt0eFRleHR1cmUuZ2xJbnRlcm5hbGZvcm1hdCk7CiAgICB9CgogICAgY29uc3QgZ3B1Rm9ybWF0VG9CYXNpc1RyYW5zY29kZXJGb3JtYXRNYXAgPSB7CiAgICAgICJiYzMtcmdiYS11bm9ybSI6ICJCQzNfUkdCQSIsCiAgICAgICJiYzctcmdiYS11bm9ybSI6ICJCQzdfTTVfUkdCQSIsCiAgICAgICJldGMyLXJnYmE4dW5vcm0iOiAiRVRDMl9SR0JBIiwKICAgICAgImFzdGMtNHg0LXVub3JtIjogIkFTVENfNHg0X1JHQkEiLAogICAgICAvLyBVbmNvbXByZXNzZWQKICAgICAgcmdiYTh1bm9ybTogIlJHQkEzMiIsCiAgICAgIHJnMTFiMTB1ZmxvYXQ6ICJSMTFGX0cxMUZfQjEwRiIKICAgIH07CiAgICBmdW5jdGlvbiBncHVGb3JtYXRUb0tUWEJhc2lzVHJhbnNjb2RlckZvcm1hdCh0cmFuc2NvZGVyRm9ybWF0KSB7CiAgICAgIGNvbnN0IGZvcm1hdCA9IGdwdUZvcm1hdFRvQmFzaXNUcmFuc2NvZGVyRm9ybWF0TWFwW3RyYW5zY29kZXJGb3JtYXRdOwogICAgICBpZiAoZm9ybWF0KSB7CiAgICAgICAgcmV0dXJuIGZvcm1hdDsKICAgICAgfQogICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRyYW5zY29kZXJGb3JtYXQ6ICR7dHJhbnNjb2RlckZvcm1hdH1gKTsKICAgIH0KCiAgICBjb25zdCBzZXR0aW5ncyA9IHsKICAgICAganNVcmw6ICIiLAogICAgICB3YXNtVXJsOiAiIgogICAgfTsKICAgIGxldCBiYXNpc1RyYW5zY29kZXJGb3JtYXQ7CiAgICBsZXQgYmFzaXNUcmFuc2NvZGVkVGV4dHVyZUZvcm1hdDsKICAgIGxldCBrdHhQcm9taXNlOwogICAgYXN5bmMgZnVuY3Rpb24gZ2V0S1RYKCkgewogICAgICBpZiAoIWt0eFByb21pc2UpIHsKICAgICAgICBjb25zdCBhYnNvbHV0ZUpzVXJsID0gbmV3IFVSTChzZXR0aW5ncy5qc1VybCwgbG9jYXRpb24ub3JpZ2luKS5ocmVmOwogICAgICAgIGNvbnN0IGFic29sdXRlV2FzbVVybCA9IG5ldyBVUkwoc2V0dGluZ3Mud2FzbVVybCwgbG9jYXRpb24ub3JpZ2luKS5ocmVmOwogICAgICAgIHRyeSB7CiAgICAgICAgICBpbXBvcnRTY3JpcHRzKGFic29sdXRlSnNVcmwpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGNvbnNvbGUud2FybigiRmFpbGVkIHRvIGxvYWQgS1RYKDIpIGluIHdvcmtlciB2aWEgaW1wb3J0U2NyaXB0cy4gRmFsbGluZyBiYWNrIHRvIGV2YWwuIik7CiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFic29sdXRlSnNVcmwpOwogICAgICAgICAgbGV0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7CiAgICAgICAgICB0ZXh0ICs9ICJcbnNlbGYuTElCS1RYID0gTElCS1RYOyI7CiAgICAgICAgICBldmFsKHRleHQpOwogICAgICAgIH0KICAgICAgICBrdHhQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsKICAgICAgICAgIExJQktUWCh7CiAgICAgICAgICAgIGxvY2F0ZUZpbGU6IChfZmlsZSkgPT4gYWJzb2x1dGVXYXNtVXJsCiAgICAgICAgICB9KS50aGVuKChsaWJrdHgpID0+IHsKICAgICAgICAgICAgcmVzb2x2ZShsaWJrdHgpOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGt0eFByb21pc2U7CiAgICB9CiAgICBhc3luYyBmdW5jdGlvbiBmZXRjaEtUWFRleHR1cmUodXJsLCBrdHgpIHsKICAgICAgY29uc3Qga3R4MlJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTsKICAgICAgaWYgKGt0eDJSZXNwb25zZS5vaykgewogICAgICAgIGNvbnN0IGt0eDJBcnJheUJ1ZmZlciA9IGF3YWl0IGt0eDJSZXNwb25zZS5hcnJheUJ1ZmZlcigpOwogICAgICAgIHJldHVybiBuZXcga3R4Lmt0eFRleHR1cmUobmV3IFVpbnQ4QXJyYXkoa3R4MkFycmF5QnVmZmVyKSk7CiAgICAgIH0KICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBLVFgoMikgdGV4dHVyZTogJHt1cmx9YCk7CiAgICB9CiAgICBjb25zdCBwcmVmZXJyZWRUcmFuc2NvZGVkRm9ybWF0ID0gWwogICAgICAiZXRjMi1yZ2JhOHVub3JtIiwKICAgICAgImJjNy1yZ2JhLXVub3JtIiwKICAgICAgImJjMy1yZ2JhLXVub3JtIiwKICAgICAgImFzdGMtNHg0LXVub3JtIiwKICAgICAgInJnYmE4dW5vcm0iCiAgICBdOwogICAgYXN5bmMgZnVuY3Rpb24gbG9hZCh1cmwpIHsKICAgICAgY29uc3Qga3R4ID0gYXdhaXQgZ2V0S1RYKCk7CiAgICAgIGNvbnN0IGt0eFRleHR1cmUgPSBhd2FpdCBmZXRjaEtUWFRleHR1cmUodXJsLCBrdHgpOwogICAgICBsZXQgZm9ybWF0OwogICAgICBpZiAoa3R4VGV4dHVyZS5uZWVkc1RyYW5zY29kaW5nKSB7CiAgICAgICAgZm9ybWF0ID0gYmFzaXNUcmFuc2NvZGVkVGV4dHVyZUZvcm1hdDsKICAgICAgICBjb25zdCB0cmFuc2NvZGVGb3JtYXQgPSBrdHguVHJhbnNjb2RlVGFyZ2V0W2Jhc2lzVHJhbnNjb2RlckZvcm1hdF07CiAgICAgICAgY29uc3QgcmVzdWx0ID0ga3R4VGV4dHVyZS50cmFuc2NvZGVCYXNpcyh0cmFuc2NvZGVGb3JtYXQsIDApOwogICAgICAgIGlmIChyZXN1bHQgIT09IGt0eC5FcnJvckNvZGUuU1VDQ0VTUykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJVbmFibGUgdG8gdHJhbnNjb2RlIGJhc2lzIHRleHR1cmUuIik7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIGZvcm1hdCA9IGdldFRleHR1cmVGb3JtYXRGcm9tS1RYVGV4dHVyZShrdHhUZXh0dXJlKTsKICAgICAgfQogICAgICBjb25zdCBsZXZlbEJ1ZmZlcnMgPSBjcmVhdGVMZXZlbEJ1ZmZlcnNGcm9tS1RYKGt0eFRleHR1cmUpOwogICAgICBjb25zdCB0ZXh0dXJlT3B0aW9ucyA9IHsKICAgICAgICB3aWR0aDoga3R4VGV4dHVyZS5iYXNlV2lkdGgsCiAgICAgICAgaGVpZ2h0OiBrdHhUZXh0dXJlLmJhc2VIZWlnaHQsCiAgICAgICAgZm9ybWF0LAogICAgICAgIG1pcExldmVsQ291bnQ6IGt0eFRleHR1cmUubnVtTGV2ZWxzLAogICAgICAgIHJlc291cmNlOiBsZXZlbEJ1ZmZlcnMsCiAgICAgICAgYWxwaGFNb2RlOiAibm8tcHJlbXVsdGlwbHktYWxwaGEiCiAgICAgIH07CiAgICAgIGNvbnZlcnRGb3JtYXRJZlJlcXVpcmVkKHRleHR1cmVPcHRpb25zKTsKICAgICAgcmV0dXJuIHRleHR1cmVPcHRpb25zOwogICAgfQogICAgYXN5bmMgZnVuY3Rpb24gaW5pdChqc1VybCwgd2FzbVVybCwgc3VwcG9ydGVkVGV4dHVyZXMpIHsKICAgICAgaWYgKGpzVXJsKQogICAgICAgIHNldHRpbmdzLmpzVXJsID0ganNVcmw7CiAgICAgIGlmICh3YXNtVXJsKQogICAgICAgIHNldHRpbmdzLndhc21VcmwgPSB3YXNtVXJsOwogICAgICBiYXNpc1RyYW5zY29kZWRUZXh0dXJlRm9ybWF0ID0gcHJlZmVycmVkVHJhbnNjb2RlZEZvcm1hdC5maWx0ZXIoKGZvcm1hdCkgPT4gc3VwcG9ydGVkVGV4dHVyZXMuaW5jbHVkZXMoZm9ybWF0KSlbMF07CiAgICAgIGJhc2lzVHJhbnNjb2RlckZvcm1hdCA9IGdwdUZvcm1hdFRvS1RYQmFzaXNUcmFuc2NvZGVyRm9ybWF0KGJhc2lzVHJhbnNjb2RlZFRleHR1cmVGb3JtYXQpOwogICAgICBhd2FpdCBnZXRLVFgoKTsKICAgIH0KICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVycyA9IHsKICAgICAgaW5pdDogYXN5bmMgKGRhdGEpID0+IHsKICAgICAgICBjb25zdCB7IGpzVXJsLCB3YXNtVXJsLCBzdXBwb3J0ZWRUZXh0dXJlcyB9ID0gZGF0YTsKICAgICAgICBhd2FpdCBpbml0KGpzVXJsLCB3YXNtVXJsLCBzdXBwb3J0ZWRUZXh0dXJlcyk7CiAgICAgIH0sCiAgICAgIGxvYWQ6IGFzeW5jIChkYXRhKSA9PiB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGNvbnN0IHRleHR1cmVPcHRpb25zID0gYXdhaXQgbG9hZChkYXRhLnVybCk7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICB0eXBlOiAibG9hZCIsCiAgICAgICAgICAgIHVybDogZGF0YS51cmwsCiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsCiAgICAgICAgICAgIHRleHR1cmVPcHRpb25zLAogICAgICAgICAgICB0cmFuc2ZlcmFibGVzOiB0ZXh0dXJlT3B0aW9ucy5yZXNvdXJjZT8ubWFwKChhcnIpID0+IGFyci5idWZmZXIpCiAgICAgICAgICB9OwogICAgICAgIH0gY2F0Y2ggKGUyKSB7CiAgICAgICAgICB0aHJvdyBlMjsKICAgICAgICB9CiAgICAgIH0KICAgIH07CiAgICBzZWxmLm9ubWVzc2FnZSA9IGFzeW5jIChtZXNzYWdlRXZlbnQpID0+IHsKICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VFdmVudC5kYXRhOwogICAgICBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBtZXNzYWdlSGFuZGxlcnNbbWVzc2FnZS50eXBlXT8uKG1lc3NhZ2UpOwogICAgICBpZiAocmVzcG9uc2UyKSB7CiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShyZXNwb25zZTIsIHJlc3BvbnNlMi50cmFuc2ZlcmFibGVzKTsKICAgICAgfQogICAgfTsKCn0pKCk7Cgo=",null,!1);const ktxTranscoderUrls={jsUrl:"https://files.pixijs.download/transcoders/ktx/libktx.js",wasmUrl:"https://files.pixijs.download/transcoders/ktx/libktx.wasm"};function setKTXTranscoderPath(Z){Object.assign(ktxTranscoderUrls,Z)}let r$5;const i$j={};function T$8(Z){return r$5||(r$5=new WorkerFactory,r$5.onmessage=X=>{const{success:K,url:J,textureOptions:Q}=X.data;K||console.warn("Failed to load KTX texture",J),i$j[J](Q)},r$5.postMessage({type:"init",jsUrl:ktxTranscoderUrls.jsUrl,wasmUrl:ktxTranscoderUrls.wasmUrl,supportedTextures:Z})),r$5}function loadKTX2onWorker(Z,X){const K=T$8(X);return new Promise(J=>{i$j[Z]=J,K.postMessage({type:"load",url:Z})})}const loadKTX={extension:{type:u$v.LoadParser,priority:LoaderParserPriority.High},name:"loadKTX",test(Z){return checkExtension(Z,[".ktx2",".ktx"])},async load(Z,X,K){const J=await getSupportedTextureFormats(),Q=await loadKTX2onWorker(Z,J),ee=new CompressedSource(Q);return createTexture(ee,K,Z)},unload(Z){Array.isArray(Z)?Z.forEach(X=>X.destroy(!0)):Z.destroy(!0)}};b$p.add(loadKTX),b$p.add(resolveCompressedTextureUrl),b$p.add(detectCompressed);function createLevelBuffersFromKTX(Z){const X=[];for(let K=0;K<Z.numLevels;K++){const J=Z.getImageData(K,0,0),Q=new Uint8Array(J.byteLength);Q.set(J),X.push(Q)}return X}const n$r={6408:"rgba8unorm",32856:"bgra8unorm",32857:"rgb10a2unorm",33189:"depth16unorm",33190:"depth24plus",33321:"r8unorm",33323:"rg8unorm",33325:"r16float",33326:"r32float",33327:"rg16float",33328:"rg32float",33329:"r8sint",33330:"r8uint",33331:"r16sint",33332:"r16uint",33333:"r32sint",33334:"r32uint",33335:"rg8sint",33336:"rg8uint",33337:"rg16sint",33338:"rg16uint",33339:"rg32sint",33340:"rg32uint",33778:"bc2-rgba-unorm",33779:"bc3-rgba-unorm",34836:"rgba32float",34842:"rgba16float",35056:"depth24plus-stencil8",35898:"rg11b10ufloat",35901:"rgb9e5ufloat",35907:"rgba8unorm-srgb",36012:"depth32float",36013:"depth32float-stencil8",36168:"stencil8",36208:"rgba32uint",36214:"rgba16uint",36220:"rgba8uint",36226:"rgba32sint",36232:"rgba16sint",36238:"rgba8sint",36492:"bc7-rgba-unorm",36756:"r8snorm",36757:"rg8snorm",36759:"rgba8snorm",37496:"etc2-rgba8unorm",37808:"astc-4x4-unorm"};function glFormatToGPUFormat(Z){const X=n$r[Z];if(X)return X;throw new Error(`Unsupported glInternalFormat: ${Z}`)}const t$8={23:"rgb8unorm",37:"rgba8unorm",43:"rgba8unorm-srgb"};function vkFormatToGPUFormat(Z){const X=t$8[Z];if(X)return X;throw new Error(`Unsupported VkFormat: ${Z}`)}function getTextureFormatFromKTXTexture(Z){return Z.classId===2?vkFormatToGPUFormat(Z.vkFormat):glFormatToGPUFormat(Z.glInternalformat)}const t$7={"bc3-rgba-unorm":"BC3_RGBA","bc7-rgba-unorm":"BC7_M5_RGBA","etc2-rgba8unorm":"ETC2_RGBA","astc-4x4-unorm":"ASTC_4x4_RGBA",rgba8unorm:"RGBA32",rg11b10ufloat:"R11F_G11F_B10F"};function gpuFormatToKTXBasisTranscoderFormat(Z){const X=t$7[Z];if(X)return X;throw new Error(`Unsupported transcoderFormat: ${Z}`)}const c$j={rgb8unorm:{convertedFormat:"rgba8unorm",convertFunction:i$i},"rgb8unorm-srgb":{convertedFormat:"rgba8unorm-srgb",convertFunction:i$i}};function convertFormatIfRequired(Z){const X=Z.format;if(c$j[X]){const K=c$j[X].convertFunction,J=Z.resource;for(let Q=0;Q<J.length;Q++)J[Q]=K(J[Q]);Z.format=c$j[X].convertedFormat}}function i$i(Z){const X=Z.byteLength/3,K=new Uint32Array(X);for(let J=0;J<X;++J)K[J]=Z[J*3]+(Z[J*3+1]<<8)+(Z[J*3+2]<<16)+4278190080;return new Uint8Array(K.buffer)}const settings={jsUrl:"",wasmUrl:""};let basisTranscoderFormat,basisTranscodedTextureFormat,ktxPromise;async function getKTX(){if(!ktxPromise){const absoluteJsUrl=new URL(settings.jsUrl,location.origin).href,absoluteWasmUrl=new URL(settings.wasmUrl,location.origin).href;try{importScripts(absoluteJsUrl)}catch(e){const response=await fetch(absoluteJsUrl);let text=await response.text();text+=`
self.LIBKTX = LIBKTX;`,eval(text)}ktxPromise=new Promise(Z=>{LIBKTX({locateFile:X=>absoluteWasmUrl}).then(X=>{Z(X)})})}return ktxPromise}async function fetchKTXTexture(Z,X){const K=await fetch(Z);if(K.ok){const J=await K.arrayBuffer();return new X.ktxTexture(new Uint8Array(J))}throw new Error(`Failed to load KTX(2) texture: ${Z}`)}const preferredTranscodedFormat=["etc2-rgba8unorm","bc7-rgba-unorm","bc3-rgba-unorm","astc-4x4-unorm","rgba8unorm"];async function load(Z){const X=await getKTX(),K=await fetchKTXTexture(Z,X);let J;if(K.needsTranscoding){J=basisTranscodedTextureFormat;const te=X.TranscodeTarget[basisTranscoderFormat];if(K.transcodeBasis(te,0)!==X.ErrorCode.SUCCESS)throw new Error("Unable to transcode basis texture.")}else J=getTextureFormatFromKTXTexture(K);const Q=createLevelBuffersFromKTX(K),ee={width:K.baseWidth,height:K.baseHeight,format:J,mipLevelCount:K.numLevels,resource:Q,alphaMode:"no-premultiply-alpha"};return convertFormatIfRequired(ee),ee}async function init(Z,X,K){Z&&(settings.jsUrl=Z),X&&(settings.wasmUrl=X),basisTranscodedTextureFormat=preferredTranscodedFormat.filter(J=>K.includes(J))[0],basisTranscoderFormat=gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat),await getKTX()}const messageHandlers={init:async Z=>{const{jsUrl:X,wasmUrl:K,supportedTextures:J}=Z;await init(X,K,J)},load:async Z=>{var X;try{const K=await load(Z.url);return{type:"load",url:Z.url,success:!0,textureOptions:K,transferables:(X=K.resource)==null?void 0:X.map(J=>J.buffer)}}catch(K){throw K}}};self.onmessage=async Z=>{var X;const K=Z.data,J=await((X=messageHandlers[K.type])==null?void 0:X.call(messageHandlers,K));J&&self.postMessage(J,J.transferables)};class s$t{constructor(){this.interactionFrequency=10,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}init(X){this.removeTickerListener(),this.events=X,this.interactionFrequency=10,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}get pauseUpdate(){return this._pauseUpdate}set pauseUpdate(X){this._pauseUpdate=X}addTickerListener(){this._tickerAdded||!this.domElement||(Ticker.system.add(this._tickerUpdate,this,UPDATE_PRIORITY.INTERACTION),this._tickerAdded=!0)}removeTickerListener(){this._tickerAdded&&(Ticker.system.remove(this._tickerUpdate,this),this._tickerAdded=!1)}pointerMoved(){this._didMove=!0}_update(){if(!this.domElement||this._pauseUpdate)return;if(this._didMove){this._didMove=!1;return}const X=this.events._rootPointerEvent;this.events.supportsTouchEvents&&X.pointerType==="touch"||globalThis.document.dispatchEvent(new PointerEvent("pointermove",{clientX:X.clientX,clientY:X.clientY}))}_tickerUpdate(X){this._deltaTime+=X.deltaTime,!(this._deltaTime<this.interactionFrequency)&&(this._deltaTime=0,this._update())}}const EventsTicker=new s$t;class FederatedMouseEvent extends FederatedEvent{constructor(){super(...arguments),this.client=new Point,this.movement=new Point,this.offset=new Point,this.global=new Point,this.screen=new Point}get clientX(){return this.client.x}get clientY(){return this.client.y}get x(){return this.clientX}get y(){return this.clientY}get movementX(){return this.movement.x}get movementY(){return this.movement.y}get offsetX(){return this.offset.x}get offsetY(){return this.offset.y}get globalX(){return this.global.x}get globalY(){return this.global.y}get screenX(){return this.screen.x}get screenY(){return this.screen.y}getLocalPosition(X,K,J){return X.worldTransform.applyInverse(J||this.global,K)}getModifierState(X){return"getModifierState"in this.nativeEvent&&this.nativeEvent.getModifierState(X)}initMouseEvent(X,K,J,Q,ee,te,re,ie,ne,se,oe,ae,le,ce,de){throw new Error("Method not implemented.")}}class FederatedPointerEvent extends FederatedMouseEvent{constructor(){super(...arguments),this.width=0,this.height=0,this.isPrimary=!1}getCoalescedEvents(){return this.type==="pointermove"||this.type==="mousemove"||this.type==="touchmove"?[this]:[]}getPredictedEvents(){throw new Error("getPredictedEvents is not supported!")}}class FederatedWheelEvent extends FederatedMouseEvent{constructor(){super(...arguments),this.DOM_DELTA_PIXEL=0,this.DOM_DELTA_LINE=1,this.DOM_DELTA_PAGE=2}}FederatedWheelEvent.DOM_DELTA_PIXEL=0,FederatedWheelEvent.DOM_DELTA_LINE=1,FederatedWheelEvent.DOM_DELTA_PAGE=2;const b$i=2048,F$1=new Point,g$i=new Point;class EventBoundary{constructor(X){this.dispatch=new eventemitter3,this.moveOnAll=!1,this.enableGlobalMoveEvents=!0,this.mappingState={trackingData:{}},this.eventPool=new Map,this._allInteractiveElements=[],this._hitElements=[],this._isPointerMoveEvent=!1,this.rootTarget=X,this.hitPruneFn=this.hitPruneFn.bind(this),this.hitTestFn=this.hitTestFn.bind(this),this.mapPointerDown=this.mapPointerDown.bind(this),this.mapPointerMove=this.mapPointerMove.bind(this),this.mapPointerOut=this.mapPointerOut.bind(this),this.mapPointerOver=this.mapPointerOver.bind(this),this.mapPointerUp=this.mapPointerUp.bind(this),this.mapPointerUpOutside=this.mapPointerUpOutside.bind(this),this.mapWheel=this.mapWheel.bind(this),this.mappingTable={},this.addEventMapping("pointerdown",this.mapPointerDown),this.addEventMapping("pointermove",this.mapPointerMove),this.addEventMapping("pointerout",this.mapPointerOut),this.addEventMapping("pointerleave",this.mapPointerOut),this.addEventMapping("pointerover",this.mapPointerOver),this.addEventMapping("pointerup",this.mapPointerUp),this.addEventMapping("pointerupoutside",this.mapPointerUpOutside),this.addEventMapping("wheel",this.mapWheel)}addEventMapping(X,K){this.mappingTable[X]||(this.mappingTable[X]=[]),this.mappingTable[X].push({fn:K,priority:0}),this.mappingTable[X].sort((J,Q)=>J.priority-Q.priority)}dispatchEvent(X,K){X.propagationStopped=!1,X.propagationImmediatelyStopped=!1,this.propagate(X,K),this.dispatch.emit(K||X.type,X)}mapEvent(X){if(!this.rootTarget)return;const K=this.mappingTable[X.type];if(K)for(let J=0,Q=K.length;J<Q;J++)K[J].fn(X)}hitTest(X,K){EventsTicker.pauseUpdate=!0;const J=this._isPointerMoveEvent&&this.enableGlobalMoveEvents?"hitTestMoveRecursive":"hitTestRecursive",Q=this[J](this.rootTarget,this.rootTarget.eventMode,F$1.set(X,K),this.hitTestFn,this.hitPruneFn);return Q&&Q[0]}propagate(X,K){if(!X.target)return;const J=X.composedPath();X.eventPhase=X.CAPTURING_PHASE;for(let Q=0,ee=J.length-1;Q<ee;Q++)if(X.currentTarget=J[Q],this.notifyTarget(X,K),X.propagationStopped||X.propagationImmediatelyStopped)return;if(X.eventPhase=X.AT_TARGET,X.currentTarget=X.target,this.notifyTarget(X,K),!(X.propagationStopped||X.propagationImmediatelyStopped)){X.eventPhase=X.BUBBLING_PHASE;for(let Q=J.length-2;Q>=0;Q--)if(X.currentTarget=J[Q],this.notifyTarget(X,K),X.propagationStopped||X.propagationImmediatelyStopped)return}}all(X,K,J=this._allInteractiveElements){if(J.length===0)return;X.eventPhase=X.BUBBLING_PHASE;const Q=Array.isArray(K)?K:[K];for(let ee=J.length-1;ee>=0;ee--)Q.forEach(te=>{X.currentTarget=J[ee],this.notifyTarget(X,te)})}propagationPath(X){const K=[X];for(let J=0;J<b$i&&X!==this.rootTarget&&X.parent;J++){if(!X.parent)throw new Error("Cannot find propagation path to disconnected target");K.push(X.parent),X=X.parent}return K.reverse(),K}hitTestMoveRecursive(X,K,J,Q,ee,te=!1){let re=!1;if(this._interactivePrune(X))return null;if((X.eventMode==="dynamic"||K==="dynamic")&&(EventsTicker.pauseUpdate=!1),X.interactiveChildren&&X.children){const se=X.children;for(let oe=se.length-1;oe>=0;oe--){const ae=se[oe],le=this.hitTestMoveRecursive(ae,this._isInteractive(K)?K:ae.eventMode,J,Q,ee,te||ee(X,J));if(le){if(le.length>0&&!le[le.length-1].parent)continue;const ce=X.isInteractive();(le.length>0||ce)&&(ce&&this._allInteractiveElements.push(X),le.push(X)),this._hitElements.length===0&&(this._hitElements=le),re=!0}}}const ie=this._isInteractive(K),ne=X.isInteractive();return ne&&ne&&this._allInteractiveElements.push(X),te||this._hitElements.length>0?null:re?this._hitElements:ie&&!ee(X,J)&&Q(X,J)?ne?[X]:[]:null}hitTestRecursive(X,K,J,Q,ee){if(this._interactivePrune(X)||ee(X,J))return null;if((X.eventMode==="dynamic"||K==="dynamic")&&(EventsTicker.pauseUpdate=!1),X.interactiveChildren&&X.children){const ie=X.children,ne=J;for(let se=ie.length-1;se>=0;se--){const oe=ie[se],ae=this.hitTestRecursive(oe,this._isInteractive(K)?K:oe.eventMode,ne,Q,ee);if(ae){if(ae.length>0&&!ae[ae.length-1].parent)continue;const le=X.isInteractive();return(ae.length>0||le)&&ae.push(X),ae}}}const te=this._isInteractive(K),re=X.isInteractive();return te&&Q(X,J)?re?[X]:[]:null}_isInteractive(X){return X==="static"||X==="dynamic"}_interactivePrune(X){return!X||!X.visible||!X.renderable||X.eventMode==="none"||X.eventMode==="passive"&&!X.interactiveChildren}hitPruneFn(X,K){if(X.hitArea&&(X.worldTransform.applyInverse(K,g$i),!X.hitArea.contains(g$i.x,g$i.y)))return!0;if(X.effects&&X.effects.length)for(let J=0;J<X.effects.length;J++){const Q=X.effects[J];if(Q.containsPoint&&!Q.containsPoint(K,this.hitTestFn))return!0}return!1}hitTestFn(X,K){var J;return X.hitArea?!0:(J=X.view)!=null&&J.containsPoint?(X.worldTransform.applyInverse(K,g$i),X.view.containsPoint(g$i)):!1}notifyTarget(X,K){var J,Q;K=K!=null?K:X.type;const ee=`on${K}`;(Q=(J=X.currentTarget)[ee])==null||Q.call(J,X);const te=X.eventPhase===X.CAPTURING_PHASE||X.eventPhase===X.AT_TARGET?`${K}capture`:K;this._notifyListeners(X,te),X.eventPhase===X.AT_TARGET&&this._notifyListeners(X,K)}mapPointerDown(X){if(!(X instanceof FederatedPointerEvent))return;const K=this.createPointerEvent(X);if(this.dispatchEvent(K,"pointerdown"),K.pointerType==="touch")this.dispatchEvent(K,"touchstart");else if(K.pointerType==="mouse"||K.pointerType==="pen"){const Q=K.button===2;this.dispatchEvent(K,Q?"rightdown":"mousedown")}const J=this.trackingData(X.pointerId);J.pressTargetsByButton[X.button]=K.composedPath(),this.freeEvent(K)}mapPointerMove(X){var K,J,Q;if(!(X instanceof FederatedPointerEvent))return;this._allInteractiveElements.length=0,this._hitElements.length=0,this._isPointerMoveEvent=!0;const ee=this.createPointerEvent(X);this._isPointerMoveEvent=!1;const te=ee.pointerType==="mouse"||ee.pointerType==="pen",re=this.trackingData(X.pointerId),ie=this.findMountedTarget(re.overTargets);if(((K=re.overTargets)==null?void 0:K.length)>0&&ie!==ee.target){const oe=X.type==="mousemove"?"mouseout":"pointerout",ae=this.createPointerEvent(X,oe,ie);if(this.dispatchEvent(ae,"pointerout"),te&&this.dispatchEvent(ae,"mouseout"),!ee.composedPath().includes(ie)){const le=this.createPointerEvent(X,"pointerleave",ie);for(le.eventPhase=le.AT_TARGET;le.target&&!ee.composedPath().includes(le.target);)le.currentTarget=le.target,this.notifyTarget(le),te&&this.notifyTarget(le,"mouseleave"),le.target=le.target.parent;this.freeEvent(le)}this.freeEvent(ae)}if(ie!==ee.target){const oe=X.type==="mousemove"?"mouseover":"pointerover",ae=this.clonePointerEvent(ee,oe);this.dispatchEvent(ae,"pointerover"),te&&this.dispatchEvent(ae,"mouseover");let le=ie==null?void 0:ie.parent;for(;le&&le!==this.rootTarget.parent&&le!==ee.target;)le=le.parent;if(!le||le===this.rootTarget.parent){const ce=this.clonePointerEvent(ee,"pointerenter");for(ce.eventPhase=ce.AT_TARGET;ce.target&&ce.target!==ie&&ce.target!==this.rootTarget.parent;)ce.currentTarget=ce.target,this.notifyTarget(ce),te&&this.notifyTarget(ce,"mouseenter"),ce.target=ce.target.parent;this.freeEvent(ce)}this.freeEvent(ae)}const ne=[],se=(J=this.enableGlobalMoveEvents)!=null?J:!0;this.moveOnAll?ne.push("pointermove"):this.dispatchEvent(ee,"pointermove"),se&&ne.push("globalpointermove"),ee.pointerType==="touch"&&(this.moveOnAll?ne.splice(1,0,"touchmove"):this.dispatchEvent(ee,"touchmove"),se&&ne.push("globaltouchmove")),te&&(this.moveOnAll?ne.splice(1,0,"mousemove"):this.dispatchEvent(ee,"mousemove"),se&&ne.push("globalmousemove"),this.cursor=(Q=ee.target)==null?void 0:Q.cursor),ne.length>0&&this.all(ee,ne),this._allInteractiveElements.length=0,this._hitElements.length=0,re.overTargets=ee.composedPath(),this.freeEvent(ee)}mapPointerOver(X){var K;if(!(X instanceof FederatedPointerEvent))return;const J=this.trackingData(X.pointerId),Q=this.createPointerEvent(X),ee=Q.pointerType==="mouse"||Q.pointerType==="pen";this.dispatchEvent(Q,"pointerover"),ee&&this.dispatchEvent(Q,"mouseover"),Q.pointerType==="mouse"&&(this.cursor=(K=Q.target)==null?void 0:K.cursor);const te=this.clonePointerEvent(Q,"pointerenter");for(te.eventPhase=te.AT_TARGET;te.target&&te.target!==this.rootTarget.parent;)te.currentTarget=te.target,this.notifyTarget(te),ee&&this.notifyTarget(te,"mouseenter"),te.target=te.target.parent;J.overTargets=Q.composedPath(),this.freeEvent(Q),this.freeEvent(te)}mapPointerOut(X){if(!(X instanceof FederatedPointerEvent))return;const K=this.trackingData(X.pointerId);if(K.overTargets){const J=X.pointerType==="mouse"||X.pointerType==="pen",Q=this.findMountedTarget(K.overTargets),ee=this.createPointerEvent(X,"pointerout",Q);this.dispatchEvent(ee),J&&this.dispatchEvent(ee,"mouseout");const te=this.createPointerEvent(X,"pointerleave",Q);for(te.eventPhase=te.AT_TARGET;te.target&&te.target!==this.rootTarget.parent;)te.currentTarget=te.target,this.notifyTarget(te),J&&this.notifyTarget(te,"mouseleave"),te.target=te.target.parent;K.overTargets=null,this.freeEvent(ee),this.freeEvent(te)}this.cursor=null}mapPointerUp(X){if(!(X instanceof FederatedPointerEvent))return;const K=performance.now(),J=this.createPointerEvent(X);if(this.dispatchEvent(J,"pointerup"),J.pointerType==="touch")this.dispatchEvent(J,"touchend");else if(J.pointerType==="mouse"||J.pointerType==="pen"){const re=J.button===2;this.dispatchEvent(J,re?"rightup":"mouseup")}const Q=this.trackingData(X.pointerId),ee=this.findMountedTarget(Q.pressTargetsByButton[X.button]);let te=ee;if(ee&&!J.composedPath().includes(ee)){let re=ee;for(;re&&!J.composedPath().includes(re);){if(J.currentTarget=re,this.notifyTarget(J,"pointerupoutside"),J.pointerType==="touch")this.notifyTarget(J,"touchendoutside");else if(J.pointerType==="mouse"||J.pointerType==="pen"){const ie=J.button===2;this.notifyTarget(J,ie?"rightupoutside":"mouseupoutside")}re=re.parent}delete Q.pressTargetsByButton[X.button],te=re}if(te){const re=this.clonePointerEvent(J,"click");re.target=te,re.path=null,Q.clicksByButton[X.button]||(Q.clicksByButton[X.button]={clickCount:0,target:re.target,timeStamp:K});const ie=Q.clicksByButton[X.button];if(ie.target===re.target&&K-ie.timeStamp<200?++ie.clickCount:ie.clickCount=1,ie.target=re.target,ie.timeStamp=K,re.detail=ie.clickCount,re.pointerType==="mouse"){const ne=re.button===2;this.dispatchEvent(re,ne?"rightclick":"click")}else re.pointerType==="touch"&&this.dispatchEvent(re,"tap");this.dispatchEvent(re,"pointertap"),this.freeEvent(re)}this.freeEvent(J)}mapPointerUpOutside(X){if(!(X instanceof FederatedPointerEvent))return;const K=this.trackingData(X.pointerId),J=this.findMountedTarget(K.pressTargetsByButton[X.button]),Q=this.createPointerEvent(X);if(J){let ee=J;for(;ee;)Q.currentTarget=ee,this.notifyTarget(Q,"pointerupoutside"),Q.pointerType==="touch"?this.notifyTarget(Q,"touchendoutside"):(Q.pointerType==="mouse"||Q.pointerType==="pen")&&this.notifyTarget(Q,Q.button===2?"rightupoutside":"mouseupoutside"),ee=ee.parent;delete K.pressTargetsByButton[X.button]}this.freeEvent(Q)}mapWheel(X){if(!(X instanceof FederatedWheelEvent))return;const K=this.createWheelEvent(X);this.dispatchEvent(K),this.freeEvent(K)}findMountedTarget(X){if(!X)return null;let K=X[0];for(let J=1;J<X.length&&X[J].parent===K;J++)K=X[J];return K}createPointerEvent(X,K,J){var Q;const ee=this.allocateEvent(FederatedPointerEvent);return this.copyPointerData(X,ee),this.copyMouseData(X,ee),this.copyData(X,ee),ee.nativeEvent=X.nativeEvent,ee.originalEvent=X,ee.target=(Q=J!=null?J:this.hitTest(ee.global.x,ee.global.y))!=null?Q:this._hitElements[0],typeof K=="string"&&(ee.type=K),ee}createWheelEvent(X){const K=this.allocateEvent(FederatedWheelEvent);return this.copyWheelData(X,K),this.copyMouseData(X,K),this.copyData(X,K),K.nativeEvent=X.nativeEvent,K.originalEvent=X,K.target=this.hitTest(K.global.x,K.global.y),K}clonePointerEvent(X,K){const J=this.allocateEvent(FederatedPointerEvent);return J.nativeEvent=X.nativeEvent,J.originalEvent=X.originalEvent,this.copyPointerData(X,J),this.copyMouseData(X,J),this.copyData(X,J),J.target=X.target,J.path=X.composedPath().slice(),J.type=K!=null?K:J.type,J}copyWheelData(X,K){K.deltaMode=X.deltaMode,K.deltaX=X.deltaX,K.deltaY=X.deltaY,K.deltaZ=X.deltaZ}copyPointerData(X,K){X instanceof FederatedPointerEvent&&K instanceof FederatedPointerEvent&&(K.pointerId=X.pointerId,K.width=X.width,K.height=X.height,K.isPrimary=X.isPrimary,K.pointerType=X.pointerType,K.pressure=X.pressure,K.tangentialPressure=X.tangentialPressure,K.tiltX=X.tiltX,K.tiltY=X.tiltY,K.twist=X.twist)}copyMouseData(X,K){X instanceof FederatedMouseEvent&&K instanceof FederatedMouseEvent&&(K.altKey=X.altKey,K.button=X.button,K.buttons=X.buttons,K.client.copyFrom(X.client),K.ctrlKey=X.ctrlKey,K.metaKey=X.metaKey,K.movement.copyFrom(X.movement),K.screen.copyFrom(X.screen),K.shiftKey=X.shiftKey,K.global.copyFrom(X.global))}copyData(X,K){K.isTrusted=X.isTrusted,K.srcElement=X.srcElement,K.timeStamp=performance.now(),K.type=X.type,K.detail=X.detail,K.view=X.view,K.which=X.which,K.layer.copyFrom(X.layer),K.page.copyFrom(X.page)}trackingData(X){return this.mappingState.trackingData[X]||(this.mappingState.trackingData[X]={pressTargetsByButton:{},clicksByButton:{},overTarget:null}),this.mappingState.trackingData[X]}allocateEvent(X){this.eventPool.has(X)||this.eventPool.set(X,[]);const K=this.eventPool.get(X).pop()||new X(this);return K.eventPhase=K.NONE,K.currentTarget=null,K.path=null,K.target=null,K}freeEvent(X){if(X.manager!==this)throw new Error("It is illegal to free an event not managed by this EventBoundary!");const K=X.constructor;this.eventPool.has(K)||this.eventPool.set(K,[]),this.eventPool.get(K).push(X)}_notifyListeners(X,K){const J=X.currentTarget._events[K];if(J&&X.currentTarget.isInteractive())if("fn"in J)J.once&&X.currentTarget.removeListener(K,J.fn,void 0,!0),J.fn.call(J.context,X);else for(let Q=0,ee=J.length;Q<ee&&!X.propagationImmediatelyStopped;Q++)J[Q].once&&X.currentTarget.removeListener(K,J[Q].fn,void 0,!0),J[Q].fn.call(J[Q].context,X)}}var c$i=Object.defineProperty,h$n=Object.getOwnPropertySymbols,f$o=Object.prototype.hasOwnProperty,y$c=Object.prototype.propertyIsEnumerable,m$o=(Z,X,K)=>X in Z?c$i(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,p$v=(Z,X)=>{for(var K in X||(X={}))f$o.call(X,K)&&m$o(Z,K,X[K]);if(h$n)for(var K of h$n(X))y$c.call(X,K)&&m$o(Z,K,X[K]);return Z};const b$h=1,g$h={touchstart:"pointerdown",touchend:"pointerup",touchendoutside:"pointerupoutside",touchmove:"pointermove",touchcancel:"pointercancel"},u$k=class{constructor(Z){this.supportsTouchEvents="ontouchstart"in globalThis,this.supportsPointerEvents=!!globalThis.PointerEvent,this.domElement=null,this.resolution=1,this.renderer=Z,this.rootBoundary=new EventBoundary(null),EventsTicker.init(this),this.autoPreventDefault=!0,this._eventsAdded=!1,this._rootPointerEvent=new FederatedPointerEvent(null),this._rootWheelEvent=new FederatedWheelEvent(null),this.cursorStyles={default:"inherit",pointer:"pointer"},this.features=new Proxy(p$v({},u$k.defaultEventFeatures),{set:(X,K,J)=>(K==="globalMove"&&(this.rootBoundary.enableGlobalMoveEvents=J),X[K]=J,!0)}),this._onPointerDown=this._onPointerDown.bind(this),this._onPointerMove=this._onPointerMove.bind(this),this._onPointerUp=this._onPointerUp.bind(this),this._onPointerOverOut=this._onPointerOverOut.bind(this),this.onWheel=this.onWheel.bind(this)}static get defaultEventMode(){return this._defaultEventMode}init(Z){var X,K;const{canvas:J,resolution:Q}=this.renderer;this.setTargetElement(J),this.resolution=Q,u$k._defaultEventMode=(X=Z.eventMode)!=null?X:"passive",Object.assign(this.features,(K=Z.eventFeatures)!=null?K:{}),this.rootBoundary.enableGlobalMoveEvents=this.features.globalMove}resolutionChange(Z){this.resolution=Z}destroy(){this.setTargetElement(null),this.renderer=null,this._currentCursor=null}setCursor(Z){Z=Z||"default";let X=!0;if(globalThis.OffscreenCanvas&&this.domElement instanceof OffscreenCanvas&&(X=!1),this._currentCursor===Z)return;this._currentCursor=Z;const K=this.cursorStyles[Z];if(K)switch(typeof K){case"string":X&&(this.domElement.style.cursor=K);break;case"function":K(Z);break;case"object":X&&Object.assign(this.domElement.style,K);break}else X&&typeof Z=="string"&&!Object.prototype.hasOwnProperty.call(this.cursorStyles,Z)&&(this.domElement.style.cursor=Z)}get pointer(){return this._rootPointerEvent}_onPointerDown(Z){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;const X=this._normalizeToPointerData(Z);this.autoPreventDefault&&X[0].isNormalized&&(Z.cancelable||!("cancelable"in Z))&&Z.preventDefault();for(let K=0,J=X.length;K<J;K++){const Q=X[K],ee=this._bootstrapEvent(this._rootPointerEvent,Q);this.rootBoundary.mapEvent(ee)}this.setCursor(this.rootBoundary.cursor)}_onPointerMove(Z){if(!this.features.move)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered,EventsTicker.pointerMoved();const X=this._normalizeToPointerData(Z);for(let K=0,J=X.length;K<J;K++){const Q=this._bootstrapEvent(this._rootPointerEvent,X[K]);this.rootBoundary.mapEvent(Q)}this.setCursor(this.rootBoundary.cursor)}_onPointerUp(Z){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;let X=Z.target;Z.composedPath&&Z.composedPath().length>0&&(X=Z.composedPath()[0]);const K=X!==this.domElement?"outside":"",J=this._normalizeToPointerData(Z);for(let Q=0,ee=J.length;Q<ee;Q++){const te=this._bootstrapEvent(this._rootPointerEvent,J[Q]);te.type+=K,this.rootBoundary.mapEvent(te)}this.setCursor(this.rootBoundary.cursor)}_onPointerOverOut(Z){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;const X=this._normalizeToPointerData(Z);for(let K=0,J=X.length;K<J;K++){const Q=this._bootstrapEvent(this._rootPointerEvent,X[K]);this.rootBoundary.mapEvent(Q)}this.setCursor(this.rootBoundary.cursor)}onWheel(Z){if(!this.features.wheel)return;const X=this.normalizeWheelEvent(Z);this.rootBoundary.rootTarget=this.renderer.lastObjectRendered,this.rootBoundary.mapEvent(X)}setTargetElement(Z){this._removeEvents(),this.domElement=Z,EventsTicker.domElement=Z,this._addEvents()}_addEvents(){if(this._eventsAdded||!this.domElement)return;EventsTicker.addTickerListener();const Z=this.domElement.style;Z&&(globalThis.navigator.msPointerEnabled?(Z.msContentZooming="none",Z.msTouchAction="none"):this.supportsPointerEvents&&(Z.touchAction="none")),this.supportsPointerEvents?(globalThis.document.addEventListener("pointermove",this._onPointerMove,!0),this.domElement.addEventListener("pointerdown",this._onPointerDown,!0),this.domElement.addEventListener("pointerleave",this._onPointerOverOut,!0),this.domElement.addEventListener("pointerover",this._onPointerOverOut,!0),globalThis.addEventListener("pointerup",this._onPointerUp,!0)):(globalThis.document.addEventListener("mousemove",this._onPointerMove,!0),this.domElement.addEventListener("mousedown",this._onPointerDown,!0),this.domElement.addEventListener("mouseout",this._onPointerOverOut,!0),this.domElement.addEventListener("mouseover",this._onPointerOverOut,!0),globalThis.addEventListener("mouseup",this._onPointerUp,!0),this.supportsTouchEvents&&(this.domElement.addEventListener("touchstart",this._onPointerDown,!0),this.domElement.addEventListener("touchend",this._onPointerUp,!0),this.domElement.addEventListener("touchmove",this._onPointerMove,!0))),this.domElement.addEventListener("wheel",this.onWheel,{passive:!0,capture:!0}),this._eventsAdded=!0}_removeEvents(){if(!this._eventsAdded||!this.domElement)return;EventsTicker.removeTickerListener();const Z=this.domElement.style;Z&&(globalThis.navigator.msPointerEnabled?(Z.msContentZooming="",Z.msTouchAction=""):this.supportsPointerEvents&&(Z.touchAction="")),this.supportsPointerEvents?(globalThis.document.removeEventListener("pointermove",this._onPointerMove,!0),this.domElement.removeEventListener("pointerdown",this._onPointerDown,!0),this.domElement.removeEventListener("pointerleave",this._onPointerOverOut,!0),this.domElement.removeEventListener("pointerover",this._onPointerOverOut,!0),globalThis.removeEventListener("pointerup",this._onPointerUp,!0)):(globalThis.document.removeEventListener("mousemove",this._onPointerMove,!0),this.domElement.removeEventListener("mousedown",this._onPointerDown,!0),this.domElement.removeEventListener("mouseout",this._onPointerOverOut,!0),this.domElement.removeEventListener("mouseover",this._onPointerOverOut,!0),globalThis.removeEventListener("mouseup",this._onPointerUp,!0),this.supportsTouchEvents&&(this.domElement.removeEventListener("touchstart",this._onPointerDown,!0),this.domElement.removeEventListener("touchend",this._onPointerUp,!0),this.domElement.removeEventListener("touchmove",this._onPointerMove,!0))),this.domElement.removeEventListener("wheel",this.onWheel,!0),this.domElement=null,this._eventsAdded=!1}mapPositionToPoint(Z,X,K){const J=this.domElement.isConnected?this.domElement.getBoundingClientRect():{x:0,y:0,width:this.domElement.width,height:this.domElement.height,left:0,top:0},Q=1/this.resolution;Z.x=(X-J.left)*(this.domElement.width/J.width)*Q,Z.y=(K-J.top)*(this.domElement.height/J.height)*Q}_normalizeToPointerData(Z){const X=[];if(this.supportsTouchEvents&&Z instanceof TouchEvent)for(let K=0,J=Z.changedTouches.length;K<J;K++){const Q=Z.changedTouches[K];typeof Q.button=="undefined"&&(Q.button=0),typeof Q.buttons=="undefined"&&(Q.buttons=1),typeof Q.isPrimary=="undefined"&&(Q.isPrimary=Z.touches.length===1&&Z.type==="touchstart"),typeof Q.width=="undefined"&&(Q.width=Q.radiusX||1),typeof Q.height=="undefined"&&(Q.height=Q.radiusY||1),typeof Q.tiltX=="undefined"&&(Q.tiltX=0),typeof Q.tiltY=="undefined"&&(Q.tiltY=0),typeof Q.pointerType=="undefined"&&(Q.pointerType="touch"),typeof Q.pointerId=="undefined"&&(Q.pointerId=Q.identifier||0),typeof Q.pressure=="undefined"&&(Q.pressure=Q.force||.5),typeof Q.twist=="undefined"&&(Q.twist=0),typeof Q.tangentialPressure=="undefined"&&(Q.tangentialPressure=0),typeof Q.layerX=="undefined"&&(Q.layerX=Q.offsetX=Q.clientX),typeof Q.layerY=="undefined"&&(Q.layerY=Q.offsetY=Q.clientY),Q.isNormalized=!0,Q.type=Z.type,X.push(Q)}else if(!globalThis.MouseEvent||Z instanceof MouseEvent&&(!this.supportsPointerEvents||!(Z instanceof globalThis.PointerEvent))){const K=Z;typeof K.isPrimary=="undefined"&&(K.isPrimary=!0),typeof K.width=="undefined"&&(K.width=1),typeof K.height=="undefined"&&(K.height=1),typeof K.tiltX=="undefined"&&(K.tiltX=0),typeof K.tiltY=="undefined"&&(K.tiltY=0),typeof K.pointerType=="undefined"&&(K.pointerType="mouse"),typeof K.pointerId=="undefined"&&(K.pointerId=b$h),typeof K.pressure=="undefined"&&(K.pressure=.5),typeof K.twist=="undefined"&&(K.twist=0),typeof K.tangentialPressure=="undefined"&&(K.tangentialPressure=0),K.isNormalized=!0,X.push(K)}else X.push(Z);return X}normalizeWheelEvent(Z){const X=this._rootWheelEvent;return this._transferMouseData(X,Z),X.deltaX=Z.deltaX,X.deltaY=Z.deltaY,X.deltaZ=Z.deltaZ,X.deltaMode=Z.deltaMode,this.mapPositionToPoint(X.screen,Z.clientX,Z.clientY),X.global.copyFrom(X.screen),X.offset.copyFrom(X.screen),X.nativeEvent=Z,X.type=Z.type,X}_bootstrapEvent(Z,X){return Z.originalEvent=null,Z.nativeEvent=X,Z.pointerId=X.pointerId,Z.width=X.width,Z.height=X.height,Z.isPrimary=X.isPrimary,Z.pointerType=X.pointerType,Z.pressure=X.pressure,Z.tangentialPressure=X.tangentialPressure,Z.tiltX=X.tiltX,Z.tiltY=X.tiltY,Z.twist=X.twist,this._transferMouseData(Z,X),this.mapPositionToPoint(Z.screen,X.clientX,X.clientY),Z.global.copyFrom(Z.screen),Z.offset.copyFrom(Z.screen),Z.isTrusted=X.isTrusted,Z.type==="pointerleave"&&(Z.type="pointerout"),Z.type.startsWith("mouse")&&(Z.type=Z.type.replace("mouse","pointer")),Z.type.startsWith("touch")&&(Z.type=g$h[Z.type]||Z.type),Z}_transferMouseData(Z,X){Z.isTrusted=X.isTrusted,Z.srcElement=X.srcElement,Z.timeStamp=performance.now(),Z.type=X.type,Z.altKey=X.altKey,Z.button=X.button,Z.buttons=X.buttons,Z.client.x=X.clientX,Z.client.y=X.clientY,Z.ctrlKey=X.ctrlKey,Z.metaKey=X.metaKey,Z.movement.x=X.movementX,Z.movement.y=X.movementY,Z.page.x=X.pageX,Z.page.y=X.pageY,Z.relatedTarget=null,Z.shiftKey=X.shiftKey}};let EventSystem=u$k;EventSystem.extension={name:"events",type:[u$v.WebGLSystem,u$v.CanvasSystem,u$v.WebGPUSystem],priority:-1},EventSystem.defaultEventFeatures={move:!0,globalMove:!0,click:!0,wheel:!0};const FederatedContainer={onclick:null,onmousedown:null,onmouseenter:null,onmouseleave:null,onmousemove:null,onglobalmousemove:null,onmouseout:null,onmouseover:null,onmouseup:null,onmouseupoutside:null,onpointercancel:null,onpointerdown:null,onpointerenter:null,onpointerleave:null,onpointermove:null,onglobalpointermove:null,onpointerout:null,onpointerover:null,onpointertap:null,onpointerup:null,onpointerupoutside:null,onrightclick:null,onrightdown:null,onrightup:null,onrightupoutside:null,ontap:null,ontouchcancel:null,ontouchend:null,ontouchendoutside:null,ontouchmove:null,onglobaltouchmove:null,ontouchstart:null,onwheel:null,get interactive(){return this.eventMode==="dynamic"||this.eventMode==="static"},set interactive(Z){this.eventMode=Z?"static":"passive"},_internalEventMode:void 0,get eventMode(){var Z;return(Z=this._internalEventMode)!=null?Z:EventSystem.defaultEventMode},set eventMode(Z){this._internalEventMode=Z},isInteractive(){return this.eventMode==="static"||this.eventMode==="dynamic"},interactiveChildren:!0,hitArea:null,addEventListener(Z,X,K){const J=typeof K=="boolean"&&K||typeof K=="object"&&K.capture,Q=typeof X=="function"?void 0:X;Z=J?`${Z}capture`:Z,X=typeof X=="function"?X:X.handleEvent,this.on(Z,X,Q)},removeEventListener(Z,X,K){const J=typeof K=="boolean"&&K||typeof K=="object"&&K.capture,Q=typeof X=="function"?void 0:X;Z=J?`${Z}capture`:Z,X=typeof X=="function"?X:X.handleEvent,this.off(Z,X,Q)},dispatchEvent(Z){if(!(Z instanceof FederatedEvent))throw new Error("Container cannot propagate events outside of the Federated Events API");return Z.defaultPrevented=!1,Z.path=null,Z.target=this,Z.manager.dispatchEvent(Z),!Z.defaultPrevented}};b$p.add(EventSystem),Container.mixin(FederatedContainer);const n$q=class{constructor(Z,X){this.linkedSheets=[],this._texture=Z instanceof Texture?Z:null,this.textureSource=Z.source,this.textures={},this.animations={},this.data=X;const K=parseFloat(X.meta.scale);K?(this.resolution=K,Z.source.resolution=this.resolution):this.resolution=Z.source._resolution,this._frames=this.data.frames,this._frameKeys=Object.keys(this._frames),this._batchIndex=0,this._callback=null}parse(){return new Promise(Z=>{this._callback=Z,this._batchIndex=0,this._frameKeys.length<=n$q.BATCH_SIZE?(this._processFrames(0),this._processAnimations(),this._parseComplete()):this._nextBatch()})}_processFrames(Z){let X=Z;const K=n$q.BATCH_SIZE;for(;X-Z<K&&X<this._frameKeys.length;){const J=this._frameKeys[X],Q=this._frames[J],ee=Q.frame;if(ee){let te=null,re=null;const ie=Q.trimmed!==!1&&Q.sourceSize?Q.sourceSize:Q.frame,ne=new Rectangle(0,0,Math.floor(ie.w)/this.resolution,Math.floor(ie.h)/this.resolution);Q.rotated?te=new Rectangle(Math.floor(ee.x)/this.resolution,Math.floor(ee.y)/this.resolution,Math.floor(ee.h)/this.resolution,Math.floor(ee.w)/this.resolution):te=new Rectangle(Math.floor(ee.x)/this.resolution,Math.floor(ee.y)/this.resolution,Math.floor(ee.w)/this.resolution,Math.floor(ee.h)/this.resolution),Q.trimmed!==!1&&Q.spriteSourceSize&&(re=new Rectangle(Math.floor(Q.spriteSourceSize.x)/this.resolution,Math.floor(Q.spriteSourceSize.y)/this.resolution,Math.floor(ee.w)/this.resolution,Math.floor(ee.h)/this.resolution),re.x/=this.textureSource.width,re.y/=this.textureSource.height,re.width/=this.textureSource.width,re.height/=this.textureSource.height),te.x/=this.textureSource.width,te.y/=this.textureSource.height,te.width/=this.textureSource.width,te.height/=this.textureSource.height,ne.x/=this.textureSource.width,ne.y/=this.textureSource.height,ne.width/=this.textureSource.width,ne.height/=this.textureSource.height,this.textures[J]=new Texture({source:this.textureSource,layout:{frame:te,orig:ne,trim:re,rotate:Q.rotated?2:0,defaultAnchor:Q.anchor,defaultBorders:Q.borders},label:J.toString()})}X++}}_processAnimations(){const Z=this.data.animations||{};for(const X in Z){this.animations[X]=[];for(let K=0;K<Z[X].length;K++){const J=Z[X][K];this.animations[X].push(this.textures[J])}}}_parseComplete(){const Z=this._callback;this._callback=null,this._batchIndex=0,Z.call(this,this.textures)}_nextBatch(){this._processFrames(this._batchIndex*n$q.BATCH_SIZE),this._batchIndex++,setTimeout(()=>{this._batchIndex*n$q.BATCH_SIZE<this._frameKeys.length?this._nextBatch():(this._processAnimations(),this._parseComplete())},0)}destroy(Z=!1){var X;for(const K in this.textures)this.textures[K].destroy();this._frames=null,this._frameKeys=null,this.data=null,this.textures=null,Z&&((X=this._texture)==null||X.destroy(),this.textureSource.destroy()),this._texture=null,this.textureSource=null,this.linkedSheets=[]}};let Spritesheet=n$q;Spritesheet.BATCH_SIZE=1e3;const b$g=["jpg","png","jpeg","avif","webp"];function y$b(Z,X,K){const J={};if(Z.forEach(Q=>{J[Q]=X}),Object.keys(X.textures).forEach(Q=>{J[Q]=X.textures[Q]}),!K){const Q=path.dirname(Z[0]);X.linkedSheets.forEach((ee,te)=>{const re=y$b([`${Q}/${X.data.meta.related_multi_packs[te]}`],ee,!0);Object.assign(J,re)})}return J}const spritesheetAsset={extension:u$v.Asset,cache:{test:Z=>Z instanceof Spritesheet,getCacheableAssets:(Z,X)=>y$b(Z,X,!1)},resolver:{test:Z=>{const X=Z.split("?")[0].split("."),K=X.pop(),J=X.pop();return K==="json"&&b$g.includes(J)},parse:Z=>{var X,K;const J=Z.split(".");return{resolution:parseFloat((K=(X=Resolver.RETINA_PREFIX.exec(Z))==null?void 0:X[1])!=null?K:"1"),format:J[J.length-2],src:Z}}},loader:{name:"spritesheetLoader",extension:{type:u$v.LoadParser,priority:LoaderParserPriority.Normal},async testParse(Z,X){return path.extname(X.src).toLowerCase()===".json"&&!!Z.frames},async parse(Z,X,K){var J,Q;let ee=path.dirname(X.src);ee&&ee.lastIndexOf("/")!==ee.length-1&&(ee+="/");let te=ee+Z.meta.image;te=copySearchParams(te,X.src);const re=(await K.load([te]))[te],ie=new Spritesheet(re.source,Z);await ie.parse();const ne=(J=Z==null?void 0:Z.meta)==null?void 0:J.related_multi_packs;if(Array.isArray(ne)){const se=[];for(const ae of ne){if(typeof ae!="string")continue;let le=ee+ae;(Q=X.data)!=null&&Q.ignoreMultiPack||(le=copySearchParams(le,X.src),se.push(K.load({src:le,data:{ignoreMultiPack:!0}})))}const oe=await Promise.all(se);ie.linkedSheets=oe,oe.forEach(ae=>{ae.linkedSheets=[ie].concat(ie.linkedSheets.filter(le=>le!==ae))})}return ie},unload(Z){Z.destroy(!0)}}};b$p.add(spritesheetAsset);const emptyViewObserver={onViewUpdate:()=>{}};function updateQuadBounds(Z,X,K,J){const Q=K._source,ee=K.layout,te=ee.orig,re=ee.trim,ie=Q.width,ne=Q.height,se=ie*te.width,oe=ne*te.height;if(re){const ae=ie*re.width,le=ne*re.height;Z[0]=re.x*ie-X._x*se-J,Z[1]=Z[0]+ae,Z[2]=re.y*ne-X._y*oe-J,Z[3]=Z[2]+le}else Z[0]=-X._x*se-J,Z[1]=Z[0]+se,Z[2]=-X._y*oe-J,Z[3]=Z[2]+oe}class SpriteView{constructor(X){this.renderPipeId="sprite",this.owner=emptyViewObserver,this.uid=uid("spriteView"),this.batched=!0,this._didUpdate=!1,this._bounds=[0,1,0,0],this._sourceBounds=[0,1,0,0],this._boundsDirty=!0,this._sourceBoundsDirty=!0,this.roundPixels=0;var K,J;this.anchor=new ObservablePoint(this,((K=X.layout.defaultAnchor)==null?void 0:K.x)||0,((J=X.layout.defaultAnchor)==null?void 0:J.y)||0),this.texture=X}set texture(X){X||(X=Texture.EMPTY),this._texture!==X&&(this._texture=X,this.onUpdate())}get texture(){return this._texture}get bounds(){return this._boundsDirty&&(this._updateBounds(),this._boundsDirty=!1),this._bounds}get sourceBounds(){return this._sourceBoundsDirty&&(this._updateSourceBounds(),this._sourceBoundsDirty=!1),this._sourceBounds}containsPoint(X){const K=this._texture.frameWidth,J=this._texture.frameHeight,Q=-K*this.anchor.x;let ee=0;return X.x>=Q&&X.x<=Q+K&&(ee=-J*this.anchor.y,X.y>=ee&&X.y<=ee+J)}addBounds(X){if(this._texture._layout.trim){const K=this.sourceBounds;X.addFrame(K[0],K[2],K[1],K[3])}else{const K=this.bounds;X.addFrame(K[0],K[2],K[1],K[3])}}onUpdate(){this._didUpdate=!0,this._sourceBoundsDirty=this._boundsDirty=!0,this.owner.onViewUpdate()}_updateBounds(){updateQuadBounds(this._bounds,this.anchor,this._texture,0)}_updateSourceBounds(){const X=this.anchor,K=this._texture,J=K._source,Q=K.layout.orig,ee=this._sourceBounds,te=J.width*Q.width,re=J.height*Q.height;ee[1]=-X._x*te,ee[0]=ee[1]+te,ee[3]=-X._y*re,ee[2]=ee[3]+re}destroy(X=!1){if(this.anchor=null,typeof X=="boolean"?X:X==null?void 0:X.texture){const K=typeof X=="boolean"?X:X==null?void 0:X.textureSource;this._texture.destroy(K)}this._texture=null,this._bounds=null,this._sourceBounds=null}}var m$n=Object.defineProperty,o$n=Object.getOwnPropertySymbols,p$u=Object.prototype.hasOwnProperty,u$j=Object.prototype.propertyIsEnumerable,s$s=(Z,X,K)=>X in Z?m$n(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,x$8=(Z,X)=>{for(var K in X||(X={}))p$u.call(X,K)&&s$s(Z,K,X[K]);if(o$n)for(var K of o$n(X))u$j.call(X,K)&&s$s(Z,K,X[K]);return Z},h$m=(Z,X)=>{var K={};for(var J in Z)p$u.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&o$n)for(var J of o$n(Z))X.indexOf(J)<0&&u$j.call(Z,J)&&(K[J]=Z[J]);return K};class Sprite extends Container{static from(X,K=!1){return X instanceof Texture?new Sprite(X):new Sprite(Texture.from(X,K))}constructor(X=Texture.EMPTY){X instanceof Texture&&(X={texture:X});const K=X,{texture:J}=K,Q=h$m(K,["texture"]);super(x$8({view:new SpriteView(J!=null?J:Texture.EMPTY),label:"Sprite"},Q)),this.allowChildren=!1}get anchor(){return this.view.anchor}set anchor(X){this.view.anchor.x=X.x,this.view.anchor.y=X.y}get texture(){return this.view.texture}set texture(X){this.view.texture=X}get roundPixels(){return!!this.view.roundPixels}set roundPixels(X){this.view.roundPixels=X?1:0}}const s$r=new Bounds;function addMaskBounds(Z,X,K){const J=s$r;Z.measurable=!0,getGlobalBounds(Z,K,J),X.addBoundsMask(J),Z.measurable=!1}function addMaskLocalBounds(Z,X,K){const J=new Bounds;Z.measurable=!0;const Q=getMatrixRelativeToParent(Z,K,new Matrix);getLocalBounds(Z,J,Q),Z.measurable=!1,X.addBoundsMask(J)}function getMatrixRelativeToParent(Z,X,K){return Z&&Z!==X&&(getMatrixRelativeToParent(Z.parent,X,K),Z.didChange&&updateLocalTransform(Z.localTransform,Z),K.append(Z.localTransform)),K}class AlphaMask{constructor(X){this.priority=0,this.pipe="alphaMask",X!=null&&X.mask&&this.init(X.mask)}init(X){this.mask=X,this.renderMaskToTexture=!(X instanceof Sprite),this.mask.renderable=this.renderMaskToTexture,this.mask.includeInBuild=!this.renderMaskToTexture,this.mask.measurable=!1}reset(){this.mask.measurable=!0,this.mask=null}addBounds(X,K){addMaskBounds(this.mask,X,K)}addLocalBounds(X,K){addMaskLocalBounds(this.mask,X,K)}containsPoint(X,K){const J=this.mask;return K(J,X)}destroy(){this.reset()}static test(X){return X instanceof Sprite}}AlphaMask.extension=u$v.MaskEffect;class ColorMask{constructor(X){this.priority=0,this.pipe="colorMask",X!=null&&X.mask&&this.init(X.mask)}init(X){this.mask=X}destroy(){}static test(X){return typeof X=="number"}}ColorMask.extension=u$v.MaskEffect;class StencilMask{constructor(X){this.priority=0,this.pipe="stencilMask",X!=null&&X.mask&&this.init(X.mask)}init(X){this.mask=X,this.mask.includeInBuild=!1,this.mask.measurable=!1}reset(){this.mask.measurable=!0,this.mask.includeInBuild=!0,this.mask=null}addBounds(X,K){addMaskBounds(this.mask,X,K)}addLocalBounds(X,K){addMaskLocalBounds(this.mask,X,K)}containsPoint(X,K){const J=this.mask;return K(J,X)}destroy(){this.reset()}static test(X){return X instanceof Container}}StencilMask.extension=u$v.MaskEffect;var u$i=Object.defineProperty,y$a=Object.defineProperties,c$h=Object.getOwnPropertyDescriptors,i$h=Object.getOwnPropertySymbols,A$3=Object.prototype.hasOwnProperty,p$t=Object.prototype.propertyIsEnumerable,f$n=(Z,X,K)=>X in Z?u$i(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$m=(Z,X)=>{for(var K in X||(X={}))A$3.call(X,K)&&f$n(Z,K,X[K]);if(i$h)for(var K of i$h(X))p$t.call(X,K)&&f$n(Z,K,X[K]);return Z},s$q=(Z,X)=>y$a(Z,c$h(X));class BufferImageSource extends TextureSource{constructor(X){const K=X.resource||new Float32Array(X.width*X.height*4);let J=X.format;J||(K instanceof Float32Array?J="rgba32float":K instanceof Int32Array||K instanceof Uint32Array?J="rgba32uint":K instanceof Int16Array||K instanceof Uint16Array?J="rgba16uint":(K instanceof Int8Array,J="bgra8unorm")),super(s$q(o$m({},X),{resource:K,format:J})),this.uploadMethodId="buffer"}static test(X){return X instanceof Int8Array||X instanceof Uint8Array||X instanceof Uint8ClampedArray||X instanceof Int16Array||X instanceof Uint16Array||X instanceof Int32Array||X instanceof Uint32Array||X instanceof Float32Array}}BufferImageSource.extension=u$v.TextureSource;class CanvasSource extends TextureSource{constructor(X){X.resource||(X.resource=DOMAdapter.get().createCanvas()),X.width||(X.width=X.resource.width,X.autoDensity||(X.width/=X.resolution)),X.height||(X.height=X.resource.height,X.autoDensity||(X.height/=X.resolution)),super(X),this.uploadMethodId="image",this.autoDensity=X.autoDensity;const K=X.resource;(this.pixelWidth!==K.width||this.pixelWidth!==K.height)&&this.resizeCanvas()}resizeCanvas(){this.autoDensity&&(this.resource.style.width=`${this.width}px`,this.resource.style.height=`${this.height}px`),this.resource.width=this.pixelWidth,this.resource.height=this.pixelHeight}resize(X=this.width,K=this.height,J=this._resolution){super.resize(X,K,J),this.resizeCanvas()}static test(X){return globalThis.HTMLCanvasElement&&X instanceof HTMLCanvasElement||globalThis.OffscreenCanvas&&X instanceof OffscreenCanvas}}CanvasSource.extension=u$v.TextureSource,b$p.add(AlphaMask,ColorMask,StencilMask,VideoSource,ImageSource,CanvasSource,BufferImageSource);var browserAll={__proto__:null};function find$1(Z,X,K){if(K===void 0&&(K=Array.prototype),Z&&typeof K.find=="function")return K.find.call(Z,X);for(var J=0;J<Z.length;J++)if(Object.prototype.hasOwnProperty.call(Z,J)){var Q=Z[J];if(X.call(void 0,Q,J,Z))return Q}}function freeze(Z,X){return X===void 0&&(X=Object),X&&typeof X.freeze=="function"?X.freeze(Z):Z}function assign(Z,X){if(Z===null||typeof Z!="object")throw new TypeError("target is not an object");for(var K in X)Object.prototype.hasOwnProperty.call(X,K)&&(Z[K]=X[K]);return Z}var MIME_TYPE=freeze({HTML:"text/html",isHTML:function(Z){return Z===MIME_TYPE.HTML},XML_APPLICATION:"application/xml",XML_TEXT:"text/xml",XML_XHTML_APPLICATION:"application/xhtml+xml",XML_SVG_IMAGE:"image/svg+xml"}),NAMESPACE$3=freeze({HTML:"http://www.w3.org/1999/xhtml",isHTML:function(Z){return Z===NAMESPACE$3.HTML},SVG:"http://www.w3.org/2000/svg",XML:"http://www.w3.org/XML/1998/namespace",XMLNS:"http://www.w3.org/2000/xmlns/"}),assign_1=assign,find_1=find$1,freeze_1=freeze,MIME_TYPE_1=MIME_TYPE,NAMESPACE_1=NAMESPACE$3,conventions={assign:assign_1,find:find_1,freeze:freeze_1,MIME_TYPE:MIME_TYPE_1,NAMESPACE:NAMESPACE_1},find=conventions.find,NAMESPACE$2=conventions.NAMESPACE;function notEmptyString(Z){return Z!==""}function splitOnASCIIWhitespace(Z){return Z?Z.split(/[\t\n\f\r ]+/).filter(notEmptyString):[]}function orderedSetReducer(Z,X){return Z.hasOwnProperty(X)||(Z[X]=!0),Z}function toOrderedSet(Z){if(!Z)return[];var X=splitOnASCIIWhitespace(Z);return Object.keys(X.reduce(orderedSetReducer,{}))}function arrayIncludes(Z){return function(X){return Z&&Z.indexOf(X)!==-1}}function copy(Z,X){for(var K in Z)Object.prototype.hasOwnProperty.call(Z,K)&&(X[K]=Z[K])}function _extends(Z,X){var K=Z.prototype;if(!(K instanceof X)){let J=function(){};J.prototype=X.prototype,J=new J,copy(K,J),Z.prototype=K=J}K.constructor!=Z&&(typeof Z!="function"&&console.error("unknown Class:"+Z),K.constructor=Z)}var NodeType={},ELEMENT_NODE=NodeType.ELEMENT_NODE=1,ATTRIBUTE_NODE=NodeType.ATTRIBUTE_NODE=2,TEXT_NODE=NodeType.TEXT_NODE=3,CDATA_SECTION_NODE=NodeType.CDATA_SECTION_NODE=4,ENTITY_REFERENCE_NODE=NodeType.ENTITY_REFERENCE_NODE=5,ENTITY_NODE=NodeType.ENTITY_NODE=6,PROCESSING_INSTRUCTION_NODE=NodeType.PROCESSING_INSTRUCTION_NODE=7,COMMENT_NODE=NodeType.COMMENT_NODE=8,DOCUMENT_NODE=NodeType.DOCUMENT_NODE=9,DOCUMENT_TYPE_NODE=NodeType.DOCUMENT_TYPE_NODE=10,DOCUMENT_FRAGMENT_NODE=NodeType.DOCUMENT_FRAGMENT_NODE=11,NOTATION_NODE=NodeType.NOTATION_NODE=12,ExceptionCode={},ExceptionMessage={},INDEX_SIZE_ERR=ExceptionCode.INDEX_SIZE_ERR=(ExceptionMessage[1]="Index size error",1),DOMSTRING_SIZE_ERR=ExceptionCode.DOMSTRING_SIZE_ERR=(ExceptionMessage[2]="DOMString size error",2),HIERARCHY_REQUEST_ERR=ExceptionCode.HIERARCHY_REQUEST_ERR=(ExceptionMessage[3]="Hierarchy request error",3),WRONG_DOCUMENT_ERR=ExceptionCode.WRONG_DOCUMENT_ERR=(ExceptionMessage[4]="Wrong document",4),INVALID_CHARACTER_ERR=ExceptionCode.INVALID_CHARACTER_ERR=(ExceptionMessage[5]="Invalid character",5),NO_DATA_ALLOWED_ERR=ExceptionCode.NO_DATA_ALLOWED_ERR=(ExceptionMessage[6]="No data allowed",6),NO_MODIFICATION_ALLOWED_ERR=ExceptionCode.NO_MODIFICATION_ALLOWED_ERR=(ExceptionMessage[7]="No modification allowed",7),NOT_FOUND_ERR=ExceptionCode.NOT_FOUND_ERR=(ExceptionMessage[8]="Not found",8),NOT_SUPPORTED_ERR=ExceptionCode.NOT_SUPPORTED_ERR=(ExceptionMessage[9]="Not supported",9),INUSE_ATTRIBUTE_ERR=ExceptionCode.INUSE_ATTRIBUTE_ERR=(ExceptionMessage[10]="Attribute in use",10),INVALID_STATE_ERR=ExceptionCode.INVALID_STATE_ERR=(ExceptionMessage[11]="Invalid state",11),SYNTAX_ERR=ExceptionCode.SYNTAX_ERR=(ExceptionMessage[12]="Syntax error",12),INVALID_MODIFICATION_ERR=ExceptionCode.INVALID_MODIFICATION_ERR=(ExceptionMessage[13]="Invalid modification",13),NAMESPACE_ERR=ExceptionCode.NAMESPACE_ERR=(ExceptionMessage[14]="Invalid namespace",14),INVALID_ACCESS_ERR=ExceptionCode.INVALID_ACCESS_ERR=(ExceptionMessage[15]="Invalid access",15);function DOMException(Z,X){if(X instanceof Error)var K=X;else K=this,Error.call(this,ExceptionMessage[Z]),this.message=ExceptionMessage[Z],Error.captureStackTrace&&Error.captureStackTrace(this,DOMException);return K.code=Z,X&&(this.message=this.message+": "+X),K}DOMException.prototype=Error.prototype,copy(ExceptionCode,DOMException);function NodeList(){}NodeList.prototype={length:0,item:function(Z){return Z>=0&&Z<this.length?this[Z]:null},toString:function(Z,X){for(var K=[],J=0;J<this.length;J++)serializeToString(this[J],K,Z,X);return K.join("")},filter:function(Z){return Array.prototype.filter.call(this,Z)},indexOf:function(Z){return Array.prototype.indexOf.call(this,Z)}};function LiveNodeList(Z,X){this._node=Z,this._refresh=X,_updateLiveList(this)}function _updateLiveList(Z){var X=Z._node._inc||Z._node.ownerDocument._inc;if(Z._inc!==X){var K=Z._refresh(Z._node);if(__set__(Z,"length",K.length),!Z.$$length||K.length<Z.$$length)for(var J=K.length;J in Z;J++)Object.prototype.hasOwnProperty.call(Z,J)&&delete Z[J];copy(K,Z),Z._inc=X}}LiveNodeList.prototype.item=function(Z){return _updateLiveList(this),this[Z]||null},_extends(LiveNodeList,NodeList);function NamedNodeMap(){}function _findNodeIndex(Z,X){for(var K=Z.length;K--;)if(Z[K]===X)return K}function _addNamedNode(Z,X,K,J){if(J?X[_findNodeIndex(X,J)]=K:X[X.length++]=K,Z){K.ownerElement=Z;var Q=Z.ownerDocument;Q&&(J&&_onRemoveAttribute(Q,Z,J),_onAddAttribute(Q,Z,K))}}function _removeNamedNode(Z,X,K){var J=_findNodeIndex(X,K);if(J>=0){for(var Q=X.length-1;J<Q;)X[J]=X[++J];if(X.length=Q,Z){var ee=Z.ownerDocument;ee&&(_onRemoveAttribute(ee,Z,K),K.ownerElement=null)}}else throw new DOMException(NOT_FOUND_ERR,new Error(Z.tagName+"@"+K))}NamedNodeMap.prototype={length:0,item:NodeList.prototype.item,getNamedItem:function(Z){for(var X=this.length;X--;){var K=this[X];if(K.nodeName==Z)return K}},setNamedItem:function(Z){var X=Z.ownerElement;if(X&&X!=this._ownerElement)throw new DOMException(INUSE_ATTRIBUTE_ERR);var K=this.getNamedItem(Z.nodeName);return _addNamedNode(this._ownerElement,this,Z,K),K},setNamedItemNS:function(Z){var X=Z.ownerElement,K;if(X&&X!=this._ownerElement)throw new DOMException(INUSE_ATTRIBUTE_ERR);return K=this.getNamedItemNS(Z.namespaceURI,Z.localName),_addNamedNode(this._ownerElement,this,Z,K),K},removeNamedItem:function(Z){var X=this.getNamedItem(Z);return _removeNamedNode(this._ownerElement,this,X),X},removeNamedItemNS:function(Z,X){var K=this.getNamedItemNS(Z,X);return _removeNamedNode(this._ownerElement,this,K),K},getNamedItemNS:function(Z,X){for(var K=this.length;K--;){var J=this[K];if(J.localName==X&&J.namespaceURI==Z)return J}return null}};function DOMImplementation$2(){}DOMImplementation$2.prototype={hasFeature:function(Z,X){return!0},createDocument:function(Z,X,K){var J=new Document;if(J.implementation=this,J.childNodes=new NodeList,J.doctype=K||null,K&&J.appendChild(K),X){var Q=J.createElementNS(Z,X);J.appendChild(Q)}return J},createDocumentType:function(Z,X,K){var J=new DocumentType;return J.name=Z,J.nodeName=Z,J.publicId=X||"",J.systemId=K||"",J}};function Node$1(){}Node$1.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(Z,X){return _insertBefore(this,Z,X)},replaceChild:function(Z,X){_insertBefore(this,Z,X,assertPreReplacementValidityInDocument),X&&this.removeChild(X)},removeChild:function(Z){return _removeChild(this,Z)},appendChild:function(Z){return this.insertBefore(Z,null)},hasChildNodes:function(){return this.firstChild!=null},cloneNode:function(Z){return cloneNode(this.ownerDocument||this,this,Z)},normalize:function(){for(var Z=this.firstChild;Z;){var X=Z.nextSibling;X&&X.nodeType==TEXT_NODE&&Z.nodeType==TEXT_NODE?(this.removeChild(X),Z.appendData(X.data)):(Z.normalize(),Z=X)}},isSupported:function(Z,X){return this.ownerDocument.implementation.hasFeature(Z,X)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(Z){for(var X=this;X;){var K=X._nsMap;if(K){for(var J in K)if(Object.prototype.hasOwnProperty.call(K,J)&&K[J]===Z)return J}X=X.nodeType==ATTRIBUTE_NODE?X.ownerDocument:X.parentNode}return null},lookupNamespaceURI:function(Z){for(var X=this;X;){var K=X._nsMap;if(K&&Object.prototype.hasOwnProperty.call(K,Z))return K[Z];X=X.nodeType==ATTRIBUTE_NODE?X.ownerDocument:X.parentNode}return null},isDefaultNamespace:function(Z){var X=this.lookupPrefix(Z);return X==null}};function _xmlEncoder(Z){return Z=="<"&&"&lt;"||Z==">"&&"&gt;"||Z=="&"&&"&amp;"||Z=='"'&&"&quot;"||"&#"+Z.charCodeAt()+";"}copy(NodeType,Node$1),copy(NodeType,Node$1.prototype);function _visitNode(Z,X){if(X(Z))return!0;if(Z=Z.firstChild)do if(_visitNode(Z,X))return!0;while(Z=Z.nextSibling)}function Document(){this.ownerDocument=this}function _onAddAttribute(Z,X,K){Z&&Z._inc++;var J=K.namespaceURI;J===NAMESPACE$2.XMLNS&&(X._nsMap[K.prefix?K.localName:""]=K.value)}function _onRemoveAttribute(Z,X,K,J){Z&&Z._inc++;var Q=K.namespaceURI;Q===NAMESPACE$2.XMLNS&&delete X._nsMap[K.prefix?K.localName:""]}function _onUpdateChild(Z,X,K){if(Z&&Z._inc){Z._inc++;var J=X.childNodes;if(K)J[J.length++]=K;else{for(var Q=X.firstChild,ee=0;Q;)J[ee++]=Q,Q=Q.nextSibling;J.length=ee,delete J[J.length]}}}function _removeChild(Z,X){var K=X.previousSibling,J=X.nextSibling;return K?K.nextSibling=J:Z.firstChild=J,J?J.previousSibling=K:Z.lastChild=K,X.parentNode=null,X.previousSibling=null,X.nextSibling=null,_onUpdateChild(Z.ownerDocument,Z),X}function hasValidParentNodeType(Z){return Z&&(Z.nodeType===Node$1.DOCUMENT_NODE||Z.nodeType===Node$1.DOCUMENT_FRAGMENT_NODE||Z.nodeType===Node$1.ELEMENT_NODE)}function hasInsertableNodeType(Z){return Z&&(isElementNode(Z)||isTextNode(Z)||isDocTypeNode(Z)||Z.nodeType===Node$1.DOCUMENT_FRAGMENT_NODE||Z.nodeType===Node$1.COMMENT_NODE||Z.nodeType===Node$1.PROCESSING_INSTRUCTION_NODE)}function isDocTypeNode(Z){return Z&&Z.nodeType===Node$1.DOCUMENT_TYPE_NODE}function isElementNode(Z){return Z&&Z.nodeType===Node$1.ELEMENT_NODE}function isTextNode(Z){return Z&&Z.nodeType===Node$1.TEXT_NODE}function isElementInsertionPossible(Z,X){var K=Z.childNodes||[];if(find(K,isElementNode)||isDocTypeNode(X))return!1;var J=find(K,isDocTypeNode);return!(X&&J&&K.indexOf(J)>K.indexOf(X))}function isElementReplacementPossible(Z,X){var K=Z.childNodes||[];function J(ee){return isElementNode(ee)&&ee!==X}if(find(K,J))return!1;var Q=find(K,isDocTypeNode);return!(X&&Q&&K.indexOf(Q)>K.indexOf(X))}function assertPreInsertionValidity1to5(Z,X,K){if(!hasValidParentNodeType(Z))throw new DOMException(HIERARCHY_REQUEST_ERR,"Unexpected parent node type "+Z.nodeType);if(K&&K.parentNode!==Z)throw new DOMException(NOT_FOUND_ERR,"child not in parent");if(!hasInsertableNodeType(X)||isDocTypeNode(X)&&Z.nodeType!==Node$1.DOCUMENT_NODE)throw new DOMException(HIERARCHY_REQUEST_ERR,"Unexpected node type "+X.nodeType+" for parent node type "+Z.nodeType)}function assertPreInsertionValidityInDocument(Z,X,K){var J=Z.childNodes||[],Q=X.childNodes||[];if(X.nodeType===Node$1.DOCUMENT_FRAGMENT_NODE){var ee=Q.filter(isElementNode);if(ee.length>1||find(Q,isTextNode))throw new DOMException(HIERARCHY_REQUEST_ERR,"More than one element or text in fragment");if(ee.length===1&&!isElementInsertionPossible(Z,K))throw new DOMException(HIERARCHY_REQUEST_ERR,"Element in fragment can not be inserted before doctype")}if(isElementNode(X)&&!isElementInsertionPossible(Z,K))throw new DOMException(HIERARCHY_REQUEST_ERR,"Only one element can be added and only after doctype");if(isDocTypeNode(X)){if(find(J,isDocTypeNode))throw new DOMException(HIERARCHY_REQUEST_ERR,"Only one doctype is allowed");var te=find(J,isElementNode);if(K&&J.indexOf(te)<J.indexOf(K))throw new DOMException(HIERARCHY_REQUEST_ERR,"Doctype can only be inserted before an element");if(!K&&te)throw new DOMException(HIERARCHY_REQUEST_ERR,"Doctype can not be appended since element is present")}}function assertPreReplacementValidityInDocument(Z,X,K){var J=Z.childNodes||[],Q=X.childNodes||[];if(X.nodeType===Node$1.DOCUMENT_FRAGMENT_NODE){var ee=Q.filter(isElementNode);if(ee.length>1||find(Q,isTextNode))throw new DOMException(HIERARCHY_REQUEST_ERR,"More than one element or text in fragment");if(ee.length===1&&!isElementReplacementPossible(Z,K))throw new DOMException(HIERARCHY_REQUEST_ERR,"Element in fragment can not be inserted before doctype")}if(isElementNode(X)&&!isElementReplacementPossible(Z,K))throw new DOMException(HIERARCHY_REQUEST_ERR,"Only one element can be added and only after doctype");if(isDocTypeNode(X)){if(find(J,function(ie){return isDocTypeNode(ie)&&ie!==K}))throw new DOMException(HIERARCHY_REQUEST_ERR,"Only one doctype is allowed");var te=find(J,isElementNode);if(K&&J.indexOf(te)<J.indexOf(K))throw new DOMException(HIERARCHY_REQUEST_ERR,"Doctype can only be inserted before an element")}}function _insertBefore(Z,X,K,J){assertPreInsertionValidity1to5(Z,X,K),Z.nodeType===Node$1.DOCUMENT_NODE&&(J||assertPreInsertionValidityInDocument)(Z,X,K);var Q=X.parentNode;if(Q&&Q.removeChild(X),X.nodeType===DOCUMENT_FRAGMENT_NODE){var ee=X.firstChild;if(ee==null)return X;var te=X.lastChild}else ee=te=X;var re=K?K.previousSibling:Z.lastChild;ee.previousSibling=re,te.nextSibling=K,re?re.nextSibling=ee:Z.firstChild=ee,K==null?Z.lastChild=te:K.previousSibling=te;do ee.parentNode=Z;while(ee!==te&&(ee=ee.nextSibling));return _onUpdateChild(Z.ownerDocument||Z,Z),X.nodeType==DOCUMENT_FRAGMENT_NODE&&(X.firstChild=X.lastChild=null),X}function _appendSingleChild(Z,X){return X.parentNode&&X.parentNode.removeChild(X),X.parentNode=Z,X.previousSibling=Z.lastChild,X.nextSibling=null,X.previousSibling?X.previousSibling.nextSibling=X:Z.firstChild=X,Z.lastChild=X,_onUpdateChild(Z.ownerDocument,Z,X),X}Document.prototype={nodeName:"#document",nodeType:DOCUMENT_NODE,doctype:null,documentElement:null,_inc:1,insertBefore:function(Z,X){if(Z.nodeType==DOCUMENT_FRAGMENT_NODE){for(var K=Z.firstChild;K;){var J=K.nextSibling;this.insertBefore(K,X),K=J}return Z}return _insertBefore(this,Z,X),Z.ownerDocument=this,this.documentElement===null&&Z.nodeType===ELEMENT_NODE&&(this.documentElement=Z),Z},removeChild:function(Z){return this.documentElement==Z&&(this.documentElement=null),_removeChild(this,Z)},replaceChild:function(Z,X){_insertBefore(this,Z,X,assertPreReplacementValidityInDocument),Z.ownerDocument=this,X&&this.removeChild(X),isElementNode(Z)&&(this.documentElement=Z)},importNode:function(Z,X){return importNode(this,Z,X)},getElementById:function(Z){var X=null;return _visitNode(this.documentElement,function(K){if(K.nodeType==ELEMENT_NODE&&K.getAttribute("id")==Z)return X=K,!0}),X},getElementsByClassName:function(Z){var X=toOrderedSet(Z);return new LiveNodeList(this,function(K){var J=[];return X.length>0&&_visitNode(K.documentElement,function(Q){if(Q!==K&&Q.nodeType===ELEMENT_NODE){var ee=Q.getAttribute("class");if(ee){var te=Z===ee;if(!te){var re=toOrderedSet(ee);te=X.every(arrayIncludes(re))}te&&J.push(Q)}}}),J})},createElement:function(Z){var X=new Element;X.ownerDocument=this,X.nodeName=Z,X.tagName=Z,X.localName=Z,X.childNodes=new NodeList;var K=X.attributes=new NamedNodeMap;return K._ownerElement=X,X},createDocumentFragment:function(){var Z=new DocumentFragment;return Z.ownerDocument=this,Z.childNodes=new NodeList,Z},createTextNode:function(Z){var X=new Text$1;return X.ownerDocument=this,X.appendData(Z),X},createComment:function(Z){var X=new Comment;return X.ownerDocument=this,X.appendData(Z),X},createCDATASection:function(Z){var X=new CDATASection;return X.ownerDocument=this,X.appendData(Z),X},createProcessingInstruction:function(Z,X){var K=new ProcessingInstruction;return K.ownerDocument=this,K.tagName=K.nodeName=K.target=Z,K.nodeValue=K.data=X,K},createAttribute:function(Z){var X=new Attr;return X.ownerDocument=this,X.name=Z,X.nodeName=Z,X.localName=Z,X.specified=!0,X},createEntityReference:function(Z){var X=new EntityReference;return X.ownerDocument=this,X.nodeName=Z,X},createElementNS:function(Z,X){var K=new Element,J=X.split(":"),Q=K.attributes=new NamedNodeMap;return K.childNodes=new NodeList,K.ownerDocument=this,K.nodeName=X,K.tagName=X,K.namespaceURI=Z,J.length==2?(K.prefix=J[0],K.localName=J[1]):K.localName=X,Q._ownerElement=K,K},createAttributeNS:function(Z,X){var K=new Attr,J=X.split(":");return K.ownerDocument=this,K.nodeName=X,K.name=X,K.namespaceURI=Z,K.specified=!0,J.length==2?(K.prefix=J[0],K.localName=J[1]):K.localName=X,K}},_extends(Document,Node$1);function Element(){this._nsMap={}}Element.prototype={nodeType:ELEMENT_NODE,hasAttribute:function(Z){return this.getAttributeNode(Z)!=null},getAttribute:function(Z){var X=this.getAttributeNode(Z);return X&&X.value||""},getAttributeNode:function(Z){return this.attributes.getNamedItem(Z)},setAttribute:function(Z,X){var K=this.ownerDocument.createAttribute(Z);K.value=K.nodeValue=""+X,this.setAttributeNode(K)},removeAttribute:function(Z){var X=this.getAttributeNode(Z);X&&this.removeAttributeNode(X)},appendChild:function(Z){return Z.nodeType===DOCUMENT_FRAGMENT_NODE?this.insertBefore(Z,null):_appendSingleChild(this,Z)},setAttributeNode:function(Z){return this.attributes.setNamedItem(Z)},setAttributeNodeNS:function(Z){return this.attributes.setNamedItemNS(Z)},removeAttributeNode:function(Z){return this.attributes.removeNamedItem(Z.nodeName)},removeAttributeNS:function(Z,X){var K=this.getAttributeNodeNS(Z,X);K&&this.removeAttributeNode(K)},hasAttributeNS:function(Z,X){return this.getAttributeNodeNS(Z,X)!=null},getAttributeNS:function(Z,X){var K=this.getAttributeNodeNS(Z,X);return K&&K.value||""},setAttributeNS:function(Z,X,K){var J=this.ownerDocument.createAttributeNS(Z,X);J.value=J.nodeValue=""+K,this.setAttributeNode(J)},getAttributeNodeNS:function(Z,X){return this.attributes.getNamedItemNS(Z,X)},getElementsByTagName:function(Z){return new LiveNodeList(this,function(X){var K=[];return _visitNode(X,function(J){J!==X&&J.nodeType==ELEMENT_NODE&&(Z==="*"||J.tagName==Z)&&K.push(J)}),K})},getElementsByTagNameNS:function(Z,X){return new LiveNodeList(this,function(K){var J=[];return _visitNode(K,function(Q){Q!==K&&Q.nodeType===ELEMENT_NODE&&(Z==="*"||Q.namespaceURI===Z)&&(X==="*"||Q.localName==X)&&J.push(Q)}),J})}},Document.prototype.getElementsByTagName=Element.prototype.getElementsByTagName,Document.prototype.getElementsByTagNameNS=Element.prototype.getElementsByTagNameNS,_extends(Element,Node$1);function Attr(){}Attr.prototype.nodeType=ATTRIBUTE_NODE,_extends(Attr,Node$1);function CharacterData(){}CharacterData.prototype={data:"",substringData:function(Z,X){return this.data.substring(Z,Z+X)},appendData:function(Z){Z=this.data+Z,this.nodeValue=this.data=Z,this.length=Z.length},insertData:function(Z,X){this.replaceData(Z,0,X)},appendChild:function(Z){throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])},deleteData:function(Z,X){this.replaceData(Z,X,"")},replaceData:function(Z,X,K){var J=this.data.substring(0,Z),Q=this.data.substring(Z+X);K=J+K+Q,this.nodeValue=this.data=K,this.length=K.length}},_extends(CharacterData,Node$1);function Text$1(){}Text$1.prototype={nodeName:"#text",nodeType:TEXT_NODE,splitText:function(Z){var X=this.data,K=X.substring(Z);X=X.substring(0,Z),this.data=this.nodeValue=X,this.length=X.length;var J=this.ownerDocument.createTextNode(K);return this.parentNode&&this.parentNode.insertBefore(J,this.nextSibling),J}},_extends(Text$1,CharacterData);function Comment(){}Comment.prototype={nodeName:"#comment",nodeType:COMMENT_NODE},_extends(Comment,CharacterData);function CDATASection(){}CDATASection.prototype={nodeName:"#cdata-section",nodeType:CDATA_SECTION_NODE},_extends(CDATASection,CharacterData);function DocumentType(){}DocumentType.prototype.nodeType=DOCUMENT_TYPE_NODE,_extends(DocumentType,Node$1);function Notation(){}Notation.prototype.nodeType=NOTATION_NODE,_extends(Notation,Node$1);function Entity(){}Entity.prototype.nodeType=ENTITY_NODE,_extends(Entity,Node$1);function EntityReference(){}EntityReference.prototype.nodeType=ENTITY_REFERENCE_NODE,_extends(EntityReference,Node$1);function DocumentFragment(){}DocumentFragment.prototype.nodeName="#document-fragment",DocumentFragment.prototype.nodeType=DOCUMENT_FRAGMENT_NODE,_extends(DocumentFragment,Node$1);function ProcessingInstruction(){}ProcessingInstruction.prototype.nodeType=PROCESSING_INSTRUCTION_NODE,_extends(ProcessingInstruction,Node$1);function XMLSerializer$2(){}XMLSerializer$2.prototype.serializeToString=function(Z,X,K){return nodeSerializeToString.call(Z,X,K)},Node$1.prototype.toString=nodeSerializeToString;function nodeSerializeToString(Z,X){var K=[],J=this.nodeType==9&&this.documentElement||this,Q=J.prefix,ee=J.namespaceURI;if(ee&&Q==null){var Q=J.lookupPrefix(ee);if(Q==null)var te=[{namespace:ee,prefix:null}]}return serializeToString(this,K,Z,X,te),K.join("")}function needNamespaceDefine(Z,X,K){var J=Z.prefix||"",Q=Z.namespaceURI;if(!Q||J==="xml"&&Q===NAMESPACE$2.XML||Q===NAMESPACE$2.XMLNS)return!1;for(var ee=K.length;ee--;){var te=K[ee];if(te.prefix===J)return te.namespace!==Q}return!0}function addSerializedAttribute(Z,X,K){Z.push(" ",X,'="',K.replace(/[<>&"\t\n\r]/g,_xmlEncoder),'"')}function serializeToString(Z,X,K,J,Q){if(Q||(Q=[]),J)if(Z=J(Z),Z){if(typeof Z=="string"){X.push(Z);return}}else return;switch(Z.nodeType){case ELEMENT_NODE:var ee=Z.attributes,te=ee.length,pe=Z.firstChild,re=Z.tagName;K=NAMESPACE$2.isHTML(Z.namespaceURI)||K;var ie=re;if(!K&&!Z.prefix&&Z.namespaceURI){for(var ne,se=0;se<ee.length;se++)if(ee.item(se).name==="xmlns"){ne=ee.item(se).value;break}if(!ne)for(var oe=Q.length-1;oe>=0;oe--){var ae=Q[oe];if(ae.prefix===""&&ae.namespace===Z.namespaceURI){ne=ae.namespace;break}}if(ne!==Z.namespaceURI)for(var oe=Q.length-1;oe>=0;oe--){var ae=Q[oe];if(ae.namespace===Z.namespaceURI){ae.prefix&&(ie=ae.prefix+":"+re);break}}}X.push("<",ie);for(var le=0;le<te;le++){var ce=ee.item(le);ce.prefix=="xmlns"?Q.push({prefix:ce.localName,namespace:ce.value}):ce.nodeName=="xmlns"&&Q.push({prefix:"",namespace:ce.value})}for(var le=0;le<te;le++){var ce=ee.item(le);if(needNamespaceDefine(ce,K,Q)){var de=ce.prefix||"",he=ce.namespaceURI;addSerializedAttribute(X,de?"xmlns:"+de:"xmlns",he),Q.push({prefix:de,namespace:he})}serializeToString(ce,X,K,J,Q)}if(re===ie&&needNamespaceDefine(Z,K,Q)){var de=Z.prefix||"",he=Z.namespaceURI;addSerializedAttribute(X,de?"xmlns:"+de:"xmlns",he),Q.push({prefix:de,namespace:he})}if(pe||K&&!/^(?:meta|link|img|br|hr|input)$/i.test(re)){if(X.push(">"),K&&/^script$/i.test(re))for(;pe;)pe.data?X.push(pe.data):serializeToString(pe,X,K,J,Q.slice()),pe=pe.nextSibling;else for(;pe;)serializeToString(pe,X,K,J,Q.slice()),pe=pe.nextSibling;X.push("</",ie,">")}else X.push("/>");return;case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:for(var pe=Z.firstChild;pe;)serializeToString(pe,X,K,J,Q.slice()),pe=pe.nextSibling;return;case ATTRIBUTE_NODE:return addSerializedAttribute(X,Z.name,Z.value);case TEXT_NODE:return X.push(Z.data.replace(/[<&>]/g,_xmlEncoder));case CDATA_SECTION_NODE:return X.push("<![CDATA[",Z.data,"]]>");case COMMENT_NODE:return X.push("<!--",Z.data,"-->");case DOCUMENT_TYPE_NODE:var fe=Z.publicId,ge=Z.systemId;if(X.push("<!DOCTYPE ",Z.name),fe)X.push(" PUBLIC ",fe),ge&&ge!="."&&X.push(" ",ge),X.push(">");else if(ge&&ge!=".")X.push(" SYSTEM ",ge,">");else{var me=Z.internalSubset;me&&X.push(" [",me,"]"),X.push(">")}return;case PROCESSING_INSTRUCTION_NODE:return X.push("<?",Z.target," ",Z.data,"?>");case ENTITY_REFERENCE_NODE:return X.push("&",Z.nodeName,";");default:X.push("??",Z.nodeName)}}function importNode(Z,X,K){var J;switch(X.nodeType){case ELEMENT_NODE:J=X.cloneNode(!1),J.ownerDocument=Z;case DOCUMENT_FRAGMENT_NODE:break;case ATTRIBUTE_NODE:K=!0;break}if(J||(J=X.cloneNode(!1)),J.ownerDocument=Z,J.parentNode=null,K)for(var Q=X.firstChild;Q;)J.appendChild(importNode(Z,Q,K)),Q=Q.nextSibling;return J}function cloneNode(Z,X,K){var J=new X.constructor;for(var Q in X)if(Object.prototype.hasOwnProperty.call(X,Q)){var ee=X[Q];typeof ee!="object"&&ee!=J[Q]&&(J[Q]=ee)}switch(X.childNodes&&(J.childNodes=new NodeList),J.ownerDocument=Z,J.nodeType){case ELEMENT_NODE:var te=X.attributes,re=J.attributes=new NamedNodeMap,ie=te.length;re._ownerElement=J;for(var ne=0;ne<ie;ne++)J.setAttributeNode(cloneNode(Z,te.item(ne),!0));break;case ATTRIBUTE_NODE:K=!0}if(K)for(var se=X.firstChild;se;)J.appendChild(cloneNode(Z,se,K)),se=se.nextSibling;return J}function __set__(Z,X,K){Z[X]=K}try{if(Object.defineProperty){let Z=function(X){switch(X.nodeType){case ELEMENT_NODE:case DOCUMENT_FRAGMENT_NODE:var K=[];for(X=X.firstChild;X;)X.nodeType!==7&&X.nodeType!==8&&K.push(Z(X)),X=X.nextSibling;return K.join("");default:return X.nodeValue}};Object.defineProperty(LiveNodeList.prototype,"length",{get:function(){return _updateLiveList(this),this.$$length}}),Object.defineProperty(Node$1.prototype,"textContent",{get:function(){return Z(this)},set:function(X){switch(this.nodeType){case ELEMENT_NODE:case DOCUMENT_FRAGMENT_NODE:for(;this.firstChild;)this.removeChild(this.firstChild);(X||String(X))&&this.appendChild(this.ownerDocument.createTextNode(X));break;default:this.data=X,this.value=X,this.nodeValue=X}}}),__set__=function(X,K,J){X["$$"+K]=J}}}catch(Z){}var DocumentType_1=DocumentType,DOMException_1=DOMException,DOMImplementation_1=DOMImplementation$2,Element_1=Element,Node_1=Node$1,NodeList_1=NodeList,XMLSerializer_1=XMLSerializer$2,dom={DocumentType:DocumentType_1,DOMException:DOMException_1,DOMImplementation:DOMImplementation_1,Element:Element_1,Node:Node_1,NodeList:NodeList_1,XMLSerializer:XMLSerializer_1},entities=createCommonjsModule(function(Z,X){"use strict";var K=conventions.freeze;X.XML_ENTITIES=K({amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}),X.HTML_ENTITIES=K({Aacute:"\xC1",aacute:"\xE1",Abreve:"\u0102",abreve:"\u0103",ac:"\u223E",acd:"\u223F",acE:"\u223E\u0333",Acirc:"\xC2",acirc:"\xE2",acute:"\xB4",Acy:"\u0410",acy:"\u0430",AElig:"\xC6",aelig:"\xE6",af:"\u2061",Afr:"\u{1D504}",afr:"\u{1D51E}",Agrave:"\xC0",agrave:"\xE0",alefsym:"\u2135",aleph:"\u2135",Alpha:"\u0391",alpha:"\u03B1",Amacr:"\u0100",amacr:"\u0101",amalg:"\u2A3F",AMP:"&",amp:"&",And:"\u2A53",and:"\u2227",andand:"\u2A55",andd:"\u2A5C",andslope:"\u2A58",andv:"\u2A5A",ang:"\u2220",ange:"\u29A4",angle:"\u2220",angmsd:"\u2221",angmsdaa:"\u29A8",angmsdab:"\u29A9",angmsdac:"\u29AA",angmsdad:"\u29AB",angmsdae:"\u29AC",angmsdaf:"\u29AD",angmsdag:"\u29AE",angmsdah:"\u29AF",angrt:"\u221F",angrtvb:"\u22BE",angrtvbd:"\u299D",angsph:"\u2222",angst:"\xC5",angzarr:"\u237C",Aogon:"\u0104",aogon:"\u0105",Aopf:"\u{1D538}",aopf:"\u{1D552}",ap:"\u2248",apacir:"\u2A6F",apE:"\u2A70",ape:"\u224A",apid:"\u224B",apos:"'",ApplyFunction:"\u2061",approx:"\u2248",approxeq:"\u224A",Aring:"\xC5",aring:"\xE5",Ascr:"\u{1D49C}",ascr:"\u{1D4B6}",Assign:"\u2254",ast:"*",asymp:"\u2248",asympeq:"\u224D",Atilde:"\xC3",atilde:"\xE3",Auml:"\xC4",auml:"\xE4",awconint:"\u2233",awint:"\u2A11",backcong:"\u224C",backepsilon:"\u03F6",backprime:"\u2035",backsim:"\u223D",backsimeq:"\u22CD",Backslash:"\u2216",Barv:"\u2AE7",barvee:"\u22BD",Barwed:"\u2306",barwed:"\u2305",barwedge:"\u2305",bbrk:"\u23B5",bbrktbrk:"\u23B6",bcong:"\u224C",Bcy:"\u0411",bcy:"\u0431",bdquo:"\u201E",becaus:"\u2235",Because:"\u2235",because:"\u2235",bemptyv:"\u29B0",bepsi:"\u03F6",bernou:"\u212C",Bernoullis:"\u212C",Beta:"\u0392",beta:"\u03B2",beth:"\u2136",between:"\u226C",Bfr:"\u{1D505}",bfr:"\u{1D51F}",bigcap:"\u22C2",bigcirc:"\u25EF",bigcup:"\u22C3",bigodot:"\u2A00",bigoplus:"\u2A01",bigotimes:"\u2A02",bigsqcup:"\u2A06",bigstar:"\u2605",bigtriangledown:"\u25BD",bigtriangleup:"\u25B3",biguplus:"\u2A04",bigvee:"\u22C1",bigwedge:"\u22C0",bkarow:"\u290D",blacklozenge:"\u29EB",blacksquare:"\u25AA",blacktriangle:"\u25B4",blacktriangledown:"\u25BE",blacktriangleleft:"\u25C2",blacktriangleright:"\u25B8",blank:"\u2423",blk12:"\u2592",blk14:"\u2591",blk34:"\u2593",block:"\u2588",bne:"=\u20E5",bnequiv:"\u2261\u20E5",bNot:"\u2AED",bnot:"\u2310",Bopf:"\u{1D539}",bopf:"\u{1D553}",bot:"\u22A5",bottom:"\u22A5",bowtie:"\u22C8",boxbox:"\u29C9",boxDL:"\u2557",boxDl:"\u2556",boxdL:"\u2555",boxdl:"\u2510",boxDR:"\u2554",boxDr:"\u2553",boxdR:"\u2552",boxdr:"\u250C",boxH:"\u2550",boxh:"\u2500",boxHD:"\u2566",boxHd:"\u2564",boxhD:"\u2565",boxhd:"\u252C",boxHU:"\u2569",boxHu:"\u2567",boxhU:"\u2568",boxhu:"\u2534",boxminus:"\u229F",boxplus:"\u229E",boxtimes:"\u22A0",boxUL:"\u255D",boxUl:"\u255C",boxuL:"\u255B",boxul:"\u2518",boxUR:"\u255A",boxUr:"\u2559",boxuR:"\u2558",boxur:"\u2514",boxV:"\u2551",boxv:"\u2502",boxVH:"\u256C",boxVh:"\u256B",boxvH:"\u256A",boxvh:"\u253C",boxVL:"\u2563",boxVl:"\u2562",boxvL:"\u2561",boxvl:"\u2524",boxVR:"\u2560",boxVr:"\u255F",boxvR:"\u255E",boxvr:"\u251C",bprime:"\u2035",Breve:"\u02D8",breve:"\u02D8",brvbar:"\xA6",Bscr:"\u212C",bscr:"\u{1D4B7}",bsemi:"\u204F",bsim:"\u223D",bsime:"\u22CD",bsol:"\\",bsolb:"\u29C5",bsolhsub:"\u27C8",bull:"\u2022",bullet:"\u2022",bump:"\u224E",bumpE:"\u2AAE",bumpe:"\u224F",Bumpeq:"\u224E",bumpeq:"\u224F",Cacute:"\u0106",cacute:"\u0107",Cap:"\u22D2",cap:"\u2229",capand:"\u2A44",capbrcup:"\u2A49",capcap:"\u2A4B",capcup:"\u2A47",capdot:"\u2A40",CapitalDifferentialD:"\u2145",caps:"\u2229\uFE00",caret:"\u2041",caron:"\u02C7",Cayleys:"\u212D",ccaps:"\u2A4D",Ccaron:"\u010C",ccaron:"\u010D",Ccedil:"\xC7",ccedil:"\xE7",Ccirc:"\u0108",ccirc:"\u0109",Cconint:"\u2230",ccups:"\u2A4C",ccupssm:"\u2A50",Cdot:"\u010A",cdot:"\u010B",cedil:"\xB8",Cedilla:"\xB8",cemptyv:"\u29B2",cent:"\xA2",CenterDot:"\xB7",centerdot:"\xB7",Cfr:"\u212D",cfr:"\u{1D520}",CHcy:"\u0427",chcy:"\u0447",check:"\u2713",checkmark:"\u2713",Chi:"\u03A7",chi:"\u03C7",cir:"\u25CB",circ:"\u02C6",circeq:"\u2257",circlearrowleft:"\u21BA",circlearrowright:"\u21BB",circledast:"\u229B",circledcirc:"\u229A",circleddash:"\u229D",CircleDot:"\u2299",circledR:"\xAE",circledS:"\u24C8",CircleMinus:"\u2296",CirclePlus:"\u2295",CircleTimes:"\u2297",cirE:"\u29C3",cire:"\u2257",cirfnint:"\u2A10",cirmid:"\u2AEF",cirscir:"\u29C2",ClockwiseContourIntegral:"\u2232",CloseCurlyDoubleQuote:"\u201D",CloseCurlyQuote:"\u2019",clubs:"\u2663",clubsuit:"\u2663",Colon:"\u2237",colon:":",Colone:"\u2A74",colone:"\u2254",coloneq:"\u2254",comma:",",commat:"@",comp:"\u2201",compfn:"\u2218",complement:"\u2201",complexes:"\u2102",cong:"\u2245",congdot:"\u2A6D",Congruent:"\u2261",Conint:"\u222F",conint:"\u222E",ContourIntegral:"\u222E",Copf:"\u2102",copf:"\u{1D554}",coprod:"\u2210",Coproduct:"\u2210",COPY:"\xA9",copy:"\xA9",copysr:"\u2117",CounterClockwiseContourIntegral:"\u2233",crarr:"\u21B5",Cross:"\u2A2F",cross:"\u2717",Cscr:"\u{1D49E}",cscr:"\u{1D4B8}",csub:"\u2ACF",csube:"\u2AD1",csup:"\u2AD0",csupe:"\u2AD2",ctdot:"\u22EF",cudarrl:"\u2938",cudarrr:"\u2935",cuepr:"\u22DE",cuesc:"\u22DF",cularr:"\u21B6",cularrp:"\u293D",Cup:"\u22D3",cup:"\u222A",cupbrcap:"\u2A48",CupCap:"\u224D",cupcap:"\u2A46",cupcup:"\u2A4A",cupdot:"\u228D",cupor:"\u2A45",cups:"\u222A\uFE00",curarr:"\u21B7",curarrm:"\u293C",curlyeqprec:"\u22DE",curlyeqsucc:"\u22DF",curlyvee:"\u22CE",curlywedge:"\u22CF",curren:"\xA4",curvearrowleft:"\u21B6",curvearrowright:"\u21B7",cuvee:"\u22CE",cuwed:"\u22CF",cwconint:"\u2232",cwint:"\u2231",cylcty:"\u232D",Dagger:"\u2021",dagger:"\u2020",daleth:"\u2138",Darr:"\u21A1",dArr:"\u21D3",darr:"\u2193",dash:"\u2010",Dashv:"\u2AE4",dashv:"\u22A3",dbkarow:"\u290F",dblac:"\u02DD",Dcaron:"\u010E",dcaron:"\u010F",Dcy:"\u0414",dcy:"\u0434",DD:"\u2145",dd:"\u2146",ddagger:"\u2021",ddarr:"\u21CA",DDotrahd:"\u2911",ddotseq:"\u2A77",deg:"\xB0",Del:"\u2207",Delta:"\u0394",delta:"\u03B4",demptyv:"\u29B1",dfisht:"\u297F",Dfr:"\u{1D507}",dfr:"\u{1D521}",dHar:"\u2965",dharl:"\u21C3",dharr:"\u21C2",DiacriticalAcute:"\xB4",DiacriticalDot:"\u02D9",DiacriticalDoubleAcute:"\u02DD",DiacriticalGrave:"`",DiacriticalTilde:"\u02DC",diam:"\u22C4",Diamond:"\u22C4",diamond:"\u22C4",diamondsuit:"\u2666",diams:"\u2666",die:"\xA8",DifferentialD:"\u2146",digamma:"\u03DD",disin:"\u22F2",div:"\xF7",divide:"\xF7",divideontimes:"\u22C7",divonx:"\u22C7",DJcy:"\u0402",djcy:"\u0452",dlcorn:"\u231E",dlcrop:"\u230D",dollar:"$",Dopf:"\u{1D53B}",dopf:"\u{1D555}",Dot:"\xA8",dot:"\u02D9",DotDot:"\u20DC",doteq:"\u2250",doteqdot:"\u2251",DotEqual:"\u2250",dotminus:"\u2238",dotplus:"\u2214",dotsquare:"\u22A1",doublebarwedge:"\u2306",DoubleContourIntegral:"\u222F",DoubleDot:"\xA8",DoubleDownArrow:"\u21D3",DoubleLeftArrow:"\u21D0",DoubleLeftRightArrow:"\u21D4",DoubleLeftTee:"\u2AE4",DoubleLongLeftArrow:"\u27F8",DoubleLongLeftRightArrow:"\u27FA",DoubleLongRightArrow:"\u27F9",DoubleRightArrow:"\u21D2",DoubleRightTee:"\u22A8",DoubleUpArrow:"\u21D1",DoubleUpDownArrow:"\u21D5",DoubleVerticalBar:"\u2225",DownArrow:"\u2193",Downarrow:"\u21D3",downarrow:"\u2193",DownArrowBar:"\u2913",DownArrowUpArrow:"\u21F5",DownBreve:"\u0311",downdownarrows:"\u21CA",downharpoonleft:"\u21C3",downharpoonright:"\u21C2",DownLeftRightVector:"\u2950",DownLeftTeeVector:"\u295E",DownLeftVector:"\u21BD",DownLeftVectorBar:"\u2956",DownRightTeeVector:"\u295F",DownRightVector:"\u21C1",DownRightVectorBar:"\u2957",DownTee:"\u22A4",DownTeeArrow:"\u21A7",drbkarow:"\u2910",drcorn:"\u231F",drcrop:"\u230C",Dscr:"\u{1D49F}",dscr:"\u{1D4B9}",DScy:"\u0405",dscy:"\u0455",dsol:"\u29F6",Dstrok:"\u0110",dstrok:"\u0111",dtdot:"\u22F1",dtri:"\u25BF",dtrif:"\u25BE",duarr:"\u21F5",duhar:"\u296F",dwangle:"\u29A6",DZcy:"\u040F",dzcy:"\u045F",dzigrarr:"\u27FF",Eacute:"\xC9",eacute:"\xE9",easter:"\u2A6E",Ecaron:"\u011A",ecaron:"\u011B",ecir:"\u2256",Ecirc:"\xCA",ecirc:"\xEA",ecolon:"\u2255",Ecy:"\u042D",ecy:"\u044D",eDDot:"\u2A77",Edot:"\u0116",eDot:"\u2251",edot:"\u0117",ee:"\u2147",efDot:"\u2252",Efr:"\u{1D508}",efr:"\u{1D522}",eg:"\u2A9A",Egrave:"\xC8",egrave:"\xE8",egs:"\u2A96",egsdot:"\u2A98",el:"\u2A99",Element:"\u2208",elinters:"\u23E7",ell:"\u2113",els:"\u2A95",elsdot:"\u2A97",Emacr:"\u0112",emacr:"\u0113",empty:"\u2205",emptyset:"\u2205",EmptySmallSquare:"\u25FB",emptyv:"\u2205",EmptyVerySmallSquare:"\u25AB",emsp:"\u2003",emsp13:"\u2004",emsp14:"\u2005",ENG:"\u014A",eng:"\u014B",ensp:"\u2002",Eogon:"\u0118",eogon:"\u0119",Eopf:"\u{1D53C}",eopf:"\u{1D556}",epar:"\u22D5",eparsl:"\u29E3",eplus:"\u2A71",epsi:"\u03B5",Epsilon:"\u0395",epsilon:"\u03B5",epsiv:"\u03F5",eqcirc:"\u2256",eqcolon:"\u2255",eqsim:"\u2242",eqslantgtr:"\u2A96",eqslantless:"\u2A95",Equal:"\u2A75",equals:"=",EqualTilde:"\u2242",equest:"\u225F",Equilibrium:"\u21CC",equiv:"\u2261",equivDD:"\u2A78",eqvparsl:"\u29E5",erarr:"\u2971",erDot:"\u2253",Escr:"\u2130",escr:"\u212F",esdot:"\u2250",Esim:"\u2A73",esim:"\u2242",Eta:"\u0397",eta:"\u03B7",ETH:"\xD0",eth:"\xF0",Euml:"\xCB",euml:"\xEB",euro:"\u20AC",excl:"!",exist:"\u2203",Exists:"\u2203",expectation:"\u2130",ExponentialE:"\u2147",exponentiale:"\u2147",fallingdotseq:"\u2252",Fcy:"\u0424",fcy:"\u0444",female:"\u2640",ffilig:"\uFB03",fflig:"\uFB00",ffllig:"\uFB04",Ffr:"\u{1D509}",ffr:"\u{1D523}",filig:"\uFB01",FilledSmallSquare:"\u25FC",FilledVerySmallSquare:"\u25AA",fjlig:"fj",flat:"\u266D",fllig:"\uFB02",fltns:"\u25B1",fnof:"\u0192",Fopf:"\u{1D53D}",fopf:"\u{1D557}",ForAll:"\u2200",forall:"\u2200",fork:"\u22D4",forkv:"\u2AD9",Fouriertrf:"\u2131",fpartint:"\u2A0D",frac12:"\xBD",frac13:"\u2153",frac14:"\xBC",frac15:"\u2155",frac16:"\u2159",frac18:"\u215B",frac23:"\u2154",frac25:"\u2156",frac34:"\xBE",frac35:"\u2157",frac38:"\u215C",frac45:"\u2158",frac56:"\u215A",frac58:"\u215D",frac78:"\u215E",frasl:"\u2044",frown:"\u2322",Fscr:"\u2131",fscr:"\u{1D4BB}",gacute:"\u01F5",Gamma:"\u0393",gamma:"\u03B3",Gammad:"\u03DC",gammad:"\u03DD",gap:"\u2A86",Gbreve:"\u011E",gbreve:"\u011F",Gcedil:"\u0122",Gcirc:"\u011C",gcirc:"\u011D",Gcy:"\u0413",gcy:"\u0433",Gdot:"\u0120",gdot:"\u0121",gE:"\u2267",ge:"\u2265",gEl:"\u2A8C",gel:"\u22DB",geq:"\u2265",geqq:"\u2267",geqslant:"\u2A7E",ges:"\u2A7E",gescc:"\u2AA9",gesdot:"\u2A80",gesdoto:"\u2A82",gesdotol:"\u2A84",gesl:"\u22DB\uFE00",gesles:"\u2A94",Gfr:"\u{1D50A}",gfr:"\u{1D524}",Gg:"\u22D9",gg:"\u226B",ggg:"\u22D9",gimel:"\u2137",GJcy:"\u0403",gjcy:"\u0453",gl:"\u2277",gla:"\u2AA5",glE:"\u2A92",glj:"\u2AA4",gnap:"\u2A8A",gnapprox:"\u2A8A",gnE:"\u2269",gne:"\u2A88",gneq:"\u2A88",gneqq:"\u2269",gnsim:"\u22E7",Gopf:"\u{1D53E}",gopf:"\u{1D558}",grave:"`",GreaterEqual:"\u2265",GreaterEqualLess:"\u22DB",GreaterFullEqual:"\u2267",GreaterGreater:"\u2AA2",GreaterLess:"\u2277",GreaterSlantEqual:"\u2A7E",GreaterTilde:"\u2273",Gscr:"\u{1D4A2}",gscr:"\u210A",gsim:"\u2273",gsime:"\u2A8E",gsiml:"\u2A90",Gt:"\u226B",GT:">",gt:">",gtcc:"\u2AA7",gtcir:"\u2A7A",gtdot:"\u22D7",gtlPar:"\u2995",gtquest:"\u2A7C",gtrapprox:"\u2A86",gtrarr:"\u2978",gtrdot:"\u22D7",gtreqless:"\u22DB",gtreqqless:"\u2A8C",gtrless:"\u2277",gtrsim:"\u2273",gvertneqq:"\u2269\uFE00",gvnE:"\u2269\uFE00",Hacek:"\u02C7",hairsp:"\u200A",half:"\xBD",hamilt:"\u210B",HARDcy:"\u042A",hardcy:"\u044A",hArr:"\u21D4",harr:"\u2194",harrcir:"\u2948",harrw:"\u21AD",Hat:"^",hbar:"\u210F",Hcirc:"\u0124",hcirc:"\u0125",hearts:"\u2665",heartsuit:"\u2665",hellip:"\u2026",hercon:"\u22B9",Hfr:"\u210C",hfr:"\u{1D525}",HilbertSpace:"\u210B",hksearow:"\u2925",hkswarow:"\u2926",hoarr:"\u21FF",homtht:"\u223B",hookleftarrow:"\u21A9",hookrightarrow:"\u21AA",Hopf:"\u210D",hopf:"\u{1D559}",horbar:"\u2015",HorizontalLine:"\u2500",Hscr:"\u210B",hscr:"\u{1D4BD}",hslash:"\u210F",Hstrok:"\u0126",hstrok:"\u0127",HumpDownHump:"\u224E",HumpEqual:"\u224F",hybull:"\u2043",hyphen:"\u2010",Iacute:"\xCD",iacute:"\xED",ic:"\u2063",Icirc:"\xCE",icirc:"\xEE",Icy:"\u0418",icy:"\u0438",Idot:"\u0130",IEcy:"\u0415",iecy:"\u0435",iexcl:"\xA1",iff:"\u21D4",Ifr:"\u2111",ifr:"\u{1D526}",Igrave:"\xCC",igrave:"\xEC",ii:"\u2148",iiiint:"\u2A0C",iiint:"\u222D",iinfin:"\u29DC",iiota:"\u2129",IJlig:"\u0132",ijlig:"\u0133",Im:"\u2111",Imacr:"\u012A",imacr:"\u012B",image:"\u2111",ImaginaryI:"\u2148",imagline:"\u2110",imagpart:"\u2111",imath:"\u0131",imof:"\u22B7",imped:"\u01B5",Implies:"\u21D2",in:"\u2208",incare:"\u2105",infin:"\u221E",infintie:"\u29DD",inodot:"\u0131",Int:"\u222C",int:"\u222B",intcal:"\u22BA",integers:"\u2124",Integral:"\u222B",intercal:"\u22BA",Intersection:"\u22C2",intlarhk:"\u2A17",intprod:"\u2A3C",InvisibleComma:"\u2063",InvisibleTimes:"\u2062",IOcy:"\u0401",iocy:"\u0451",Iogon:"\u012E",iogon:"\u012F",Iopf:"\u{1D540}",iopf:"\u{1D55A}",Iota:"\u0399",iota:"\u03B9",iprod:"\u2A3C",iquest:"\xBF",Iscr:"\u2110",iscr:"\u{1D4BE}",isin:"\u2208",isindot:"\u22F5",isinE:"\u22F9",isins:"\u22F4",isinsv:"\u22F3",isinv:"\u2208",it:"\u2062",Itilde:"\u0128",itilde:"\u0129",Iukcy:"\u0406",iukcy:"\u0456",Iuml:"\xCF",iuml:"\xEF",Jcirc:"\u0134",jcirc:"\u0135",Jcy:"\u0419",jcy:"\u0439",Jfr:"\u{1D50D}",jfr:"\u{1D527}",jmath:"\u0237",Jopf:"\u{1D541}",jopf:"\u{1D55B}",Jscr:"\u{1D4A5}",jscr:"\u{1D4BF}",Jsercy:"\u0408",jsercy:"\u0458",Jukcy:"\u0404",jukcy:"\u0454",Kappa:"\u039A",kappa:"\u03BA",kappav:"\u03F0",Kcedil:"\u0136",kcedil:"\u0137",Kcy:"\u041A",kcy:"\u043A",Kfr:"\u{1D50E}",kfr:"\u{1D528}",kgreen:"\u0138",KHcy:"\u0425",khcy:"\u0445",KJcy:"\u040C",kjcy:"\u045C",Kopf:"\u{1D542}",kopf:"\u{1D55C}",Kscr:"\u{1D4A6}",kscr:"\u{1D4C0}",lAarr:"\u21DA",Lacute:"\u0139",lacute:"\u013A",laemptyv:"\u29B4",lagran:"\u2112",Lambda:"\u039B",lambda:"\u03BB",Lang:"\u27EA",lang:"\u27E8",langd:"\u2991",langle:"\u27E8",lap:"\u2A85",Laplacetrf:"\u2112",laquo:"\xAB",Larr:"\u219E",lArr:"\u21D0",larr:"\u2190",larrb:"\u21E4",larrbfs:"\u291F",larrfs:"\u291D",larrhk:"\u21A9",larrlp:"\u21AB",larrpl:"\u2939",larrsim:"\u2973",larrtl:"\u21A2",lat:"\u2AAB",lAtail:"\u291B",latail:"\u2919",late:"\u2AAD",lates:"\u2AAD\uFE00",lBarr:"\u290E",lbarr:"\u290C",lbbrk:"\u2772",lbrace:"{",lbrack:"[",lbrke:"\u298B",lbrksld:"\u298F",lbrkslu:"\u298D",Lcaron:"\u013D",lcaron:"\u013E",Lcedil:"\u013B",lcedil:"\u013C",lceil:"\u2308",lcub:"{",Lcy:"\u041B",lcy:"\u043B",ldca:"\u2936",ldquo:"\u201C",ldquor:"\u201E",ldrdhar:"\u2967",ldrushar:"\u294B",ldsh:"\u21B2",lE:"\u2266",le:"\u2264",LeftAngleBracket:"\u27E8",LeftArrow:"\u2190",Leftarrow:"\u21D0",leftarrow:"\u2190",LeftArrowBar:"\u21E4",LeftArrowRightArrow:"\u21C6",leftarrowtail:"\u21A2",LeftCeiling:"\u2308",LeftDoubleBracket:"\u27E6",LeftDownTeeVector:"\u2961",LeftDownVector:"\u21C3",LeftDownVectorBar:"\u2959",LeftFloor:"\u230A",leftharpoondown:"\u21BD",leftharpoonup:"\u21BC",leftleftarrows:"\u21C7",LeftRightArrow:"\u2194",Leftrightarrow:"\u21D4",leftrightarrow:"\u2194",leftrightarrows:"\u21C6",leftrightharpoons:"\u21CB",leftrightsquigarrow:"\u21AD",LeftRightVector:"\u294E",LeftTee:"\u22A3",LeftTeeArrow:"\u21A4",LeftTeeVector:"\u295A",leftthreetimes:"\u22CB",LeftTriangle:"\u22B2",LeftTriangleBar:"\u29CF",LeftTriangleEqual:"\u22B4",LeftUpDownVector:"\u2951",LeftUpTeeVector:"\u2960",LeftUpVector:"\u21BF",LeftUpVectorBar:"\u2958",LeftVector:"\u21BC",LeftVectorBar:"\u2952",lEg:"\u2A8B",leg:"\u22DA",leq:"\u2264",leqq:"\u2266",leqslant:"\u2A7D",les:"\u2A7D",lescc:"\u2AA8",lesdot:"\u2A7F",lesdoto:"\u2A81",lesdotor:"\u2A83",lesg:"\u22DA\uFE00",lesges:"\u2A93",lessapprox:"\u2A85",lessdot:"\u22D6",lesseqgtr:"\u22DA",lesseqqgtr:"\u2A8B",LessEqualGreater:"\u22DA",LessFullEqual:"\u2266",LessGreater:"\u2276",lessgtr:"\u2276",LessLess:"\u2AA1",lesssim:"\u2272",LessSlantEqual:"\u2A7D",LessTilde:"\u2272",lfisht:"\u297C",lfloor:"\u230A",Lfr:"\u{1D50F}",lfr:"\u{1D529}",lg:"\u2276",lgE:"\u2A91",lHar:"\u2962",lhard:"\u21BD",lharu:"\u21BC",lharul:"\u296A",lhblk:"\u2584",LJcy:"\u0409",ljcy:"\u0459",Ll:"\u22D8",ll:"\u226A",llarr:"\u21C7",llcorner:"\u231E",Lleftarrow:"\u21DA",llhard:"\u296B",lltri:"\u25FA",Lmidot:"\u013F",lmidot:"\u0140",lmoust:"\u23B0",lmoustache:"\u23B0",lnap:"\u2A89",lnapprox:"\u2A89",lnE:"\u2268",lne:"\u2A87",lneq:"\u2A87",lneqq:"\u2268",lnsim:"\u22E6",loang:"\u27EC",loarr:"\u21FD",lobrk:"\u27E6",LongLeftArrow:"\u27F5",Longleftarrow:"\u27F8",longleftarrow:"\u27F5",LongLeftRightArrow:"\u27F7",Longleftrightarrow:"\u27FA",longleftrightarrow:"\u27F7",longmapsto:"\u27FC",LongRightArrow:"\u27F6",Longrightarrow:"\u27F9",longrightarrow:"\u27F6",looparrowleft:"\u21AB",looparrowright:"\u21AC",lopar:"\u2985",Lopf:"\u{1D543}",lopf:"\u{1D55D}",loplus:"\u2A2D",lotimes:"\u2A34",lowast:"\u2217",lowbar:"_",LowerLeftArrow:"\u2199",LowerRightArrow:"\u2198",loz:"\u25CA",lozenge:"\u25CA",lozf:"\u29EB",lpar:"(",lparlt:"\u2993",lrarr:"\u21C6",lrcorner:"\u231F",lrhar:"\u21CB",lrhard:"\u296D",lrm:"\u200E",lrtri:"\u22BF",lsaquo:"\u2039",Lscr:"\u2112",lscr:"\u{1D4C1}",Lsh:"\u21B0",lsh:"\u21B0",lsim:"\u2272",lsime:"\u2A8D",lsimg:"\u2A8F",lsqb:"[",lsquo:"\u2018",lsquor:"\u201A",Lstrok:"\u0141",lstrok:"\u0142",Lt:"\u226A",LT:"<",lt:"<",ltcc:"\u2AA6",ltcir:"\u2A79",ltdot:"\u22D6",lthree:"\u22CB",ltimes:"\u22C9",ltlarr:"\u2976",ltquest:"\u2A7B",ltri:"\u25C3",ltrie:"\u22B4",ltrif:"\u25C2",ltrPar:"\u2996",lurdshar:"\u294A",luruhar:"\u2966",lvertneqq:"\u2268\uFE00",lvnE:"\u2268\uFE00",macr:"\xAF",male:"\u2642",malt:"\u2720",maltese:"\u2720",Map:"\u2905",map:"\u21A6",mapsto:"\u21A6",mapstodown:"\u21A7",mapstoleft:"\u21A4",mapstoup:"\u21A5",marker:"\u25AE",mcomma:"\u2A29",Mcy:"\u041C",mcy:"\u043C",mdash:"\u2014",mDDot:"\u223A",measuredangle:"\u2221",MediumSpace:"\u205F",Mellintrf:"\u2133",Mfr:"\u{1D510}",mfr:"\u{1D52A}",mho:"\u2127",micro:"\xB5",mid:"\u2223",midast:"*",midcir:"\u2AF0",middot:"\xB7",minus:"\u2212",minusb:"\u229F",minusd:"\u2238",minusdu:"\u2A2A",MinusPlus:"\u2213",mlcp:"\u2ADB",mldr:"\u2026",mnplus:"\u2213",models:"\u22A7",Mopf:"\u{1D544}",mopf:"\u{1D55E}",mp:"\u2213",Mscr:"\u2133",mscr:"\u{1D4C2}",mstpos:"\u223E",Mu:"\u039C",mu:"\u03BC",multimap:"\u22B8",mumap:"\u22B8",nabla:"\u2207",Nacute:"\u0143",nacute:"\u0144",nang:"\u2220\u20D2",nap:"\u2249",napE:"\u2A70\u0338",napid:"\u224B\u0338",napos:"\u0149",napprox:"\u2249",natur:"\u266E",natural:"\u266E",naturals:"\u2115",nbsp:"\xA0",nbump:"\u224E\u0338",nbumpe:"\u224F\u0338",ncap:"\u2A43",Ncaron:"\u0147",ncaron:"\u0148",Ncedil:"\u0145",ncedil:"\u0146",ncong:"\u2247",ncongdot:"\u2A6D\u0338",ncup:"\u2A42",Ncy:"\u041D",ncy:"\u043D",ndash:"\u2013",ne:"\u2260",nearhk:"\u2924",neArr:"\u21D7",nearr:"\u2197",nearrow:"\u2197",nedot:"\u2250\u0338",NegativeMediumSpace:"\u200B",NegativeThickSpace:"\u200B",NegativeThinSpace:"\u200B",NegativeVeryThinSpace:"\u200B",nequiv:"\u2262",nesear:"\u2928",nesim:"\u2242\u0338",NestedGreaterGreater:"\u226B",NestedLessLess:"\u226A",NewLine:`
`,nexist:"\u2204",nexists:"\u2204",Nfr:"\u{1D511}",nfr:"\u{1D52B}",ngE:"\u2267\u0338",nge:"\u2271",ngeq:"\u2271",ngeqq:"\u2267\u0338",ngeqslant:"\u2A7E\u0338",nges:"\u2A7E\u0338",nGg:"\u22D9\u0338",ngsim:"\u2275",nGt:"\u226B\u20D2",ngt:"\u226F",ngtr:"\u226F",nGtv:"\u226B\u0338",nhArr:"\u21CE",nharr:"\u21AE",nhpar:"\u2AF2",ni:"\u220B",nis:"\u22FC",nisd:"\u22FA",niv:"\u220B",NJcy:"\u040A",njcy:"\u045A",nlArr:"\u21CD",nlarr:"\u219A",nldr:"\u2025",nlE:"\u2266\u0338",nle:"\u2270",nLeftarrow:"\u21CD",nleftarrow:"\u219A",nLeftrightarrow:"\u21CE",nleftrightarrow:"\u21AE",nleq:"\u2270",nleqq:"\u2266\u0338",nleqslant:"\u2A7D\u0338",nles:"\u2A7D\u0338",nless:"\u226E",nLl:"\u22D8\u0338",nlsim:"\u2274",nLt:"\u226A\u20D2",nlt:"\u226E",nltri:"\u22EA",nltrie:"\u22EC",nLtv:"\u226A\u0338",nmid:"\u2224",NoBreak:"\u2060",NonBreakingSpace:"\xA0",Nopf:"\u2115",nopf:"\u{1D55F}",Not:"\u2AEC",not:"\xAC",NotCongruent:"\u2262",NotCupCap:"\u226D",NotDoubleVerticalBar:"\u2226",NotElement:"\u2209",NotEqual:"\u2260",NotEqualTilde:"\u2242\u0338",NotExists:"\u2204",NotGreater:"\u226F",NotGreaterEqual:"\u2271",NotGreaterFullEqual:"\u2267\u0338",NotGreaterGreater:"\u226B\u0338",NotGreaterLess:"\u2279",NotGreaterSlantEqual:"\u2A7E\u0338",NotGreaterTilde:"\u2275",NotHumpDownHump:"\u224E\u0338",NotHumpEqual:"\u224F\u0338",notin:"\u2209",notindot:"\u22F5\u0338",notinE:"\u22F9\u0338",notinva:"\u2209",notinvb:"\u22F7",notinvc:"\u22F6",NotLeftTriangle:"\u22EA",NotLeftTriangleBar:"\u29CF\u0338",NotLeftTriangleEqual:"\u22EC",NotLess:"\u226E",NotLessEqual:"\u2270",NotLessGreater:"\u2278",NotLessLess:"\u226A\u0338",NotLessSlantEqual:"\u2A7D\u0338",NotLessTilde:"\u2274",NotNestedGreaterGreater:"\u2AA2\u0338",NotNestedLessLess:"\u2AA1\u0338",notni:"\u220C",notniva:"\u220C",notnivb:"\u22FE",notnivc:"\u22FD",NotPrecedes:"\u2280",NotPrecedesEqual:"\u2AAF\u0338",NotPrecedesSlantEqual:"\u22E0",NotReverseElement:"\u220C",NotRightTriangle:"\u22EB",NotRightTriangleBar:"\u29D0\u0338",NotRightTriangleEqual:"\u22ED",NotSquareSubset:"\u228F\u0338",NotSquareSubsetEqual:"\u22E2",NotSquareSuperset:"\u2290\u0338",NotSquareSupersetEqual:"\u22E3",NotSubset:"\u2282\u20D2",NotSubsetEqual:"\u2288",NotSucceeds:"\u2281",NotSucceedsEqual:"\u2AB0\u0338",NotSucceedsSlantEqual:"\u22E1",NotSucceedsTilde:"\u227F\u0338",NotSuperset:"\u2283\u20D2",NotSupersetEqual:"\u2289",NotTilde:"\u2241",NotTildeEqual:"\u2244",NotTildeFullEqual:"\u2247",NotTildeTilde:"\u2249",NotVerticalBar:"\u2224",npar:"\u2226",nparallel:"\u2226",nparsl:"\u2AFD\u20E5",npart:"\u2202\u0338",npolint:"\u2A14",npr:"\u2280",nprcue:"\u22E0",npre:"\u2AAF\u0338",nprec:"\u2280",npreceq:"\u2AAF\u0338",nrArr:"\u21CF",nrarr:"\u219B",nrarrc:"\u2933\u0338",nrarrw:"\u219D\u0338",nRightarrow:"\u21CF",nrightarrow:"\u219B",nrtri:"\u22EB",nrtrie:"\u22ED",nsc:"\u2281",nsccue:"\u22E1",nsce:"\u2AB0\u0338",Nscr:"\u{1D4A9}",nscr:"\u{1D4C3}",nshortmid:"\u2224",nshortparallel:"\u2226",nsim:"\u2241",nsime:"\u2244",nsimeq:"\u2244",nsmid:"\u2224",nspar:"\u2226",nsqsube:"\u22E2",nsqsupe:"\u22E3",nsub:"\u2284",nsubE:"\u2AC5\u0338",nsube:"\u2288",nsubset:"\u2282\u20D2",nsubseteq:"\u2288",nsubseteqq:"\u2AC5\u0338",nsucc:"\u2281",nsucceq:"\u2AB0\u0338",nsup:"\u2285",nsupE:"\u2AC6\u0338",nsupe:"\u2289",nsupset:"\u2283\u20D2",nsupseteq:"\u2289",nsupseteqq:"\u2AC6\u0338",ntgl:"\u2279",Ntilde:"\xD1",ntilde:"\xF1",ntlg:"\u2278",ntriangleleft:"\u22EA",ntrianglelefteq:"\u22EC",ntriangleright:"\u22EB",ntrianglerighteq:"\u22ED",Nu:"\u039D",nu:"\u03BD",num:"#",numero:"\u2116",numsp:"\u2007",nvap:"\u224D\u20D2",nVDash:"\u22AF",nVdash:"\u22AE",nvDash:"\u22AD",nvdash:"\u22AC",nvge:"\u2265\u20D2",nvgt:">\u20D2",nvHarr:"\u2904",nvinfin:"\u29DE",nvlArr:"\u2902",nvle:"\u2264\u20D2",nvlt:"<\u20D2",nvltrie:"\u22B4\u20D2",nvrArr:"\u2903",nvrtrie:"\u22B5\u20D2",nvsim:"\u223C\u20D2",nwarhk:"\u2923",nwArr:"\u21D6",nwarr:"\u2196",nwarrow:"\u2196",nwnear:"\u2927",Oacute:"\xD3",oacute:"\xF3",oast:"\u229B",ocir:"\u229A",Ocirc:"\xD4",ocirc:"\xF4",Ocy:"\u041E",ocy:"\u043E",odash:"\u229D",Odblac:"\u0150",odblac:"\u0151",odiv:"\u2A38",odot:"\u2299",odsold:"\u29BC",OElig:"\u0152",oelig:"\u0153",ofcir:"\u29BF",Ofr:"\u{1D512}",ofr:"\u{1D52C}",ogon:"\u02DB",Ograve:"\xD2",ograve:"\xF2",ogt:"\u29C1",ohbar:"\u29B5",ohm:"\u03A9",oint:"\u222E",olarr:"\u21BA",olcir:"\u29BE",olcross:"\u29BB",oline:"\u203E",olt:"\u29C0",Omacr:"\u014C",omacr:"\u014D",Omega:"\u03A9",omega:"\u03C9",Omicron:"\u039F",omicron:"\u03BF",omid:"\u29B6",ominus:"\u2296",Oopf:"\u{1D546}",oopf:"\u{1D560}",opar:"\u29B7",OpenCurlyDoubleQuote:"\u201C",OpenCurlyQuote:"\u2018",operp:"\u29B9",oplus:"\u2295",Or:"\u2A54",or:"\u2228",orarr:"\u21BB",ord:"\u2A5D",order:"\u2134",orderof:"\u2134",ordf:"\xAA",ordm:"\xBA",origof:"\u22B6",oror:"\u2A56",orslope:"\u2A57",orv:"\u2A5B",oS:"\u24C8",Oscr:"\u{1D4AA}",oscr:"\u2134",Oslash:"\xD8",oslash:"\xF8",osol:"\u2298",Otilde:"\xD5",otilde:"\xF5",Otimes:"\u2A37",otimes:"\u2297",otimesas:"\u2A36",Ouml:"\xD6",ouml:"\xF6",ovbar:"\u233D",OverBar:"\u203E",OverBrace:"\u23DE",OverBracket:"\u23B4",OverParenthesis:"\u23DC",par:"\u2225",para:"\xB6",parallel:"\u2225",parsim:"\u2AF3",parsl:"\u2AFD",part:"\u2202",PartialD:"\u2202",Pcy:"\u041F",pcy:"\u043F",percnt:"%",period:".",permil:"\u2030",perp:"\u22A5",pertenk:"\u2031",Pfr:"\u{1D513}",pfr:"\u{1D52D}",Phi:"\u03A6",phi:"\u03C6",phiv:"\u03D5",phmmat:"\u2133",phone:"\u260E",Pi:"\u03A0",pi:"\u03C0",pitchfork:"\u22D4",piv:"\u03D6",planck:"\u210F",planckh:"\u210E",plankv:"\u210F",plus:"+",plusacir:"\u2A23",plusb:"\u229E",pluscir:"\u2A22",plusdo:"\u2214",plusdu:"\u2A25",pluse:"\u2A72",PlusMinus:"\xB1",plusmn:"\xB1",plussim:"\u2A26",plustwo:"\u2A27",pm:"\xB1",Poincareplane:"\u210C",pointint:"\u2A15",Popf:"\u2119",popf:"\u{1D561}",pound:"\xA3",Pr:"\u2ABB",pr:"\u227A",prap:"\u2AB7",prcue:"\u227C",prE:"\u2AB3",pre:"\u2AAF",prec:"\u227A",precapprox:"\u2AB7",preccurlyeq:"\u227C",Precedes:"\u227A",PrecedesEqual:"\u2AAF",PrecedesSlantEqual:"\u227C",PrecedesTilde:"\u227E",preceq:"\u2AAF",precnapprox:"\u2AB9",precneqq:"\u2AB5",precnsim:"\u22E8",precsim:"\u227E",Prime:"\u2033",prime:"\u2032",primes:"\u2119",prnap:"\u2AB9",prnE:"\u2AB5",prnsim:"\u22E8",prod:"\u220F",Product:"\u220F",profalar:"\u232E",profline:"\u2312",profsurf:"\u2313",prop:"\u221D",Proportion:"\u2237",Proportional:"\u221D",propto:"\u221D",prsim:"\u227E",prurel:"\u22B0",Pscr:"\u{1D4AB}",pscr:"\u{1D4C5}",Psi:"\u03A8",psi:"\u03C8",puncsp:"\u2008",Qfr:"\u{1D514}",qfr:"\u{1D52E}",qint:"\u2A0C",Qopf:"\u211A",qopf:"\u{1D562}",qprime:"\u2057",Qscr:"\u{1D4AC}",qscr:"\u{1D4C6}",quaternions:"\u210D",quatint:"\u2A16",quest:"?",questeq:"\u225F",QUOT:'"',quot:'"',rAarr:"\u21DB",race:"\u223D\u0331",Racute:"\u0154",racute:"\u0155",radic:"\u221A",raemptyv:"\u29B3",Rang:"\u27EB",rang:"\u27E9",rangd:"\u2992",range:"\u29A5",rangle:"\u27E9",raquo:"\xBB",Rarr:"\u21A0",rArr:"\u21D2",rarr:"\u2192",rarrap:"\u2975",rarrb:"\u21E5",rarrbfs:"\u2920",rarrc:"\u2933",rarrfs:"\u291E",rarrhk:"\u21AA",rarrlp:"\u21AC",rarrpl:"\u2945",rarrsim:"\u2974",Rarrtl:"\u2916",rarrtl:"\u21A3",rarrw:"\u219D",rAtail:"\u291C",ratail:"\u291A",ratio:"\u2236",rationals:"\u211A",RBarr:"\u2910",rBarr:"\u290F",rbarr:"\u290D",rbbrk:"\u2773",rbrace:"}",rbrack:"]",rbrke:"\u298C",rbrksld:"\u298E",rbrkslu:"\u2990",Rcaron:"\u0158",rcaron:"\u0159",Rcedil:"\u0156",rcedil:"\u0157",rceil:"\u2309",rcub:"}",Rcy:"\u0420",rcy:"\u0440",rdca:"\u2937",rdldhar:"\u2969",rdquo:"\u201D",rdquor:"\u201D",rdsh:"\u21B3",Re:"\u211C",real:"\u211C",realine:"\u211B",realpart:"\u211C",reals:"\u211D",rect:"\u25AD",REG:"\xAE",reg:"\xAE",ReverseElement:"\u220B",ReverseEquilibrium:"\u21CB",ReverseUpEquilibrium:"\u296F",rfisht:"\u297D",rfloor:"\u230B",Rfr:"\u211C",rfr:"\u{1D52F}",rHar:"\u2964",rhard:"\u21C1",rharu:"\u21C0",rharul:"\u296C",Rho:"\u03A1",rho:"\u03C1",rhov:"\u03F1",RightAngleBracket:"\u27E9",RightArrow:"\u2192",Rightarrow:"\u21D2",rightarrow:"\u2192",RightArrowBar:"\u21E5",RightArrowLeftArrow:"\u21C4",rightarrowtail:"\u21A3",RightCeiling:"\u2309",RightDoubleBracket:"\u27E7",RightDownTeeVector:"\u295D",RightDownVector:"\u21C2",RightDownVectorBar:"\u2955",RightFloor:"\u230B",rightharpoondown:"\u21C1",rightharpoonup:"\u21C0",rightleftarrows:"\u21C4",rightleftharpoons:"\u21CC",rightrightarrows:"\u21C9",rightsquigarrow:"\u219D",RightTee:"\u22A2",RightTeeArrow:"\u21A6",RightTeeVector:"\u295B",rightthreetimes:"\u22CC",RightTriangle:"\u22B3",RightTriangleBar:"\u29D0",RightTriangleEqual:"\u22B5",RightUpDownVector:"\u294F",RightUpTeeVector:"\u295C",RightUpVector:"\u21BE",RightUpVectorBar:"\u2954",RightVector:"\u21C0",RightVectorBar:"\u2953",ring:"\u02DA",risingdotseq:"\u2253",rlarr:"\u21C4",rlhar:"\u21CC",rlm:"\u200F",rmoust:"\u23B1",rmoustache:"\u23B1",rnmid:"\u2AEE",roang:"\u27ED",roarr:"\u21FE",robrk:"\u27E7",ropar:"\u2986",Ropf:"\u211D",ropf:"\u{1D563}",roplus:"\u2A2E",rotimes:"\u2A35",RoundImplies:"\u2970",rpar:")",rpargt:"\u2994",rppolint:"\u2A12",rrarr:"\u21C9",Rrightarrow:"\u21DB",rsaquo:"\u203A",Rscr:"\u211B",rscr:"\u{1D4C7}",Rsh:"\u21B1",rsh:"\u21B1",rsqb:"]",rsquo:"\u2019",rsquor:"\u2019",rthree:"\u22CC",rtimes:"\u22CA",rtri:"\u25B9",rtrie:"\u22B5",rtrif:"\u25B8",rtriltri:"\u29CE",RuleDelayed:"\u29F4",ruluhar:"\u2968",rx:"\u211E",Sacute:"\u015A",sacute:"\u015B",sbquo:"\u201A",Sc:"\u2ABC",sc:"\u227B",scap:"\u2AB8",Scaron:"\u0160",scaron:"\u0161",sccue:"\u227D",scE:"\u2AB4",sce:"\u2AB0",Scedil:"\u015E",scedil:"\u015F",Scirc:"\u015C",scirc:"\u015D",scnap:"\u2ABA",scnE:"\u2AB6",scnsim:"\u22E9",scpolint:"\u2A13",scsim:"\u227F",Scy:"\u0421",scy:"\u0441",sdot:"\u22C5",sdotb:"\u22A1",sdote:"\u2A66",searhk:"\u2925",seArr:"\u21D8",searr:"\u2198",searrow:"\u2198",sect:"\xA7",semi:";",seswar:"\u2929",setminus:"\u2216",setmn:"\u2216",sext:"\u2736",Sfr:"\u{1D516}",sfr:"\u{1D530}",sfrown:"\u2322",sharp:"\u266F",SHCHcy:"\u0429",shchcy:"\u0449",SHcy:"\u0428",shcy:"\u0448",ShortDownArrow:"\u2193",ShortLeftArrow:"\u2190",shortmid:"\u2223",shortparallel:"\u2225",ShortRightArrow:"\u2192",ShortUpArrow:"\u2191",shy:"\xAD",Sigma:"\u03A3",sigma:"\u03C3",sigmaf:"\u03C2",sigmav:"\u03C2",sim:"\u223C",simdot:"\u2A6A",sime:"\u2243",simeq:"\u2243",simg:"\u2A9E",simgE:"\u2AA0",siml:"\u2A9D",simlE:"\u2A9F",simne:"\u2246",simplus:"\u2A24",simrarr:"\u2972",slarr:"\u2190",SmallCircle:"\u2218",smallsetminus:"\u2216",smashp:"\u2A33",smeparsl:"\u29E4",smid:"\u2223",smile:"\u2323",smt:"\u2AAA",smte:"\u2AAC",smtes:"\u2AAC\uFE00",SOFTcy:"\u042C",softcy:"\u044C",sol:"/",solb:"\u29C4",solbar:"\u233F",Sopf:"\u{1D54A}",sopf:"\u{1D564}",spades:"\u2660",spadesuit:"\u2660",spar:"\u2225",sqcap:"\u2293",sqcaps:"\u2293\uFE00",sqcup:"\u2294",sqcups:"\u2294\uFE00",Sqrt:"\u221A",sqsub:"\u228F",sqsube:"\u2291",sqsubset:"\u228F",sqsubseteq:"\u2291",sqsup:"\u2290",sqsupe:"\u2292",sqsupset:"\u2290",sqsupseteq:"\u2292",squ:"\u25A1",Square:"\u25A1",square:"\u25A1",SquareIntersection:"\u2293",SquareSubset:"\u228F",SquareSubsetEqual:"\u2291",SquareSuperset:"\u2290",SquareSupersetEqual:"\u2292",SquareUnion:"\u2294",squarf:"\u25AA",squf:"\u25AA",srarr:"\u2192",Sscr:"\u{1D4AE}",sscr:"\u{1D4C8}",ssetmn:"\u2216",ssmile:"\u2323",sstarf:"\u22C6",Star:"\u22C6",star:"\u2606",starf:"\u2605",straightepsilon:"\u03F5",straightphi:"\u03D5",strns:"\xAF",Sub:"\u22D0",sub:"\u2282",subdot:"\u2ABD",subE:"\u2AC5",sube:"\u2286",subedot:"\u2AC3",submult:"\u2AC1",subnE:"\u2ACB",subne:"\u228A",subplus:"\u2ABF",subrarr:"\u2979",Subset:"\u22D0",subset:"\u2282",subseteq:"\u2286",subseteqq:"\u2AC5",SubsetEqual:"\u2286",subsetneq:"\u228A",subsetneqq:"\u2ACB",subsim:"\u2AC7",subsub:"\u2AD5",subsup:"\u2AD3",succ:"\u227B",succapprox:"\u2AB8",succcurlyeq:"\u227D",Succeeds:"\u227B",SucceedsEqual:"\u2AB0",SucceedsSlantEqual:"\u227D",SucceedsTilde:"\u227F",succeq:"\u2AB0",succnapprox:"\u2ABA",succneqq:"\u2AB6",succnsim:"\u22E9",succsim:"\u227F",SuchThat:"\u220B",Sum:"\u2211",sum:"\u2211",sung:"\u266A",Sup:"\u22D1",sup:"\u2283",sup1:"\xB9",sup2:"\xB2",sup3:"\xB3",supdot:"\u2ABE",supdsub:"\u2AD8",supE:"\u2AC6",supe:"\u2287",supedot:"\u2AC4",Superset:"\u2283",SupersetEqual:"\u2287",suphsol:"\u27C9",suphsub:"\u2AD7",suplarr:"\u297B",supmult:"\u2AC2",supnE:"\u2ACC",supne:"\u228B",supplus:"\u2AC0",Supset:"\u22D1",supset:"\u2283",supseteq:"\u2287",supseteqq:"\u2AC6",supsetneq:"\u228B",supsetneqq:"\u2ACC",supsim:"\u2AC8",supsub:"\u2AD4",supsup:"\u2AD6",swarhk:"\u2926",swArr:"\u21D9",swarr:"\u2199",swarrow:"\u2199",swnwar:"\u292A",szlig:"\xDF",Tab:"	",target:"\u2316",Tau:"\u03A4",tau:"\u03C4",tbrk:"\u23B4",Tcaron:"\u0164",tcaron:"\u0165",Tcedil:"\u0162",tcedil:"\u0163",Tcy:"\u0422",tcy:"\u0442",tdot:"\u20DB",telrec:"\u2315",Tfr:"\u{1D517}",tfr:"\u{1D531}",there4:"\u2234",Therefore:"\u2234",therefore:"\u2234",Theta:"\u0398",theta:"\u03B8",thetasym:"\u03D1",thetav:"\u03D1",thickapprox:"\u2248",thicksim:"\u223C",ThickSpace:"\u205F\u200A",thinsp:"\u2009",ThinSpace:"\u2009",thkap:"\u2248",thksim:"\u223C",THORN:"\xDE",thorn:"\xFE",Tilde:"\u223C",tilde:"\u02DC",TildeEqual:"\u2243",TildeFullEqual:"\u2245",TildeTilde:"\u2248",times:"\xD7",timesb:"\u22A0",timesbar:"\u2A31",timesd:"\u2A30",tint:"\u222D",toea:"\u2928",top:"\u22A4",topbot:"\u2336",topcir:"\u2AF1",Topf:"\u{1D54B}",topf:"\u{1D565}",topfork:"\u2ADA",tosa:"\u2929",tprime:"\u2034",TRADE:"\u2122",trade:"\u2122",triangle:"\u25B5",triangledown:"\u25BF",triangleleft:"\u25C3",trianglelefteq:"\u22B4",triangleq:"\u225C",triangleright:"\u25B9",trianglerighteq:"\u22B5",tridot:"\u25EC",trie:"\u225C",triminus:"\u2A3A",TripleDot:"\u20DB",triplus:"\u2A39",trisb:"\u29CD",tritime:"\u2A3B",trpezium:"\u23E2",Tscr:"\u{1D4AF}",tscr:"\u{1D4C9}",TScy:"\u0426",tscy:"\u0446",TSHcy:"\u040B",tshcy:"\u045B",Tstrok:"\u0166",tstrok:"\u0167",twixt:"\u226C",twoheadleftarrow:"\u219E",twoheadrightarrow:"\u21A0",Uacute:"\xDA",uacute:"\xFA",Uarr:"\u219F",uArr:"\u21D1",uarr:"\u2191",Uarrocir:"\u2949",Ubrcy:"\u040E",ubrcy:"\u045E",Ubreve:"\u016C",ubreve:"\u016D",Ucirc:"\xDB",ucirc:"\xFB",Ucy:"\u0423",ucy:"\u0443",udarr:"\u21C5",Udblac:"\u0170",udblac:"\u0171",udhar:"\u296E",ufisht:"\u297E",Ufr:"\u{1D518}",ufr:"\u{1D532}",Ugrave:"\xD9",ugrave:"\xF9",uHar:"\u2963",uharl:"\u21BF",uharr:"\u21BE",uhblk:"\u2580",ulcorn:"\u231C",ulcorner:"\u231C",ulcrop:"\u230F",ultri:"\u25F8",Umacr:"\u016A",umacr:"\u016B",uml:"\xA8",UnderBar:"_",UnderBrace:"\u23DF",UnderBracket:"\u23B5",UnderParenthesis:"\u23DD",Union:"\u22C3",UnionPlus:"\u228E",Uogon:"\u0172",uogon:"\u0173",Uopf:"\u{1D54C}",uopf:"\u{1D566}",UpArrow:"\u2191",Uparrow:"\u21D1",uparrow:"\u2191",UpArrowBar:"\u2912",UpArrowDownArrow:"\u21C5",UpDownArrow:"\u2195",Updownarrow:"\u21D5",updownarrow:"\u2195",UpEquilibrium:"\u296E",upharpoonleft:"\u21BF",upharpoonright:"\u21BE",uplus:"\u228E",UpperLeftArrow:"\u2196",UpperRightArrow:"\u2197",Upsi:"\u03D2",upsi:"\u03C5",upsih:"\u03D2",Upsilon:"\u03A5",upsilon:"\u03C5",UpTee:"\u22A5",UpTeeArrow:"\u21A5",upuparrows:"\u21C8",urcorn:"\u231D",urcorner:"\u231D",urcrop:"\u230E",Uring:"\u016E",uring:"\u016F",urtri:"\u25F9",Uscr:"\u{1D4B0}",uscr:"\u{1D4CA}",utdot:"\u22F0",Utilde:"\u0168",utilde:"\u0169",utri:"\u25B5",utrif:"\u25B4",uuarr:"\u21C8",Uuml:"\xDC",uuml:"\xFC",uwangle:"\u29A7",vangrt:"\u299C",varepsilon:"\u03F5",varkappa:"\u03F0",varnothing:"\u2205",varphi:"\u03D5",varpi:"\u03D6",varpropto:"\u221D",vArr:"\u21D5",varr:"\u2195",varrho:"\u03F1",varsigma:"\u03C2",varsubsetneq:"\u228A\uFE00",varsubsetneqq:"\u2ACB\uFE00",varsupsetneq:"\u228B\uFE00",varsupsetneqq:"\u2ACC\uFE00",vartheta:"\u03D1",vartriangleleft:"\u22B2",vartriangleright:"\u22B3",Vbar:"\u2AEB",vBar:"\u2AE8",vBarv:"\u2AE9",Vcy:"\u0412",vcy:"\u0432",VDash:"\u22AB",Vdash:"\u22A9",vDash:"\u22A8",vdash:"\u22A2",Vdashl:"\u2AE6",Vee:"\u22C1",vee:"\u2228",veebar:"\u22BB",veeeq:"\u225A",vellip:"\u22EE",Verbar:"\u2016",verbar:"|",Vert:"\u2016",vert:"|",VerticalBar:"\u2223",VerticalLine:"|",VerticalSeparator:"\u2758",VerticalTilde:"\u2240",VeryThinSpace:"\u200A",Vfr:"\u{1D519}",vfr:"\u{1D533}",vltri:"\u22B2",vnsub:"\u2282\u20D2",vnsup:"\u2283\u20D2",Vopf:"\u{1D54D}",vopf:"\u{1D567}",vprop:"\u221D",vrtri:"\u22B3",Vscr:"\u{1D4B1}",vscr:"\u{1D4CB}",vsubnE:"\u2ACB\uFE00",vsubne:"\u228A\uFE00",vsupnE:"\u2ACC\uFE00",vsupne:"\u228B\uFE00",Vvdash:"\u22AA",vzigzag:"\u299A",Wcirc:"\u0174",wcirc:"\u0175",wedbar:"\u2A5F",Wedge:"\u22C0",wedge:"\u2227",wedgeq:"\u2259",weierp:"\u2118",Wfr:"\u{1D51A}",wfr:"\u{1D534}",Wopf:"\u{1D54E}",wopf:"\u{1D568}",wp:"\u2118",wr:"\u2240",wreath:"\u2240",Wscr:"\u{1D4B2}",wscr:"\u{1D4CC}",xcap:"\u22C2",xcirc:"\u25EF",xcup:"\u22C3",xdtri:"\u25BD",Xfr:"\u{1D51B}",xfr:"\u{1D535}",xhArr:"\u27FA",xharr:"\u27F7",Xi:"\u039E",xi:"\u03BE",xlArr:"\u27F8",xlarr:"\u27F5",xmap:"\u27FC",xnis:"\u22FB",xodot:"\u2A00",Xopf:"\u{1D54F}",xopf:"\u{1D569}",xoplus:"\u2A01",xotime:"\u2A02",xrArr:"\u27F9",xrarr:"\u27F6",Xscr:"\u{1D4B3}",xscr:"\u{1D4CD}",xsqcup:"\u2A06",xuplus:"\u2A04",xutri:"\u25B3",xvee:"\u22C1",xwedge:"\u22C0",Yacute:"\xDD",yacute:"\xFD",YAcy:"\u042F",yacy:"\u044F",Ycirc:"\u0176",ycirc:"\u0177",Ycy:"\u042B",ycy:"\u044B",yen:"\xA5",Yfr:"\u{1D51C}",yfr:"\u{1D536}",YIcy:"\u0407",yicy:"\u0457",Yopf:"\u{1D550}",yopf:"\u{1D56A}",Yscr:"\u{1D4B4}",yscr:"\u{1D4CE}",YUcy:"\u042E",yucy:"\u044E",Yuml:"\u0178",yuml:"\xFF",Zacute:"\u0179",zacute:"\u017A",Zcaron:"\u017D",zcaron:"\u017E",Zcy:"\u0417",zcy:"\u0437",Zdot:"\u017B",zdot:"\u017C",zeetrf:"\u2128",ZeroWidthSpace:"\u200B",Zeta:"\u0396",zeta:"\u03B6",Zfr:"\u2128",zfr:"\u{1D537}",ZHcy:"\u0416",zhcy:"\u0436",zigrarr:"\u21DD",Zopf:"\u2124",zopf:"\u{1D56B}",Zscr:"\u{1D4B5}",zscr:"\u{1D4CF}",zwj:"\u200D",zwnj:"\u200C"}),X.entityMap=X.HTML_ENTITIES}),NAMESPACE$1=conventions.NAMESPACE,nameStartChar=/[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,nameChar=new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"),tagNamePattern=new RegExp("^"+nameStartChar.source+nameChar.source+"*(?::"+nameStartChar.source+nameChar.source+"*)?$"),S_TAG=0,S_ATTR=1,S_ATTR_SPACE=2,S_EQ=3,S_ATTR_NOQUOT_VALUE=4,S_ATTR_END=5,S_TAG_SPACE=6,S_TAG_CLOSE=7;function ParseError$1(Z,X){this.message=Z,this.locator=X,Error.captureStackTrace&&Error.captureStackTrace(this,ParseError$1)}ParseError$1.prototype=new Error,ParseError$1.prototype.name=ParseError$1.name;function XMLReader$1(){}XMLReader$1.prototype={parse:function(Z,X,K){var J=this.domBuilder;J.startDocument(),_copy(X,X={}),parse(Z,X,K,J,this.errorHandler),J.endDocument()}};function parse(Z,X,K,J,Q){function ee(we){if(we>65535){we-=65536;var Be=55296+(we>>10),Re=56320+(we&1023);return String.fromCharCode(Be,Re)}else return String.fromCharCode(we)}function te(we){var Be=we.slice(1,-1);return Object.hasOwnProperty.call(K,Be)?K[Be]:Be.charAt(0)==="#"?ee(parseInt(Be.substr(1).replace("x","0x"))):(Q.error("entity not found:"+we),we)}function re(we){if(we>de){var Be=Z.substring(de,we).replace(/&#?\w+;/g,te);ae&&ie(de),J.characters(Be,0,we-de),de=we}}function ie(we,Be){for(;we>=se&&(Be=oe.exec(Z));)ne=Be.index,se=ne+Be[0].length,ae.lineNumber++;ae.columnNumber=we-ne+1}for(var ne=0,se=0,oe=/.*(?:\r\n?|\n)|.*$/g,ae=J.locator,le=[{currentNSMap:X}],ce={},de=0;;){try{var he=Z.indexOf("<",de);if(he<0){if(!Z.substr(de).match(/^\s*$/)){var pe=J.doc,fe=pe.createTextNode(Z.substr(de));pe.appendChild(fe),J.currentElement=fe}return}switch(he>de&&re(he),Z.charAt(he+1)){case"/":var Se=Z.indexOf(">",he+3),ge=Z.substring(he+2,Se).replace(/[ \t\n\r]+$/g,""),me=le.pop();Se<0?(ge=Z.substring(he+2).replace(/[\s<].*/,""),Q.error("end tag name: "+ge+" is not complete:"+me.tagName),Se=he+1+ge.length):ge.match(/\s</)&&(ge=ge.replace(/[\s<].*/,""),Q.error("end tag name: "+ge+" maybe not complete"),Se=he+1+ge.length);var ye=me.localNSMap,_e=me.tagName==ge,Ce=_e||me.tagName&&me.tagName.toLowerCase()==ge.toLowerCase();if(Ce){if(J.endElement(me.uri,me.localName,ge),ye)for(var xe in ye)Object.prototype.hasOwnProperty.call(ye,xe)&&J.endPrefixMapping(xe);_e||Q.fatalError("end tag name: "+ge+" is not match the current start tagName:"+me.tagName)}else le.push(me);Se++;break;case"?":ae&&ie(he),Se=parseInstruction(Z,he,J);break;case"!":ae&&ie(he),Se=parseDCC(Z,he,J,Q);break;default:ae&&ie(he);var be=new ElementAttributes,ve=le[le.length-1].currentNSMap,Se=parseElementStartPart(Z,he,be,ve,te,Q),Pe=be.length;if(!be.closed&&fixSelfClosed(Z,Se,be.tagName,ce)&&(be.closed=!0,K.nbsp||Q.warning("unclosed xml attribute")),ae&&Pe){for(var Te=copyLocator(ae,{}),Ae=0;Ae<Pe;Ae++){var Ie=be[Ae];ie(Ie.offset),Ie.locator=copyLocator(ae,{})}J.locator=Te,appendElement$1(be,J,ve)&&le.push(be),J.locator=ae}else appendElement$1(be,J,ve)&&le.push(be);NAMESPACE$1.isHTML(be.uri)&&!be.closed?Se=parseHtmlSpecialContent(Z,Se,be.tagName,te,J):Se++}}catch(we){if(we instanceof ParseError$1)throw we;Q.error("element parse error: "+we),Se=-1}Se>de?de=Se:re(Math.max(he,de)+1)}}function copyLocator(Z,X){return X.lineNumber=Z.lineNumber,X.columnNumber=Z.columnNumber,X}function parseElementStartPart(Z,X,K,J,Q,ee){function te(le,ce,de){K.attributeNames.hasOwnProperty(le)&&ee.fatalError("Attribute "+le+" redefined"),K.addValue(le,ce.replace(/[\t\n\r]/g," ").replace(/&#?\w+;/g,Q),de)}for(var re,ie,ne=++X,se=S_TAG;;){var oe=Z.charAt(ne);switch(oe){case"=":if(se===S_ATTR)re=Z.slice(X,ne),se=S_EQ;else if(se===S_ATTR_SPACE)se=S_EQ;else throw new Error("attribute equal must after attrName");break;case"'":case'"':if(se===S_EQ||se===S_ATTR)if(se===S_ATTR&&(ee.warning('attribute value must after "="'),re=Z.slice(X,ne)),X=ne+1,ne=Z.indexOf(oe,X),ne>0)ie=Z.slice(X,ne),te(re,ie,X-1),se=S_ATTR_END;else throw new Error("attribute value no end '"+oe+"' match");else if(se==S_ATTR_NOQUOT_VALUE)ie=Z.slice(X,ne),te(re,ie,X),ee.warning('attribute "'+re+'" missed start quot('+oe+")!!"),X=ne+1,se=S_ATTR_END;else throw new Error('attribute value must after "="');break;case"/":switch(se){case S_TAG:K.setTagName(Z.slice(X,ne));case S_ATTR_END:case S_TAG_SPACE:case S_TAG_CLOSE:se=S_TAG_CLOSE,K.closed=!0;case S_ATTR_NOQUOT_VALUE:case S_ATTR:break;case S_ATTR_SPACE:K.closed=!0;break;default:throw new Error("attribute invalid close char('/')")}break;case"":return ee.error("unexpected end of input"),se==S_TAG&&K.setTagName(Z.slice(X,ne)),ne;case">":switch(se){case S_TAG:K.setTagName(Z.slice(X,ne));case S_ATTR_END:case S_TAG_SPACE:case S_TAG_CLOSE:break;case S_ATTR_NOQUOT_VALUE:case S_ATTR:ie=Z.slice(X,ne),ie.slice(-1)==="/"&&(K.closed=!0,ie=ie.slice(0,-1));case S_ATTR_SPACE:se===S_ATTR_SPACE&&(ie=re),se==S_ATTR_NOQUOT_VALUE?(ee.warning('attribute "'+ie+'" missed quot(")!'),te(re,ie,X)):((!NAMESPACE$1.isHTML(J[""])||!ie.match(/^(?:disabled|checked|selected)$/i))&&ee.warning('attribute "'+ie+'" missed value!! "'+ie+'" instead!!'),te(ie,ie,X));break;case S_EQ:throw new Error("attribute value missed!!")}return ne;case"\x80":oe=" ";default:if(oe<=" ")switch(se){case S_TAG:K.setTagName(Z.slice(X,ne)),se=S_TAG_SPACE;break;case S_ATTR:re=Z.slice(X,ne),se=S_ATTR_SPACE;break;case S_ATTR_NOQUOT_VALUE:var ie=Z.slice(X,ne);ee.warning('attribute "'+ie+'" missed quot(")!!'),te(re,ie,X);case S_ATTR_END:se=S_TAG_SPACE;break}else switch(se){case S_ATTR_SPACE:var ae=K.tagName;(!NAMESPACE$1.isHTML(J[""])||!re.match(/^(?:disabled|checked|selected)$/i))&&ee.warning('attribute "'+re+'" missed value!! "'+re+'" instead2!!'),te(re,re,X),X=ne,se=S_ATTR;break;case S_ATTR_END:ee.warning('attribute space is required"'+re+'"!!');case S_TAG_SPACE:se=S_ATTR,X=ne;break;case S_EQ:se=S_ATTR_NOQUOT_VALUE,X=ne;break;case S_TAG_CLOSE:throw new Error("elements closed character '/' and '>' must be connected to")}}ne++}}function appendElement$1(Z,X,K){for(var J=Z.tagName,Q=null,oe=Z.length;oe--;){var ee=Z[oe],te=ee.qName,re=ee.value,ae=te.indexOf(":");if(ae>0)var ie=ee.prefix=te.slice(0,ae),ne=te.slice(ae+1),se=ie==="xmlns"&&ne;else ne=te,ie=null,se=te==="xmlns"&&"";ee.localName=ne,se!==!1&&(Q==null&&(Q={},_copy(K,K={})),K[se]=Q[se]=re,ee.uri=NAMESPACE$1.XMLNS,X.startPrefixMapping(se,re))}for(var oe=Z.length;oe--;){ee=Z[oe];var ie=ee.prefix;ie&&(ie==="xml"&&(ee.uri=NAMESPACE$1.XML),ie!=="xmlns"&&(ee.uri=K[ie||""]))}var ae=J.indexOf(":");ae>0?(ie=Z.prefix=J.slice(0,ae),ne=Z.localName=J.slice(ae+1)):(ie=null,ne=Z.localName=J);var le=Z.uri=K[ie||""];if(X.startElement(le,ne,J,Z),Z.closed){if(X.endElement(le,ne,J),Q)for(ie in Q)Object.prototype.hasOwnProperty.call(Q,ie)&&X.endPrefixMapping(ie)}else return Z.currentNSMap=K,Z.localNSMap=Q,!0}function parseHtmlSpecialContent(Z,X,K,J,Q){if(/^(?:script|textarea)$/i.test(K)){var ee=Z.indexOf("</"+K+">",X),te=Z.substring(X+1,ee);if(/[&<]/.test(te))return/^script$/i.test(K)?(Q.characters(te,0,te.length),ee):(te=te.replace(/&#?\w+;/g,J),Q.characters(te,0,te.length),ee)}return X+1}function fixSelfClosed(Z,X,K,J){var Q=J[K];return Q==null&&(Q=Z.lastIndexOf("</"+K+">"),Q<X&&(Q=Z.lastIndexOf("</"+K)),J[K]=Q),Q<X}function _copy(Z,X){for(var K in Z)Object.prototype.hasOwnProperty.call(Z,K)&&(X[K]=Z[K])}function parseDCC(Z,X,K,J){var Q=Z.charAt(X+2);switch(Q){case"-":if(Z.charAt(X+3)==="-"){var ee=Z.indexOf("-->",X+4);return ee>X?(K.comment(Z,X+4,ee-X-4),ee+3):(J.error("Unclosed comment"),-1)}else return-1;default:if(Z.substr(X+3,6)=="CDATA["){var ee=Z.indexOf("]]>",X+9);return K.startCDATA(),K.characters(Z,X+9,ee-X-9),K.endCDATA(),ee+3}var te=split(Z,X),re=te.length;if(re>1&&/!doctype/i.test(te[0][0])){var ie=te[1][0],ne=!1,se=!1;re>3&&(/^public$/i.test(te[2][0])?(ne=te[3][0],se=re>4&&te[4][0]):/^system$/i.test(te[2][0])&&(se=te[3][0]));var oe=te[re-1];return K.startDTD(ie,ne,se),K.endDTD(),oe.index+oe[0].length}}return-1}function parseInstruction(Z,X,K){var J=Z.indexOf("?>",X);if(J){var Q=Z.substring(X,J).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);if(Q){var ee=Q[0].length;return K.processingInstruction(Q[1],Q[2]),J+2}else return-1}return-1}function ElementAttributes(){this.attributeNames={}}ElementAttributes.prototype={setTagName:function(Z){if(!tagNamePattern.test(Z))throw new Error("invalid tagName:"+Z);this.tagName=Z},addValue:function(Z,X,K){if(!tagNamePattern.test(Z))throw new Error("invalid attribute:"+Z);this.attributeNames[Z]=this.length,this[this.length++]={qName:Z,value:X,offset:K}},length:0,getLocalName:function(Z){return this[Z].localName},getLocator:function(Z){return this[Z].locator},getQName:function(Z){return this[Z].qName},getURI:function(Z){return this[Z].uri},getValue:function(Z){return this[Z].value}};function split(Z,X){var K,J=[],Q=/'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;for(Q.lastIndex=X,Q.exec(Z);K=Q.exec(Z);)if(J.push(K),K[1])return J}var XMLReader_1=XMLReader$1,ParseError_1=ParseError$1,sax={XMLReader:XMLReader_1,ParseError:ParseError_1},DOMImplementation$1=dom.DOMImplementation,NAMESPACE=conventions.NAMESPACE,ParseError=sax.ParseError,XMLReader=sax.XMLReader;function normalizeLineEndings(Z){return Z.replace(/\r[\n\u0085]/g,`
`).replace(/[\r\u0085\u2028]/g,`
`)}function DOMParser$2(Z){this.options=Z||{locator:{}}}DOMParser$2.prototype.parseFromString=function(Z,X){var K=this.options,J=new XMLReader,Q=K.domBuilder||new DOMHandler,ee=K.errorHandler,te=K.locator,re=K.xmlns||{},ie=/\/x?html?$/.test(X),ne=ie?entities.HTML_ENTITIES:entities.XML_ENTITIES;te&&Q.setDocumentLocator(te),J.errorHandler=buildErrorHandler(ee,Q,te),J.domBuilder=K.domBuilder||Q,ie&&(re[""]=NAMESPACE.HTML),re.xml=re.xml||NAMESPACE.XML;var se=K.normalizeLineEndings||normalizeLineEndings;return Z&&typeof Z=="string"?J.parse(se(Z),re,ne):J.errorHandler.error("invalid doc source"),Q.doc};function buildErrorHandler(Z,X,K){if(!Z){if(X instanceof DOMHandler)return X;Z=X}var J={},Q=Z instanceof Function;K=K||{};function ee(te){var re=Z[te];!re&&Q&&(re=Z.length==2?function(ie){Z(te,ie)}:Z),J[te]=re&&function(ie){re("[xmldom "+te+"]	"+ie+_locator(K))}||function(){}}return ee("warning"),ee("error"),ee("fatalError"),J}function DOMHandler(){this.cdata=!1}function position(Z,X){X.lineNumber=Z.lineNumber,X.columnNumber=Z.columnNumber}DOMHandler.prototype={startDocument:function(){this.doc=new DOMImplementation$1().createDocument(null,null,null),this.locator&&(this.doc.documentURI=this.locator.systemId)},startElement:function(Z,X,K,J){var Q=this.doc,ee=Q.createElementNS(Z,K||X),te=J.length;appendElement(this,ee),this.currentElement=ee,this.locator&&position(this.locator,ee);for(var re=0;re<te;re++){var Z=J.getURI(re),ie=J.getValue(re),K=J.getQName(re),ne=Q.createAttributeNS(Z,K);this.locator&&position(J.getLocator(re),ne),ne.value=ne.nodeValue=ie,ee.setAttributeNode(ne)}},endElement:function(Z,X,K){var J=this.currentElement,Q=J.tagName;this.currentElement=J.parentNode},startPrefixMapping:function(Z,X){},endPrefixMapping:function(Z){},processingInstruction:function(Z,X){var K=this.doc.createProcessingInstruction(Z,X);this.locator&&position(this.locator,K),appendElement(this,K)},ignorableWhitespace:function(Z,X,K){},characters:function(Z,X,K){if(Z=_toString.apply(this,arguments),Z){if(this.cdata)var J=this.doc.createCDATASection(Z);else var J=this.doc.createTextNode(Z);this.currentElement?this.currentElement.appendChild(J):/^\s*$/.test(Z)&&this.doc.appendChild(J),this.locator&&position(this.locator,J)}},skippedEntity:function(Z){},endDocument:function(){this.doc.normalize()},setDocumentLocator:function(Z){(this.locator=Z)&&(Z.lineNumber=0)},comment:function(Z,X,K){Z=_toString.apply(this,arguments);var J=this.doc.createComment(Z);this.locator&&position(this.locator,J),appendElement(this,J)},startCDATA:function(){this.cdata=!0},endCDATA:function(){this.cdata=!1},startDTD:function(Z,X,K){var J=this.doc.implementation;if(J&&J.createDocumentType){var Q=J.createDocumentType(Z,X,K);this.locator&&position(this.locator,Q),appendElement(this,Q),this.doc.doctype=Q}},warning:function(Z){console.warn("[xmldom warning]	"+Z,_locator(this.locator))},error:function(Z){console.error("[xmldom error]	"+Z,_locator(this.locator))},fatalError:function(Z){throw new ParseError(Z,this.locator)}};function _locator(Z){if(Z)return`
@`+(Z.systemId||"")+"#[line:"+Z.lineNumber+",col:"+Z.columnNumber+"]"}function _toString(Z,X,K){return typeof Z=="string"?Z.substr(X,K):Z.length>=X+K||X?new java.lang.String(Z,X,K)+"":Z}"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(Z){DOMHandler.prototype[Z]=function(){return null}});function appendElement(Z,X){Z.currentElement?Z.currentElement.appendChild(X):Z.doc.appendChild(X)}var __DOMHandler=DOMHandler,normalizeLineEndings_1=normalizeLineEndings,DOMParser_1=DOMParser$2,domParser={__DOMHandler,normalizeLineEndings:normalizeLineEndings_1,DOMParser:DOMParser_1},DOMImplementation=dom.DOMImplementation,XMLSerializer$1=dom.XMLSerializer,DOMParser$1=domParser.DOMParser,lib={DOMImplementation,XMLSerializer:XMLSerializer$1,DOMParser:DOMParser$1};const WebWorkerAdapter={createCanvas:(Z,X)=>new OffscreenCanvas(Z!=null?Z:0,X!=null?X:0),getCanvasRenderingContext2D:()=>OffscreenCanvasRenderingContext2D,getWebGLRenderingContext:()=>WebGLRenderingContext,getNavigator:()=>navigator,getBaseUrl:()=>globalThis.location.href,getFontFaceSet:()=>globalThis.fonts,fetch:(Z,X)=>fetch(Z,X),parseXML:Z=>new DOMParser$1().parseFromString(Z,"text/xml")};var webworkerAll={__proto__:null};function ensurePrecision(Z,X,K){const J=K?X.maxSupportedFragmentPrecision:X.maxSupportedVertexPrecision;if(Z.substring(0,9)!=="precision"){let Q=K?X.requestedFragmentPrecision:X.requestedVertexPrecision;if(Q==="highp"&&J!=="highp"&&(Q="mediump"),Z.substring(0,8)!=="#version")return`precision ${Q} float;
${Z}`;const ee=Z.indexOf(`
`);return`${Z.substring(0,ee+1)}precision ${Q} float;
${Z.substring(ee+1)}`}else if(J!=="highp"&&Z.substring(0,15)==="precision highp")return Z.replace("precision highp","precision mediump");return Z}const t$6={};let e$3=t$6;function getTestContext(){return(e$3===t$6||e$3!=null&&e$3.isContextLost())&&(e$3=DOMAdapter.get().createCanvas().getContext("webgl2",{})),e$3}let t$5;function getMaxFragmentPrecision(){if(!t$5){t$5="mediump";const Z=getTestContext();Z&&Z.getShaderPrecisionFormat&&(t$5=Z.getShaderPrecisionFormat(Z.FRAGMENT_SHADER,Z.HIGH_FLOAT).precision?"highp":"mediump")}return t$5}const f$m={},g$g={};function setProgramName(Z,{name:X="pixi-program"},K=!0){X=X.replace(/\s+/g,"-"),X+=K?"-fragment":"-vertex";const J=K?f$m:g$g;if(J[X]?(J[X]++,X+=`-${J[X]}`):J[X]=1,Z.indexOf("#define SHADER_NAME")!==-1)return Z;const Q=`#define SHADER_NAME ${X}`;if(Z.substring(0,8)!=="#version")return`${Q}
${Z}`;const ee=Z.indexOf(`
`);return`${Z.substring(0,ee+1)}${Q}
${Z.substring(ee+1)}`}function setProgramVersion(Z,{version:X="300 es"}){return Z.substring(0,8)==="#version"?Z:`#version ${X}
${Z}`}var p$s=Object.defineProperty,g$f=Object.getOwnPropertySymbols,d$g=Object.prototype.hasOwnProperty,b$f=Object.prototype.propertyIsEnumerable,f$l=(Z,X,K)=>X in Z?p$s(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$l=(Z,X)=>{for(var K in X||(X={}))d$g.call(X,K)&&f$l(Z,K,X[K]);if(g$f)for(var K of g$f(X))b$f.call(X,K)&&f$l(Z,K,X[K]);return Z};const m$m={ensurePrecision,setProgramName,setProgramVersion},l$k=Object.create(null),i$g=class{constructor(Z){Z=o$l(o$l({},i$g.defaultOptions),Z);const X={ensurePrecision:{requestedFragmentPrecision:Z.preferredFragmentPrecision,requestedVertexPrecision:Z.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:getMaxFragmentPrecision()},setProgramName:{name:Z.name},setProgramVersion:{version:"300 es"}};let K=Z.fragment,J=Z.vertex;Object.keys(m$m).forEach(Q=>{var ee;const te=(ee=X[Q])!=null?ee:{};K=m$m[Q](K,te,!0),J=m$m[Q](J,te,!1)}),this.fragment=K,this.vertex=J,this._key=`${this.vertex}:${this.fragment}`}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(Z){const X=`${Z.vertex}:${Z.fragment}`;return l$k[X]||(l$k[X]=new i$g(Z)),l$k[X]}};let GlProgram=i$g;GlProgram.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};function extractStructAndGroups(Z){var X,K,J;const Q=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,ee=/@group\((\d+)\)/,te=/@binding\((\d+)\)/,re=/var(<[^>]+>)? (\w+)/,ie=/:\s*(\w+)/,ne=/struct\s+(\w+)\s*{([^}]+)}/g,se=/(\w+)\s*:\s*([\w\<\>]+)/g,oe=/struct\s+(\w+)/,ae=(X=Z.match(Q))==null?void 0:X.map(ce=>({group:parseInt(ce.match(ee)[1],10),binding:parseInt(ce.match(te)[1],10),name:ce.match(re)[2],isUniform:ce.match(re)[1]==="<uniform>",type:ce.match(ie)[1]}));if(!ae)return{groups:[],structs:[]};const le=(J=(K=Z.match(ne))==null?void 0:K.map(ce=>{const de=ce.match(oe)[1],he=ce.match(se).reduce((pe,fe)=>{const[ge,me]=fe.split(":");return pe[ge.trim()]=me.trim(),pe},{});return he?{name:de,members:he}:null}).filter(({name:ce})=>ae.some(de=>de.type===ce)))!=null?J:[];return{groups:ae,structs:le}}var ShaderStage=(Z=>(Z[Z.VERTEX=1]="VERTEX",Z[Z.FRAGMENT=2]="FRAGMENT",Z[Z.COMPUTE=4]="COMPUTE",Z))(ShaderStage||{});function generateGpuLayoutGroups({groups:Z}){const X=[];for(let K=0;K<Z.length;K++){const J=Z[K];X[J.group]||(X[J.group]=[]),J.isUniform?X[J.group].push({binding:J.binding,visibility:ShaderStage.VERTEX|ShaderStage.FRAGMENT,buffer:{type:"uniform"}}):J.type==="sampler"?X[J.group].push({binding:J.binding,visibility:ShaderStage.FRAGMENT,sampler:{type:"filtering"}}):J.type==="texture_2d"&&X[J.group].push({binding:J.binding,visibility:ShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return X}function generateLayoutHash({groups:Z}){const X=[];for(let K=0;K<Z.length;K++){const J=Z[K];X[J.group]||(X[J.group]={}),X[J.group][J.name]=J.binding}return X}function removeStructAndGroupDuplicates(Z,X){const K=new Set,J=new Set,Q=[...Z.structs,...X.structs].filter(te=>K.has(te.name)?!1:(K.add(te.name),!0)),ee=[...Z.groups,...X.groups].filter(te=>{const re=`${te.name}-${te.binding}`;return J.has(re)?!1:(J.add(re),!0)});return{structs:Q,groups:ee}}const a$t=Object.create(null);class GpuProgram{constructor(X){this._layoutKey=0;const{fragment:K,vertex:J,layout:Q,gpuLayout:ee,name:te}=X;if(this.name=te,this.fragment=K,this.vertex=J,K.source===J.source){const re=extractStructAndGroups(K.source);this.structsAndGroups=re}else{const re=extractStructAndGroups(J.source),ie=extractStructAndGroups(K.source);this.structsAndGroups=removeStructAndGroupDuplicates(re,ie)}this.layout=Q!=null?Q:generateLayoutHash(this.structsAndGroups),this.gpuLayout=ee!=null?ee:generateGpuLayoutGroups(this.structsAndGroups)}destroy(){this._gpuLayout=null,this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(X){const K=`${X.vertex.source}:${X.fragment.source}:${X.fragment.entryPoint}:${X.vertex.entryPoint}`;return a$t[K]||(a$t[K]=new GpuProgram(X)),a$t[K]}}function defaultUniformValue(Z,X){switch(Z){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*X);case"vec3<f32>":return new Float32Array(3*X);case"vec4<f32>":return new Float32Array(4*X);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}var l$j=Object.defineProperty,f$k=Object.getOwnPropertySymbols,m$l=Object.prototype.hasOwnProperty,b$e=Object.prototype.propertyIsEnumerable,p$r=(Z,X,K)=>X in Z?l$j(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,s$p=(Z,X)=>{for(var K in X||(X={}))m$l.call(X,K)&&p$r(Z,K,X[K]);if(f$k)for(var K of f$k(X))b$e.call(X,K)&&p$r(Z,K,X[K]);return Z};const a$s=class{constructor(Z,X){this._touched=0,this.uid=uid("uniform"),this._resourceType="uniformGroup",this._resourceId=this.uid,this.isUniformGroup=!0,this._dirtyId=0;var K,J;X=s$p(s$p({},a$s.defaultOptions),X),this.uniformStructures=Z;const Q={};for(const ee in Z){const te=Z[ee];te.name=ee,te.size=(K=te.size)!=null?K:1,(J=te.value)!=null||(te.value=defaultUniformValue(te.type,te.size)),Q[ee]=te.value}this.uniforms=Q,this._dirtyId=1,this.ubo=X.ubo,this.isStatic=X.isStatic,this._signature=Object.keys(Q).map(ee=>`${ee}-${Z[ee].type}`).join("-")}update(){this._dirtyId++}};let UniformGroup=a$s;UniformGroup.defaultOptions={ubo:!1,isStatic:!1};class BindGroup{constructor(X){this.resources=Object.create(null),this._dirty=!0;let K=0;for(const J in X){const Q=X[J];this.setResource(Q,K++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const X=[];let K=0;for(const J in this.resources)X[K++]=this.resources[J]._resourceId;this._key=X.join("|")}setResource(X,K){var J,Q;const ee=this.resources[K];X!==ee&&(ee&&((J=X.off)==null||J.call(X,"change",this.onResourceChange,this)),(Q=X.on)==null||Q.call(X,"change",this.onResourceChange,this),this.resources[K]=X,this._dirty=!0)}getResource(X){return this.resources[X]}_touch(X){const K=this.resources;for(const J in K)K[J]._touched=X}destroy(){var X;const K=this.resources;for(const J in K){const Q=K[J];(X=Q.off)==null||X.call(Q,"change",this.onResourceChange,this)}this.resources=null}onResourceChange(){this._dirty=!0,this._updateKey()}}var RendererType=(Z=>(Z[Z.WEBGL=1]="WEBGL",Z[Z.WEBGPU=2]="WEBGPU",Z))(RendererType||{});class Shader extends eventemitter3{constructor({gpuProgram:X,glProgram:K,groups:J,resources:Q,groupMap:ee,compatibleRenderers:te}){super(),this._uniformBindMap=Object.create(null),this.gpuProgram=X,this.glProgram=K,te===void 0&&(te=0,X&&(te|=RendererType.WEBGPU),K&&(te|=RendererType.WEBGL)),this.compatibleRenderers=te;const re={};if(Q&&J)throw new Error("[Shader] Cannot have both resources and groups");if(!Q&&!J)throw new Error("[Shader] Must provide either resources or groups descriptor");if(!X&&J&&!ee)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!X&&J&&ee)for(const ie in ee)for(const ne in ee[ie]){const se=ee[ie][ne];re[se]={group:ie,binding:ne,name:se}}else if(X&&J&&!ee){const ie=X.structsAndGroups.groups;ee={},ie.forEach(ne=>{ee[ne.group]=ee[ne.group]||{},ee[ne.group][ne.binding]=ne.name,re[ne.name]=ne})}else if(Q){if(X){const ie=X.structsAndGroups.groups;ee={},ie.forEach(ne=>{ee[ne.group]=ee[ne.group]||{},ee[ne.group][ne.binding]=ne.name,re[ne.name]=ne})}else{ee={},J={99:new BindGroup};let ie=0;for(const ne in Q)re[ne]={group:99,binding:ie,name:ne},ee[99]=ee[99]||{},ee[99][ie]=ne,ie++}J={};for(const ie in Q){const ne=ie;let se=Q[ie];!se.source&&!se._resourceType&&(se=new UniformGroup(se));const oe=re[ne];oe&&(J[oe.group]=J[oe.group]||new BindGroup,J[oe.group].setResource(se,oe.binding))}}this.groups=J,this._uniformBindMap=ee,this.resources=this._buildResourceAccessor(J,re)}addResource(X,K,J){var Q,ee;(Q=this._uniformBindMap)[K]||(Q[K]={}),(ee=this._uniformBindMap[K])[J]||(ee[J]=X)}_buildResourceAccessor(X,K){const J={};for(const Q in K){const ee=K[Q];Object.defineProperty(J,ee.name,{get(){return X[ee.group].getResource(ee.binding)},set(te){X[ee.group].setResource(te,ee.binding)}})}return J}destroy(X=!1){var K,J;this.emit("destroy",this),X&&((K=this.gpuProgram)==null||K.destroy(),(J=this.glProgram)==null||J.destroy()),this.gpuProgram=null,this.glProgram=null,this.groups=null,this.removeAllListeners(),this._uniformBindMap=null,this.resources=null}}const i$f={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8},e$2=0,s$o=1,n$p=2,o$k=3,a$r=4,d$f=5;class State{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<e$2)}set blend(X){!!(this.data&1<<e$2)!==X&&(this.data^=1<<e$2)}get offsets(){return!!(this.data&1<<s$o)}set offsets(X){!!(this.data&1<<s$o)!==X&&(this.data^=1<<s$o)}set cullMode(X){if(X==="none"){this.culling=!1;return}this.culling=!0,this.clockwiseFrontFace=X==="front"}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<n$p)}set culling(X){!!(this.data&1<<n$p)!==X&&(this.data^=1<<n$p)}get depthTest(){return!!(this.data&1<<o$k)}set depthTest(X){!!(this.data&1<<o$k)!==X&&(this.data^=1<<o$k)}get depthMask(){return!!(this.data&1<<d$f)}set depthMask(X){!!(this.data&1<<d$f)!==X&&(this.data^=1<<d$f)}get clockwiseFrontFace(){return!!(this.data&1<<a$r)}set clockwiseFrontFace(X){!!(this.data&1<<a$r)!==X&&(this.data^=1<<a$r)}get blendMode(){return this._blendMode}set blendMode(X){this.blend=X!=="none",this._blendMode=X,this._blendModeId=i$f[X]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(X){this.offsets=!!X,this._polygonOffset=X}static for2d(){const X=new State;return X.depthTest=!1,X.blend=!0,X}}var u$h=Object.defineProperty,d$e=Object.getOwnPropertySymbols,p$q=Object.prototype.hasOwnProperty,b$d=Object.prototype.propertyIsEnumerable,l$i=(Z,X,K)=>X in Z?u$h(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,a$q=(Z,X)=>{for(var K in X||(X={}))p$q.call(X,K)&&l$i(Z,K,X[K]);if(d$e)for(var K of d$e(X))b$d.call(X,K)&&l$i(Z,K,X[K]);return Z};const n$o=class extends Shader{constructor(Z){var X;Z=a$q(a$q({},n$o.defaultOptions),Z),super(Z),this.enabled=!0,this._state=State.for2d(),this.padding=Z.padding,typeof Z.antialias=="boolean"?this.antialias=Z.antialias?"on":"off":this.antialias=(X=Z.antialias)!=null?X:"inherit",this.resolution=Z.resolution,this.blendRequired=Z.blendRequired,this.addResource("filterUniforms",0,0),this.addResource("uSampler",0,1)}apply(Z,X,K,J){Z.applyFilter(this,X,K,J)}get blendMode(){return this._state.blendMode}set blendMode(Z){this._state.blendMode=Z}};let Filter=n$o;Filter.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"inherit",blendRequired:!1};var M$3=`
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 fragColor;

uniform float uBlend;

uniform sampler2D uSampler;
uniform sampler2D backTexture;

{FUNCTIONS}

void main()
{ 
    vec4 back = texture(backTexture, vTextureCoord);
    vec4 front = texture(uSampler, vTextureCoord);

    {MAIN}
}
`,B$2=`in vec2 aPosition;
out vec2 vTextureCoord;
out vec2 backgroundUv;

uniform globalUniforms {
  mat3 projectionMatrix;
  mat3 worldTransformMatrix;
  float worldAlpha;
};

uniform vec4 inputSize;
uniform vec4 outputFrame;
uniform vec4 backgroundFrame;
uniform vec4 outputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;
    
    position.x = position.x * (2.0 / outputTexture.x) - 1.0;
    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,O$2=`struct GlobalUniforms {
  projectionMatrix:mat3x3<f32>,
  worldTransformMatrix:mat3x3<f32>,
  worldAlpha: f32
}

struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,
};

struct BlendUniforms {
  uBlend:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;
@group(0) @binding(3) var backTexture: texture_2d<f32>;

@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

{FUNCTIONS}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>
) -> @location(0) vec4<f32> {


   var back =  textureSample(backTexture, mySampler, uv);
   var front = textureSample(uSampler, mySampler, uv);
   
   var out = vec4<f32>(0.0,0.0,0.0,0.0);

   {MAIN}

   return out;
}`,a$p=Object.defineProperty,i$e=Object.getOwnPropertySymbols,f$j=Object.prototype.hasOwnProperty,d$d=Object.prototype.propertyIsEnumerable,s$n=(Z,X,K)=>X in Z?a$p(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$j=(Z,X)=>{for(var K in X||(X={}))f$j.call(X,K)&&s$n(Z,K,X[K]);if(i$e)for(var K of i$e(X))d$d.call(X,K)&&s$n(Z,K,X[K]);return Z};class BlendModeFilter extends Filter{constructor(X){const K=X.gpu,J=m$k(o$j({source:O$2},K)),Q=new GpuProgram({vertex:{source:J,entryPoint:"mainVertex"},fragment:{source:J,entryPoint:"mainFragment"}}),ee=X.gl,te=m$k(o$j({source:M$3},ee)),re=new GlProgram({vertex:B$2,fragment:te}),ie=new UniformGroup({uBlend:{value:1,type:"f32"}});super({gpuProgram:Q,glProgram:re,blendRequired:!0,resources:{blendUniforms:ie,backTexture:Texture.EMPTY}})}}function m$k(Z){const{source:X,functions:K,main:J}=Z;return X.replace("{FUNCTIONS}",K).replace("{MAIN}",J)}const hslgl=`
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `,hslgpu=`
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;class ColorBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                ${hslgl}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendColor(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                ${hslgpu}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}ColorBlend.extension={name:"color",type:u$v.BlendMode};class ColorBurnBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendColorBurn(back.rgb, front.rgb, front.a), uBlend);
            `},gpu:{functions:`
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}ColorBurnBlend.extension={name:"color-burn",type:u$v.BlendMode};class ColorDodgeBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendColorDodge(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}ColorDodgeBlend.extension={name:"color-dodge",type:u$v.BlendMode};class DarkenBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendDarken(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}DarkenBlend.extension={name:"darken",type:u$v.BlendMode};class DifferenceBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendDifference(back.rgb, front.rgb, front.a), uBlend);
            `},gpu:{functions:`
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}DifferenceBlend.extension={name:"difference",type:u$v.BlendMode};class DivideBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendDivide(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}DivideBlend.extension={name:"divide",type:u$v.BlendMode};class ExclusionBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendExclusion(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}ExclusionBlend.extension={name:"exclusion",type:u$v.BlendMode};class HardLightBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendHardLight(back.rgb, front.rgb, front.a), uBlend);
            `},gpu:{functions:`
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}HardLightBlend.extension={name:"hard-light",type:u$v.BlendMode};class HardMixBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendHardMix(back.rgb, front.rgb, front.a), uBlend);
            `},gpu:{functions:`
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}HardMixBlend.extension={name:"hard-mix",type:u$v.BlendMode};class LightenBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendLighten(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}LightenBlend.extension={name:"lighten",type:u$v.BlendMode};class LinearBurnBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendLinearBurn(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}LinearBurnBlend.extension={name:"linear-burn",type:u$v.BlendMode};class LinearDodgeBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendLinearDodge(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}LinearDodgeBlend.extension={name:"linear-dodge",type:u$v.BlendMode};class LinearLightBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendLinearLight(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}LinearLightBlend.extension={name:"linear-light",type:u$v.BlendMode};class LuminosityBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                ${hslgl}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendLuminosity(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                ${hslgpu}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}LuminosityBlend.extension={name:"luminosity",type:u$v.BlendMode};class NegationBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendNegation(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}NegationBlend.extension={name:"negation",type:u$v.BlendMode};class OverlayBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float overlay(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendOverlay(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}OverlayBlend.extension={name:"overlay",type:u$v.BlendMode};class PinLightBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}PinLightBlend.extension={name:"pin-light",type:u$v.BlendMode};class SaturationBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                ${hslgl}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), uBlend);
            `},gpu:{functions:`
                ${hslgpu}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,main:`
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
            `}})}}SaturationBlend.extension={name:"saturation",type:u$v.BlendMode};class SoftLightBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}SoftLightBlend.extension={name:"soft-light",type:u$v.BlendMode};class SubtractBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                fragColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), uBlend);
                `},gpu:{functions:`
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}SubtractBlend.extension={name:"subtract",type:u$v.BlendMode};class VividLightBlend extends BlendModeFilter{constructor(){super({gl:{functions:`
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,main:`
                fragColor = vec4(blendVividLight(back.rgb, front.rgb, front.a), uBlend);
            `},gpu:{functions:`
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,main:`
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendUniforms.uBlend);
                `}})}}VividLightBlend.extension={name:"vivid-light",type:u$v.BlendMode},b$p.add(ColorBlend,ColorBurnBlend,ColorDodgeBlend,DarkenBlend,DifferenceBlend,DivideBlend,ExclusionBlend,HardLightBlend,HardMixBlend,LightenBlend,LinearBurnBlend,LinearLightBlend,LinearDodgeBlend,LuminosityBlend,NegationBlend,OverlayBlend,PinLightBlend,SaturationBlend,SoftLightBlend,SubtractBlend,VividLightBlend);var P$6=`in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;
uniform vec4 outputTexture;
// uniform vec4 globalFrame;
// uniform float flipped;


vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;
    
    position.x = position.x * (2.0 / outputTexture.x) - 1.0;
    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,y$9=`
in vec2 vTextureCoord;

out vec4 fragColor;

uniform float uAlpha;
uniform sampler2D uSampler;

void main()
{
    fragColor =  texture(uSampler, vTextureCoord) * uAlpha;
}
`,s$m=`struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,
};

struct AlphaUniforms {
  uAlpha:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;

@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.globalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {
 
    var sample = textureSample(uSampler, mySampler, uv);
    
    return sample * alphaUniforms.uAlpha;
}`,f$i=Object.defineProperty,h$l=Object.defineProperties,c$g=Object.getOwnPropertyDescriptors,i$d=Object.getOwnPropertySymbols,g$e=Object.prototype.hasOwnProperty,O$1=Object.prototype.propertyIsEnumerable,n$n=(Z,X,K)=>X in Z?f$i(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$i=(Z,X)=>{for(var K in X||(X={}))g$e.call(X,K)&&n$n(Z,K,X[K]);if(i$d)for(var K of i$d(X))O$1.call(X,K)&&n$n(Z,K,X[K]);return Z},p$p=(Z,X)=>h$l(Z,c$g(X));const a$o=class extends Filter{constructor(Z){Z=o$i(o$i({},a$o.defaultOptions),Z);const X=new GpuProgram({vertex:{source:s$m,entryPoint:"mainVertex"},fragment:{source:s$m,entryPoint:"mainFragment"}}),K=new GlProgram({vertex:P$6,fragment:y$9,name:"alpha-filter"}),J=new UniformGroup({uAlpha:{value:Z.alpha,type:"f32"}});super({gpuProgram:X,glProgram:K,resources:{alphaUniforms:J}})}get alpha(){return this.resources.alphaUniforms.uniforms.uAlpha}set alpha(Z){this.resources.alphaUniforms.uniforms.uAlpha=Z}};let AlphaFilter=a$o;AlphaFilter.defaultOptions=p$p(o$i({},Filter.defaultOptions),{alpha:1});function nextPow2(Z){return Z+=Z===0?1:0,--Z,Z|=Z>>>1,Z|=Z>>>2,Z|=Z>>>4,Z|=Z>>>8,Z|=Z>>>16,Z+1}function isPow2(Z){return!(Z&Z-1)&&!!Z}function log2(Z){let X=(Z>65535?1:0)<<4;Z>>>=X;let K=(Z>255?1:0)<<3;return Z>>>=K,X|=K,K=(Z>15?1:0)<<2,Z>>>=K,X|=K,K=(Z>3?1:0)<<1,Z>>>=K,X|=K,X|Z>>1}var b$c=Object.defineProperty,m$j=Object.defineProperties,f$h=Object.getOwnPropertyDescriptors,n$m=Object.getOwnPropertySymbols,T$7=Object.prototype.hasOwnProperty,_$3=Object.prototype.propertyIsEnumerable,p$o=(Z,X,K)=>X in Z?b$c(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,x$7=(Z,X)=>{for(var K in X||(X={}))T$7.call(X,K)&&p$o(Z,K,X[K]);if(n$m)for(var K of n$m(X))_$3.call(X,K)&&p$o(Z,K,X[K]);return Z},h$k=(Z,X)=>m$j(Z,f$h(X));let g$d=0;class TexturePoolClass{constructor(X){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=X||{},this.enableFullScreen=!1}createTexture(X,K,J){const Q=new TextureSource(h$k(x$7({},this.textureOptions),{width:X,height:K,resolution:1,antialias:J}));return new Texture({source:Q,label:`texturePool_${g$d++}`})}getOptimalTexture(X,K,J=1,Q){let ee=Math.ceil(X*J-1e-6),te=Math.ceil(K*J-1e-6);ee=nextPow2(ee),te=nextPow2(te);const re=(ee<<17)+(te<<1)+(Q?1:0);this._texturePool[re]||(this._texturePool[re]=[]);let ie=this._texturePool[re].pop();return ie||(ie=this.createTexture(ee,te,Q)),ie.source._resolution=J,ie.source.width=ee/J,ie.source.height=te/J,ie.source.pixelWidth=ee,ie.source.pixelHeight=te,ie.frameX=0,ie.frameY=0,ie.frameWidth=X,ie.frameHeight=K,ie.layout.update(),this._poolKeyHash[ie.id]=re,ie}getSameSizeTexture(X,K=!1){const J=X.source;return this.getOptimalTexture(X.width,X.height,J._resolution,K)}returnTexture(X){const K=this._poolKeyHash[X.id];this._texturePool[K].push(X)}clear(X){if(X=X!==!1,X)for(const K in this._texturePool){const J=this._texturePool[K];if(J)for(let Q=0;Q<J.length;Q++)J[Q].destroy(!0)}this._texturePool={}}}const TexturePool=new TexturePoolClass,GAUSSIAN_VALUES={5:[.153388,.221461,.250301],7:[.071303,.131514,.189879,.214607],9:[.028532,.067234,.124009,.179044,.20236],11:[.0093,.028002,.065984,.121703,.175713,.198596],13:[.002406,.009255,.027867,.065666,.121117,.174868,.197641],15:[489e-6,.002403,.009246,.02784,.065602,.120999,.174697,.197448]},g$c=["in vec2 vBlurTexCoords[%size%];","uniform sampler2D uSampler;","out vec4 fragColor;","void main(void)","{","    fragColor = vec4(0.0);","    %blur%","}"].join(`
`);function generateBlurFragSource(Z){const X=GAUSSIAN_VALUES[Z],K=X.length;let J=g$c,Q="";const ee="fragColor += texture(uSampler, vBlurTexCoords[%index%]) * %value%;";let te;for(let re=0;re<Z;re++){let ie=ee.replace("%index%",re.toString());te=re,re>=K&&(te=Z-re-1),ie=ie.replace("%value%",X[te].toString()),Q+=ie,Q+=`
`}return J=J.replace("%blur%",Q),J=J.replace("%size%",Z.toString()),J}const p$n=`
    in vec2 aPosition;

    uniform float strength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;
    uniform vec4 inputPixel;
    uniform vec4 outputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;
    
    position.x = position.x * (2.0 / outputTexture.x) - 1.0;
    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = inputSize.%dimension% * strength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;function generateBlurVertSource(Z,X){const K=Math.ceil(Z/2);let J=p$n,Q="",ee;X?ee="vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);":ee="vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";for(let te=0;te<Z;te++){let re=ee.replace("%index%",te.toString());re=re.replace("%sampleIndex%",`${te-(K-1)}.0`),Q+=re,Q+=`
`}return J=J.replace("%blur%",Q),J=J.replace("%size%",Z.toString()),J=J.replace("%dimension%",X?"z":"w"),J}function generateBlurGlProgram(Z,X){const K=generateBlurVertSource(X,Z),J=generateBlurFragSource(X);return GlProgram.from({vertex:K,fragment:J,name:`blur-${Z?"horizontal":"vertical"}-pass-filter`})}var b$b=`

struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,
};

struct BlurUniforms {
  strength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.globalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let strength = gfu.inputSize.w * blurUniforms.strength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   fragColor = vec4(0.0);

    %blur-sampling%

    return fragColor;
}`;function generateBlurProgram(Z,X){const K=GAUSSIAN_VALUES[X],J=K.length,Q=[],ee=[],te=[];for(let oe=0;oe<X;oe++){Q[oe]=`@location(${oe}) offset${oe}: vec2<f32>,`,Z?ee[oe]=`filteredCord + vec2(${oe-J+1} * strength, 0.0),`:ee[oe]=`filteredCord + vec2(0.0, ${oe-J+1} * strength),`;const ae=oe<J?oe:X-oe-1,le=K[ae].toString();te[oe]=`fragColor += textureSample(uSampler, mySampler, offset${oe}) * ${le};`}const re=Q.join(`
`),ie=ee.join(`
`),ne=te.join(`
`),se=b$b.replace("%blur-struct%",re).replace("%blur-vertex-out%",ie).replace("%blur-fragment-in%",re).replace("%blur-sampling%",ne);return GpuProgram.from({vertex:{source:se,entryPoint:"mainVertex"},fragment:{source:se,entryPoint:"mainFragment"}})}var d$c=Object.defineProperty,h$j=Object.getOwnPropertySymbols,g$b=Object.prototype.hasOwnProperty,c$f=Object.prototype.propertyIsEnumerable,y$8=(Z,X,K)=>X in Z?d$c(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,n$l=(Z,X)=>{for(var K in X||(X={}))g$b.call(X,K)&&y$8(Z,K,X[K]);if(h$j)for(var K of h$j(X))c$f.call(X,K)&&y$8(Z,K,X[K]);return Z};const a$n=class extends Filter{constructor(Z){Z=n$l(n$l({},a$n.defaultOptions),Z);const X=generateBlurGlProgram(Z.horizontal,Z.kernelSize),K=generateBlurProgram(Z.horizontal,Z.kernelSize);super(n$l({glProgram:X,gpuProgram:K,resources:{blurUniforms:{strength:{value:0,type:"f32"}}}},Z)),this.horizontal=Z.horizontal,this._quality=0,this.quality=Z.quality,this.blur=Z.strength,this._uniforms=this.resources.blurUniforms.uniforms}apply(Z,X,K,J){if(this._uniforms.strength=this.strength/this.passes,this.passes===1)Z.applyFilter(this,X,K,J);else{const Q=TexturePool.getSameSizeTexture(X);let ee=X,te=Q;this._state.blend=!1;for(let re=0;re<this.passes-1;re++){Z.applyFilter(this,ee,te,Z.renderer.type===RendererType.WEBGPU);const ie=te;te=ee,ee=ie}this._state.blend=!0,Z.applyFilter(this,ee,K,J),TexturePool.returnTexture(Q)}}get blur(){return this.strength}set blur(Z){this.padding=1+Math.abs(Z)*2,this.strength=Z}get quality(){return this._quality}set quality(Z){this._quality=Z,this.passes=Z}};let BlurFilterPass=a$n;BlurFilterPass.defaultOptions={strength:8,quality:4,kernelSize:5};var y$7=Object.defineProperty,g$a=Object.defineProperties,c$e=Object.getOwnPropertyDescriptors,a$m=Object.getOwnPropertySymbols,f$g=Object.prototype.hasOwnProperty,x$6=Object.prototype.propertyIsEnumerable,p$m=(Z,X,K)=>X in Z?y$7(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$g=(Z,X)=>{for(var K in X||(X={}))f$g.call(X,K)&&p$m(Z,K,X[K]);if(a$m)for(var K of a$m(X))x$6.call(X,K)&&p$m(Z,K,X[K]);return Z},d$b=(Z,X)=>g$a(Z,c$e(X));class BlurFilter extends Filter{constructor(...X){var K;let J=(K=X[0])!=null?K:{};typeof J=="number"&&(deprecation(v8_0_0,"BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"),J={strength:J},X[1]&&(J.quality=X[1]),X[2]&&(J.resolution=X[2]),X[3]&&(J.kernelSize=X[3])),J=u$g(u$g({},BlurFilterPass.defaultOptions),J),super(d$b(u$g({},J),{compatibleRenderers:RendererType.WEBGL|RendererType.WEBGPU,resources:{}})),this._repeatEdgePixels=!1,this.blurXFilter=new BlurFilterPass(u$g({horizontal:!1},J)),this.blurYFilter=new BlurFilterPass(u$g({horizontal:!0},J)),this.quality=J.quality,this.blur=J.strength,this.repeatEdgePixels=!1}apply(X,K,J,Q){const ee=Math.abs(this.blurXFilter.strength),te=Math.abs(this.blurYFilter.strength);if(ee&&te){const re=TexturePool.getSameSizeTexture(K);this.blurXFilter.apply(X,K,re,!0),this.blurYFilter.apply(X,re,J,Q),TexturePool.returnTexture(re)}else te?this.blurYFilter.apply(X,K,J,Q):this.blurXFilter.apply(X,K,J,Q)}updatePadding(){this._repeatEdgePixels?this.padding=0:this.padding=Math.max(Math.abs(this.blurXFilter.blur),Math.abs(this.blurYFilter.blur))*2}get blur(){return this.blurXFilter.blur}set blur(X){this.blurXFilter.blur=this.blurYFilter.blur=X,this.updatePadding()}get quality(){return this.blurXFilter.quality}set quality(X){this.blurXFilter.quality=this.blurYFilter.quality=X}get blurX(){return this.blurXFilter.blur}set blurX(X){this.blurXFilter.blur=X,this.updatePadding()}get blurY(){return this.blurYFilter.blur}set blurY(X){this.blurYFilter.blur=X,this.updatePadding()}get blendMode(){return this.blurYFilter.blendMode}set blendMode(X){this.blurYFilter.blendMode=X}get repeatEdgePixels(){return this._repeatEdgePixels}set repeatEdgePixels(X){this._repeatEdgePixels=X,this.updatePadding()}}BlurFilter.defaultOptions={strength:8,quality:4,kernelSize:5};var F=`
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 fragColor;

uniform float uColorMatrix[20];
uniform float uAlpha;

uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * 0.2);
    float diff = (randomValue - 0.5) *  0.5;
    
    float[20] cm = uColorMatrix;


    if (uAlpha == 0.0) {
        fragColor = color;
        return;
    }

    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    vec4 result;

    result.r = (cm[0] * color.r);
        result.r += (cm[1] * color.g);
        result.r += (cm[2] * color.b);
        result.r += (cm[3] * color.a);
        result.r += cm[4];

    result.g = (cm[5] * color.r);
        result.g += (cm[6] * color.g);
        result.g += (cm[7] * color.b);
        result.g += (cm[8] * color.a);
        result.g += cm[9];

    result.b = (cm[10] * color.r);
       result.b += (cm[11] * color.g);
       result.b += (cm[12] * color.b);
       result.b += (cm[13] * color.a);
       result.b += cm[14];

    result.a = (cm[15] * color.r);
       result.a += (cm[16] * color.g);
       result.a += (cm[17] * color.b);
       result.a += (cm[18] * color.a);
       result.a += cm[19];

    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    fragColor = vec4(rgb, result.a);
}
`,d$a=`struct GlobalUniforms {
  projectionMatrix:mat3x3<f32>,
  worldTransformMatrix:mat3x3<f32>,
  worldAlpha: f32
}

struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,
};

struct ColorMatrixUniforms {
  uColorMatrix:array<vec4<f32>, 5>,
  uAlpha:f32,
};


@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;
@group(0) @binding(3) var backTexture: texture_2d<f32>;
@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
  };
  
fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
  );
}


@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
) -> @location(0) vec4<f32> {


  var c = textureSample(uSampler, mySampler, uv);
  
  if (colorMatrixUniforms.uAlpha == 0.0) {
    return c;
  }

 
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.r /= c.a;
      c.g /= c.a;
      c.b /= c.a;
    }

    var cm = colorMatrixUniforms.uColorMatrix;


    var result = vec4<f32>(0.);

    result.r = (cm[0][0] * c.r);
    result.r += (cm[0][1] * c.g);
    result.r += (cm[0][2] * c.b);
    result.r += (cm[0][3] * c.a);
    result.r += cm[1][0];

    result.g = (cm[1][1] * c.r);
    result.g += (cm[1][2] * c.g);
    result.g += (cm[1][3] * c.b);
    result.g += (cm[2][0] * c.a);
    result.g += cm[2][1];

    result.b = (cm[2][2] * c.r);
    result.b += (cm[2][3] * c.g);
    result.b += (cm[3][0] * c.b);
    result.b += (cm[3][1] * c.a);
    result.b += cm[3][2];

    result.a = (cm[3][3] * c.r);
    result.a += (cm[4][0] * c.g);
    result.a += (cm[4][1] * c.b);
    result.a += (cm[4][2] * c.a);
    result.a += cm[4][3];

    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);

    rgb.r *= result.a;
    rgb.g *= result.a;
    rgb.b *= result.a;

    return vec4(rgb, result.a);
}`;class ColorMatrixFilter extends Filter{constructor(){const X=new UniformGroup({uColorMatrix:{value:[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],type:"vec4<f32>",size:5},uAlpha:{value:1,type:"f32"}}),K=GpuProgram.from({vertex:{source:d$a,entryPoint:"mainVertex"},fragment:{source:d$a,entryPoint:"mainFragment"}}),J=GlProgram.from({vertex:P$6,fragment:F,name:"color-matrix-filter"});super({gpuProgram:K,glProgram:J,resources:{colorMatrixUniforms:X}}),this.alpha=1}_loadMatrix(X,K=!1){let J=X;K&&(this._multiply(J,this.matrix,X),J=this._colorMatrix(J)),this.resources.colorMatrixUniforms.uniforms.uColorMatrix=J,this.resources.colorMatrixUniforms.update()}_multiply(X,K,J){return X[0]=K[0]*J[0]+K[1]*J[5]+K[2]*J[10]+K[3]*J[15],X[1]=K[0]*J[1]+K[1]*J[6]+K[2]*J[11]+K[3]*J[16],X[2]=K[0]*J[2]+K[1]*J[7]+K[2]*J[12]+K[3]*J[17],X[3]=K[0]*J[3]+K[1]*J[8]+K[2]*J[13]+K[3]*J[18],X[4]=K[0]*J[4]+K[1]*J[9]+K[2]*J[14]+K[3]*J[19]+K[4],X[5]=K[5]*J[0]+K[6]*J[5]+K[7]*J[10]+K[8]*J[15],X[6]=K[5]*J[1]+K[6]*J[6]+K[7]*J[11]+K[8]*J[16],X[7]=K[5]*J[2]+K[6]*J[7]+K[7]*J[12]+K[8]*J[17],X[8]=K[5]*J[3]+K[6]*J[8]+K[7]*J[13]+K[8]*J[18],X[9]=K[5]*J[4]+K[6]*J[9]+K[7]*J[14]+K[8]*J[19]+K[9],X[10]=K[10]*J[0]+K[11]*J[5]+K[12]*J[10]+K[13]*J[15],X[11]=K[10]*J[1]+K[11]*J[6]+K[12]*J[11]+K[13]*J[16],X[12]=K[10]*J[2]+K[11]*J[7]+K[12]*J[12]+K[13]*J[17],X[13]=K[10]*J[3]+K[11]*J[8]+K[12]*J[13]+K[13]*J[18],X[14]=K[10]*J[4]+K[11]*J[9]+K[12]*J[14]+K[13]*J[19]+K[14],X[15]=K[15]*J[0]+K[16]*J[5]+K[17]*J[10]+K[18]*J[15],X[16]=K[15]*J[1]+K[16]*J[6]+K[17]*J[11]+K[18]*J[16],X[17]=K[15]*J[2]+K[16]*J[7]+K[17]*J[12]+K[18]*J[17],X[18]=K[15]*J[3]+K[16]*J[8]+K[17]*J[13]+K[18]*J[18],X[19]=K[15]*J[4]+K[16]*J[9]+K[17]*J[14]+K[18]*J[19]+K[19],X}_colorMatrix(X){const K=new Float32Array(X);return K[4]/=255,K[9]/=255,K[14]/=255,K[19]/=255,K}brightness(X,K){const J=[X,0,0,0,0,0,X,0,0,0,0,0,X,0,0,0,0,0,1,0];this._loadMatrix(J,K)}tint(X,K){const[J,Q,ee]=Color.shared.setValue(X).toArray(),te=[J,0,0,0,0,0,Q,0,0,0,0,0,ee,0,0,0,0,0,1,0];this._loadMatrix(te,K)}greyscale(X,K){const J=[X,X,X,0,0,X,X,X,0,0,X,X,X,0,0,0,0,0,1,0];this._loadMatrix(J,K)}grayscale(X,K){this.greyscale(X,K)}blackAndWhite(X){const K=[.3,.6,.1,0,0,.3,.6,.1,0,0,.3,.6,.1,0,0,0,0,0,1,0];this._loadMatrix(K,X)}hue(X,K){X=(X||0)/180*Math.PI;const J=Math.cos(X),Q=Math.sin(X),ee=Math.sqrt,te=1/3,re=ee(te),ie=J+(1-J)*te,ne=te*(1-J)-re*Q,se=te*(1-J)+re*Q,oe=te*(1-J)+re*Q,ae=J+te*(1-J),le=te*(1-J)-re*Q,ce=te*(1-J)-re*Q,de=te*(1-J)+re*Q,he=J+te*(1-J),pe=[ie,ne,se,0,0,oe,ae,le,0,0,ce,de,he,0,0,0,0,0,1,0];this._loadMatrix(pe,K)}contrast(X,K){const J=(X||0)+1,Q=-.5*(J-1),ee=[J,0,0,0,Q,0,J,0,0,Q,0,0,J,0,Q,0,0,0,1,0];this._loadMatrix(ee,K)}saturate(X=0,K){const J=X*2/3+1,Q=(J-1)*-.5,ee=[J,Q,Q,0,0,Q,J,Q,0,0,Q,Q,J,0,0,0,0,0,1,0];this._loadMatrix(ee,K)}desaturate(){this.saturate(-1)}negative(X){const K=[-1,0,0,1,0,0,-1,0,1,0,0,0,-1,1,0,0,0,0,1,0];this._loadMatrix(K,X)}sepia(X){const K=[.393,.7689999,.18899999,0,0,.349,.6859999,.16799999,0,0,.272,.5339999,.13099999,0,0,0,0,0,1,0];this._loadMatrix(K,X)}technicolor(X){const K=[1.9125277891456083,-.8545344976951645,-.09155508482755585,0,11.793603434377337,-.3087833385928097,1.7658908555458428,-.10601743074722245,0,-70.35205161461398,-.231103377548616,-.7501899197440212,1.847597816108189,0,30.950940869491138,0,0,0,1,0];this._loadMatrix(K,X)}polaroid(X){const K=[1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0];this._loadMatrix(K,X)}toBGR(X){const K=[0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0];this._loadMatrix(K,X)}kodachrome(X){const K=[1.1285582396593525,-.3967382283601348,-.03992559172921793,0,63.72958762196502,-.16404339962244616,1.0835251566291304,-.05498805115633132,0,24.732407896706203,-.16786010706155763,-.5603416277695248,1.6014850761964943,0,35.62982807460946,0,0,0,1,0];this._loadMatrix(K,X)}browni(X){const K=[.5997023498159715,.34553243048391263,-.2708298674538042,0,47.43192855600873,-.037703249837783157,.8609577587992641,.15059552388459913,0,-36.96841498319127,.24113635128153335,-.07441037908422492,.44972182064877153,0,-7.562075277591283,0,0,0,1,0];this._loadMatrix(K,X)}vintage(X){const K=[.6279345635605994,.3202183420819367,-.03965408211312453,0,9.651285835294123,.02578397704808868,.6441188644374771,.03259127616149294,0,7.462829176470591,.0466055556782719,-.0851232987247891,.5241648018700465,0,5.159190588235296,0,0,0,1,0];this._loadMatrix(K,X)}colorTone(X,K,J,Q,ee){X=X||.2,K=K||.15,J=J||16770432,Q=Q||3375104;const te=Color.shared,[re,ie,ne]=te.setValue(J).toArray(),[se,oe,ae]=te.setValue(Q).toArray(),le=[.3,.59,.11,0,0,re,ie,ne,X,0,se,oe,ae,K,0,re-se,ie-oe,ne-ae,0,0];this._loadMatrix(le,ee)}night(X,K){X=X||.1;const J=[X*-2,-X,0,0,0,-X,0,X,0,0,0,X,X*2,0,0,0,0,0,1,0];this._loadMatrix(J,K)}predator(X,K){const J=[11.224130630493164*X,-4.794486999511719*X,-2.8746118545532227*X,0*X,.40342438220977783*X,-3.6330697536468506*X,9.193157196044922*X,-2.951810836791992*X,0*X,-1.316135048866272*X,-3.2184197902679443*X,-4.2375030517578125*X,7.476448059082031*X,0*X,.8044459223747253*X,0,0,0,1,0];this._loadMatrix(J,K)}lsd(X){const K=[2,-.4,.5,0,0,-.5,2,-.4,0,0,-.4,-.5,3,0,0,0,0,0,1,0];this._loadMatrix(K,X)}reset(){const X=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0];this._loadMatrix(X,!1)}get matrix(){return this.resources.colorMatrixUniforms.uniforms.uColorMatrix}set matrix(X){this.resources.colorMatrixUniforms.uniforms.uColorMatrix=X}get alpha(){return this.resources.colorMatrixUniforms.uniforms.uAlpha}set alpha(X){this.resources.colorMatrixUniforms.uniforms.uAlpha=X}}var h$i=`
in vec2 vTextureCoord;
in vec2 vFilterUv;

out vec4 fragColor;

uniform sampler2D uSampler;
uniform sampler2D mapTexture;

uniform vec4 filterArea;
uniform vec4 filterClamp;
uniform vec4 inputClamp;
uniform highp vec4 inputSize;
uniform mat2 rotation;
uniform vec2 scale;


void main()
{
vec4 map = texture(mapTexture, vFilterUv);
    
    vec2 offset = inputSize.zw * (rotation * (map.xy - 0.5)) * scale; 

    fragColor = texture(uSampler, clamp(vTextureCoord + offset, inputClamp.xy, inputClamp.zw));
}
`,S$5=`in vec2 aPosition;
out vec2 vTextureCoord;
out vec2 vFilterUv;


uniform vec4 inputSize;
uniform vec4 outputFrame;
uniform vec4 outputTexture;

uniform mat3 filterMatrix;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;
    
    position.x = position.x * (2.0 / outputTexture.x) - 1.0;
    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (outputFrame.zw * inputSize.zw);
}

vec2 getFilterCoord( void )
{
  return ( filterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;
}


void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
    vFilterUv = getFilterCoord();
}
`,p$l=`struct GlobalUniforms {
  projectionMatrix:mat3x3<f32>,
  worldTransformMatrix:mat3x3<f32>,
  worldAlpha: f32
}

struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,
};

struct DisplacementUniforms {
  filterMatrix:mat3x3<f32>,
  scale:vec2<f32>,
  rotation:mat2x2<f32>
};



@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;
@group(1) @binding(1) var mapTexture: texture_2d<f32>;
@group(1) @binding(2) var mapSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{

  
  return gfu.globalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var map = textureSample(mapTexture, mapSampler, filterUv);
    
    var offset =  gfu.inputSize.zw * (filterUniforms.rotation * (map.xy - 0.5)) * filterUniforms.scale; 
   
     return textureSample(uSampler, mySampler, clamp(uv + offset, gfu.inputClamp.xy, gfu.inputClamp.zw));
}`;class DisplacementFilter extends Filter{constructor(...X){var K;let J=X[0];J instanceof Sprite&&(X[1]&&deprecation(v8_0_0,"DisplacementFilter now uses options object instead of params. {sprite, scale}"),J={sprite:J,scale:X[1]});let Q=(K=J.scale)!=null?K:20;typeof Q=="number"&&(Q=new Point(Q,Q));const ee=new UniformGroup({filterMatrix:{value:new Matrix,type:"mat3x3<f32>"},scale:{value:Q,type:"vec2<f32>"},rotation:{value:new Float32Array([0,0,0,0]),type:"vec4<f32>"}}),te=GlProgram.from({vertex:S$5,fragment:h$i,name:"displacement-filter"}),re=GpuProgram.from({vertex:{source:p$l,entryPoint:"mainVertex"},fragment:{source:p$l,entryPoint:"mainFragment"}}),ie=J.sprite.texture.source;super({gpuProgram:re,glProgram:te,resources:{filterUniforms:ee,mapTexture:ie,mapSampler:ie.style}}),this._sprite=J.sprite,this._sprite.renderable=!1}apply(X,K,J,Q){const ee=this.resources.filterUniforms.uniforms;X.calculateSpriteMatrix(ee.filterMatrix,this._sprite);const te=this._sprite.worldTransform,re=Math.sqrt(te.a*te.a+te.b*te.b),ie=Math.sqrt(te.c*te.c+te.d*te.d);re!==0&&ie!==0&&(ee.rotation[0]=te.a/re,ee.rotation[1]=te.b/re,ee.rotation[2]=te.c/ie,ee.rotation[3]=te.d/ie),this.resources.mapTexture=this._sprite.texture.source,X.applyFilter(this,K,J,Q)}get scale(){return this.resources.filterUniforms.uniforms.scale}}var U=`
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 fragColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * 0.2);
    float diff = (randomValue - 0.5) *  0.5;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    fragColor = color;
}
`,f$f=`

struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,
};

struct NoiseUniforms {
  uNoise:f32,
  uSeed:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;
@group(0) @binding(3) var backTexture: texture_2d<f32>;

@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.globalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

fn rand(co:vec2<f32>) -> f32
{
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}



@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.outputFrame.xy);
  
    
    var sample = textureSample(uSampler, mySampler, uv);
    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);
    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;
  
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (sample.a > 0.0) {
      sample.r /= sample.a;
      sample.g /= sample.a;
      sample.b /= sample.a;
    }

    sample.r += diff;
    sample.g += diff;
    sample.b += diff;

    // Premultiply alpha again.
    sample.r *= sample.a;
    sample.g *= sample.a;
    sample.b *= sample.a;
    
    return sample;
}`,p$k=Object.defineProperty,t$4=Object.getOwnPropertySymbols,g$9=Object.prototype.hasOwnProperty,l$h=Object.prototype.propertyIsEnumerable,m$i=(Z,X,K)=>X in Z?p$k(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$f=(Z,X)=>{for(var K in X||(X={}))g$9.call(X,K)&&m$i(Z,K,X[K]);if(t$4)for(var K of t$4(X))l$h.call(X,K)&&m$i(Z,K,X[K]);return Z};class NoiseFilter extends Filter{constructor(X={}){var K,J,Q;X=u$f({noise:.5,seed:Math.random()},X);const ee=new GpuProgram({vertex:{source:f$f,entryPoint:"mainVertex"},fragment:{source:f$f,entryPoint:"mainFragment"}}),te=new GlProgram({vertex:P$6,fragment:U,name:"noise-filter"});super({gpuProgram:ee,glProgram:te,resources:{noiseUniforms:new UniformGroup({uNoise:{value:X.noise,type:"f32"},uSeed:{value:(K=X.seed)!=null?K:Math.random(),type:"f32"}})},resolution:1});const re=(J=X.noise)!=null?J:.5,ie=(Q=X.seed)!=null?Q:Math.random();this.noise=re,this.seed=ie}get noise(){return this.resources.noiseUniforms.uniforms.uNoise}set noise(X){this.resources.noiseUniforms.uniforms.uNoise=X}get seed(){return this.resources.noiseUniforms.uniforms.uSeed}set seed(X){this.resources.noiseUniforms.uniforms.uSeed=X}}var P$5=`
in vec2 vTextureCoord;
in vec4 vColor;

uniform vec4 inputSize;
uniform vec4 inputClamp;

out vec4 fragColor;

uniform vec2 uCenter;
uniform float uTime;
uniform float uSpeed;
uniform vec4 uWave;

uniform sampler2D uSampler;


const float PI = 3.14159;

void main()
{
    float uAmplitude = uWave[0];
    float uWavelength = uWave[1];
    float uBrightness = uWave[2];
    float uRadius = uWave[3];

    float halfWavelength = uWavelength * 0.5 / inputSize.x;
    float maxRadius = uRadius / inputSize.x;
    float currentRadius = uTime * uSpeed / inputSize.x;

    float fade = 1.0;

    if (maxRadius > 0.0) {
        if (currentRadius > maxRadius) {
            fragColor = texture(uSampler, vTextureCoord);
            return;
        }
        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);
    }

    vec2 dir = vec2(vTextureCoord - uCenter / inputSize.xy);
    dir.y *= inputSize.y / inputSize.x;
    float dist = length(dir);

    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {
        fragColor = texture(uSampler, vTextureCoord);
        return;
    }

    vec2 diffUV = normalize(dir);

    float diff = (dist - currentRadius) / halfWavelength;

    float p = 1.0 - pow(abs(diff), 2.0);

    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );
    float powDiff = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );

    vec2 offset = diffUV * powDiff / inputSize.xy;

    // Do clamp :
    vec2 coord = vTextureCoord + offset;
    vec2 clampedCoord = clamp(coord, inputClamp.xy, inputClamp.zw);
    vec4 color = texture(uSampler, clampedCoord);
    if (coord != clampedCoord) {
        color *= max(0.0, 1.0 - length(coord - clampedCoord));
    }

    // No clamp :
    // fragColor = texture(uSampler, vTextureCoord + offset);

    color.rgb *= 1.0 + (uBrightness - 1.0) * p * fade;

    fragColor = color;
}
`,w$3=`in vec2 aPosition;
out vec2 vTextureCoord;

uniform globalUniforms {
  mat3 projectionMatrix;
  mat3 worldTransformMatrix;
  float worldAlpha;
};

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;
    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,f$e=`struct GlobalUniforms {
    projectionMatrix:mat3x3<f32>,
    worldTransformMatrix:mat3x3<f32>,
    worldAlpha: f32
}

struct GlobalFilterUniforms {
    inputSize:vec4<f32>,
    inputPixel:vec4<f32>,
    inputClamp:vec4<f32>,
    outputFrame:vec4<f32>,
    backgroundFrame:vec4<f32>,
    globalFrame:vec4<f32>,
};

struct ShockWaveUniforms {
    uTime: f32,
    uOffset: vec2<f32>,
    uSpeed: f32,
    uWave: vec4<f32>,
};
@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
@group(1) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(1) @binding(1) var uSampler: texture_2d<f32>;
@group(1) @binding(2) var mySampler : sampler;
@group(1) @binding(3) var backTexture: texture_2d<f32>;
@group(2) @binding(0) var<uniform> shockwaveUniforms : ShockWaveUniforms;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) backgroundUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;
    return vec4((globalUniforms.projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn filterBackgroundTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * gfu.backgroundFrame.zw;
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}
fn getSize() -> vec2<f32>
{
    return gfu.globalFrame.zw;
}

@vertex
fn mainVertex(
    @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
    return VSOutput(
        filterVertexPosition(aPosition),
        filterTextureCoord(aPosition),
        filterBackgroundTextureCoord(aPosition),
    );
}

@fragment
fn mainFragment(
    @location(0) uv: vec2<f32>,
    @location(1) backgroundUv: vec2<f32>,
    @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    let uTime = shockwaveUniforms.uTime;
    let uOffset = shockwaveUniforms.uOffset;
    let uSpeed = shockwaveUniforms.uSpeed;
    let uAmplitude = shockwaveUniforms.uWave[0];
    let uWavelength = shockwaveUniforms.uWave[1];
    let uBrightness = shockwaveUniforms.uWave[2];
    let uRadius = shockwaveUniforms.uWave[3];
    let halfWavelength: f32 = uWavelength * 0.5 / gfu.inputSize.x;
    let maxRadius: f32 = uRadius / gfu.inputSize.x;
    let currentRadius: f32 = uTime * uSpeed / gfu.inputSize.x;
    var fade: f32 = 1.0;
    var returnColorOnly: bool = false;
    
    if (maxRadius > 0.0) {
        if (currentRadius > maxRadius) {
            returnColorOnly = true;
        }
        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);
    }
    var dir: vec2<f32> = vec2<f32>(uv - uOffset / gfu.inputSize.xy);
    dir.y *= gfu.inputSize.y / gfu.inputSize.x;

    let dist:f32 = length(dir);

    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {
        returnColorOnly = true;
    }

    let diffUV: vec2<f32> = normalize(dir);
    let diff: f32 = (dist - currentRadius) / halfWavelength;
    let p: f32 = 1.0 - pow(abs(diff), 2.0);
    let powDiff: f32 = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );
    let offset: vec2<f32> = diffUV * powDiff / gfu.inputSize.xy;
    // Do clamp :
    let coord: vec2<f32> = uv + offset;
    let clampedCoord: vec2<f32> = clamp(coord, gfu.inputClamp.xy, gfu.inputClamp.zw);

    var clampedColor: vec4<f32> = textureSample(uSampler, mySampler, clampedCoord);
    
    if (boolVec2(coord, clampedCoord)) 
    {
        clampedColor *= max(0.0, 1.0 - length(coord - clampedCoord));
    }
    // No clamp :
    return select(clampedColor * vec4<f32>(vec3<f32>(1.0 + (uBrightness - 1.0) * p * fade), clampedColor.a), textureSample(uSampler, mySampler, uv), returnColorOnly);
}

fn boolVec2(x: vec2<f32>, y: vec2<f32>) -> bool
{
    if (x.x == y.x && x.y == y.y)
    {
        return true;
    }
    
    return false;
}

const PI: f32 = 3.14159265358979323846264;
`,h$h=Object.defineProperty,d$9=Object.defineProperties,b$a=Object.getOwnPropertyDescriptors,m$h=Object.getOwnPropertySymbols,c$d=Object.prototype.hasOwnProperty,g$8=Object.prototype.propertyIsEnumerable,o$h=(Z,X,K)=>X in Z?h$h(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,n$k=(Z,X)=>{for(var K in X||(X={}))c$d.call(X,K)&&o$h(Z,K,X[K]);if(m$h)for(var K of m$h(X))g$8.call(X,K)&&o$h(Z,K,X[K]);return Z},a$l=(Z,X)=>d$9(Z,b$a(X));const s$l=class extends Filter{constructor(Z={}){Z=n$k(n$k({},s$l.defaultOptions),Z);const X=new GpuProgram({vertex:{source:f$e,entryPoint:"mainVertex"},fragment:{source:f$e,entryPoint:"mainFragment"}}),K=new GlProgram({vertex:w$3,fragment:P$5,name:"shockwave-filter"});super({gpuProgram:X,glProgram:K,resources:{shockwaveUniforms:new UniformGroup({uTime:{value:0,type:"f32"},uCenter:{value:Z.center,type:"vec2<f32>"},uSpeed:{value:Z.speed,type:"f32"},uWave:{value:new Float32Array(4),type:"vec4<f32>"}})},resolution:1}),this.time=0,this.uniforms=this.resources.shockwaveUniforms.uniforms,Object.assign(this,Z)}apply(Z,X,K,J){this.uniforms.uTime=this.time,Z.applyFilter(this,X,K,J)}get center(){return this.uniforms.uCenter}set center(Z){this.uniforms.uCenter=Z}get centerX(){return this.uniforms.uCenter.x}set centerX(Z){this.uniforms.uCenter.x=Z}get centerY(){return this.uniforms.uCenter.y}set centerY(Z){this.uniforms.uCenter.y=Z}get speed(){return this.uniforms.uSpeed}set speed(Z){this.uniforms.uSpeed=Z}get amplitude(){return this.uniforms.uWave[0]}set amplitude(Z){this.uniforms.uWave[0]=Z}get wavelength(){return this.uniforms.uWave[1]}set wavelength(Z){this.uniforms.uWave[1]=Z}get brightness(){return this.uniforms.uWave[2]}set brightness(Z){this.uniforms.uWave[2]=Z}get radius(){return this.uniforms.uWave[3]}set radius(Z){this.uniforms.uWave[3]=Z}};let ShockwaveFilter=s$l;ShockwaveFilter.defaultOptions=a$l(n$k({},Filter.defaultOptions),{center:{x:0,y:0},speed:500,amplitude:30,wavelength:160,brightness:1,radius:-1});class FilterPipe{constructor(X){this._renderer=X}push(X,K,J){this._renderer.renderPipes.batch.break(J),J.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:K,filterEffect:X})}pop(X,K,J){this._renderer.renderPipes.batch.break(J),J.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(X){X.action==="pushFilter"?this._renderer.filter.push(X):X.action==="popFilter"&&this._renderer.filter.pop()}destroy(){this._renderer=null}}FilterPipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"filter"};class Buffer extends eventemitter3{constructor(X){let{data:K,size:J}=X;const{usage:Q,label:ee,shrinkToFit:te}=X;super(),this.uid=uid("buffer"),this._resourceType="buffer",this._resourceId=uid("bufferResource"),this._touched=0,this._updateID=1,this.shrinkToFit=!0,K instanceof Array&&(K=new Float32Array(K)),this._data=K,J=J!=null?J:K==null?void 0:K.byteLength;const re=!!K;this.descriptor={size:J,usage:Q,mappedAtCreation:re,label:ee},this.shrinkToFit=te!=null?te:!0}get data(){return this._data}set data(X){this.setDataWithSize(X,X.length,!0)}setDataWithSize(X,K,J){if(this._updateID++,this._updateSize=K*X.BYTES_PER_ELEMENT,this._data===X){J&&this.emit("update",this);return}const Q=this._data;if(this._data=X,Q.length!==X.length){!this.shrinkToFit&&X.byteLength<Q.byteLength?J&&this.emit("update",this):(this.descriptor.size=X.byteLength,this._resourceId=uid("bufferResource"),this.emit("change",this));return}J&&this.emit("update",this)}update(X){this._updateSize=X!=null?X:this._updateSize,this._updateID++,this.emit("update",this)}destroy(){this.emit("destroy",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}var BufferUsage=(Z=>(Z[Z.MAP_READ=1]="MAP_READ",Z[Z.MAP_WRITE=2]="MAP_WRITE",Z[Z.COPY_SRC=4]="COPY_SRC",Z[Z.COPY_DST=8]="COPY_DST",Z[Z.INDEX=16]="INDEX",Z[Z.VERTEX=32]="VERTEX",Z[Z.UNIFORM=64]="UNIFORM",Z[Z.STORAGE=128]="STORAGE",Z[Z.INDIRECT=256]="INDIRECT",Z[Z.QUERY_RESOLVE=512]="QUERY_RESOLVE",Z[Z.STATIC=1024]="STATIC",Z))(BufferUsage||{});function ensureIsBuffer(Z,X){if(!(Z instanceof Buffer)){let K=X?BufferUsage.INDEX:BufferUsage.VERTEX;Z instanceof Array&&(X?(Z=new Uint32Array(Z),K=BufferUsage.INDEX|BufferUsage.COPY_DST):(Z=new Float32Array(Z),K=BufferUsage.VERTEX|BufferUsage.COPY_DST)),Z=new Buffer({data:Z,label:X?"index-mesh-buffer":"vertex-mesh-buffer",usage:K})}return Z}class Geometry extends eventemitter3{constructor(X){const{attributes:K,indexBuffer:J,topology:Q}=X;super(),this.uid=uid("geometry"),this._layoutKey=0,this.attributes=K,this.buffers=[];for(const ee in K){const te=K[ee];te.buffer=ensureIsBuffer(te.buffer,!1),this.buffers.indexOf(te.buffer)===-1&&(this.buffers.push(te.buffer),te.buffer.on("update",this.onBufferUpdate,this))}J&&(this.indexBuffer=ensureIsBuffer(J,!0),this.buffers.push(this.indexBuffer)),this.topology=Q||"triangle-list"}onBufferUpdate(){this.emit("update",this)}getAttribute(X){return this.attributes[X]}getIndex(){return this.indexBuffer}getBuffer(X){return this.getAttribute(X).buffer}getSize(){for(const X in this.attributes){const K=this.attributes[X];return this.getBuffer(X).data.length/(K.stride/4||K.size)}return 0}destroy(X=!1){this.emit("destroy",this),this.removeAllListeners(),X&&this.buffers.forEach(K=>K.destroy()),this.attributes=null,this.buffers=null}}function getGlobalRenderableBounds(Z,X){X.clear();const K=X.matrix;for(let J=0;J<Z.length;J++){const Q=Z[J];Q.layerVisibleRenderable<3||(X.matrix=Q.worldTransform,Q.view.addBounds(X))}return X.matrix=K,X}const W$5=new Geometry({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),shaderLocation:0,format:"float32x2",stride:2*4,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class FilterSystem{constructor(X){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new UniformGroup({inputSize:{value:new Float32Array(4),type:"vec4<f32>"},inputPixel:{value:new Float32Array(4),type:"vec4<f32>"},inputClamp:{value:new Float32Array(4),type:"vec4<f32>"},outputFrame:{value:new Float32Array(4),type:"vec4<f32>"},globalFrame:{value:new Float32Array(4),type:"vec4<f32>"},outputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new BindGroup({}),this.renderer=X}push(X){var K,J;const Q=this.renderer,ee=X.filterEffect.filters;this._filterStack[this._filterStackIndex]||(this._filterStack[this._filterStackIndex]=this._getFilterData());const te=this._filterStack[this._filterStackIndex];this._filterStackIndex++;const re=te.bounds;if(X.renderables?getGlobalRenderableBounds(X.renderables,re):X.filterEffect.filterArea?(re.addRect(X.filterEffect.filterArea),re.applyMatrix(X.container.worldTransform)):getGlobalBounds(X.container,!0,re),ee.length===0){te.skip=!0;return}let ie=Q.renderTarget.rootRenderTarget.colorTexture.source._resolution,ne=0,se=Q.renderTarget.rootRenderTarget.colorTexture.source.antialias,oe=!1,ae=!1;for(let le=0;le<ee.length;le++){const ce=ee[le];if(ie=Math.min(ie,ce.resolution),ne+=ce.padding,ce.antialias!=="inherit"&&(ce.antialias==="on"?se=!0:se=!1),!(ce.compatibleRenderers&Q.type)){ae=!1;break}if(ce.blendRequired&&!((J=(K=Q.backBuffer)==null?void 0:K.useBackBuffer)==null||J)){ae=!1;break}ae=ce.enabled||ae,oe=oe||ce.blendRequired}if(!ae){te.skip=!0;return}if(re.scale(ie).fit(Q.renderTarget.rootViewPort).scale(1/ie).pad(ne).ceil(),!re.isPositive){te.skip=!0;return}te.skip=!1,te.bounds=re,te.blendRequired=oe,te.container=X.container,te.filterEffect=X.filterEffect,te.previousRenderSurface=Q.renderTarget.renderTarget,te.inputTexture=TexturePool.getOptimalTexture(re.width,re.height,ie,se),Q.renderTarget.bind(te.inputTexture,!0),Q.globalUniforms.push({offset:re})}pop(){const X=this.renderer;this._filterStackIndex--;const K=this._filterStack[this._filterStackIndex];if(K.skip)return;this._activeFilterData=K;const J=K.inputTexture,Q=K.bounds;let ee=Texture.EMPTY;if(X.renderTarget.finishRenderPass(),K.blendRequired){const re=this._filterStackIndex>0?this._filterStack[this._filterStackIndex-1].bounds:null;ee=this.getBackTexture(K.previousRenderSurface,Q,re)}K.backTexture=ee;const te=K.filterEffect.filters;if(this._globalFilterBindGroup.setResource(J.source.style,2),this._globalFilterBindGroup.setResource(ee.source,3),X.globalUniforms.pop(),te.length===1)te[0].apply(this,J,K.previousRenderSurface,!1),TexturePool.returnTexture(J);else{let re=K.inputTexture,ie=TexturePool.getOptimalTexture(Q.width,Q.height,re.source._resolution,!1),ne=0;for(ne=0;ne<te.length-1;++ne){te[ne].apply(this,re,ie,!0);const se=re;re=ie,ie=se}te[ne].apply(this,re,K.previousRenderSurface,!1),TexturePool.returnTexture(re),TexturePool.returnTexture(ie)}K.blendRequired&&TexturePool.returnTexture(ee)}getBackTexture(X,K,J){const Q=X.colorTexture.source._resolution,ee=TexturePool.getOptimalTexture(K.width,K.height,Q,!1);let te=K.minX,re=K.minY;J&&(te-=J.minX,re-=J.minY),te=Math.floor(te*Q),re=Math.floor(re*Q);const ie=Math.ceil(K.width*Q),ne=Math.ceil(K.height*Q);return this.renderer.renderTarget.copyToTexture(X,ee,{x:te,y:re},{width:ie,height:ne}),ee}applyFilter(X,K,J,Q){const ee=this.renderer,te=this._filterStack[this._filterStackIndex],re=te.bounds,ie=Point.shared,ne=te.previousRenderSurface===this.renderer.renderTarget.getRenderTarget(J);let se=this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,oe=this._filterStackIndex-1;for(;oe>0&&this._filterStack[oe].skip;)--oe;oe>0&&(se=this._filterStack[oe].inputTexture.source._resolution);const ae=this._filterGlobalUniforms,le=ae.uniforms,ce=le.outputFrame,de=le.inputSize,he=le.inputPixel,pe=le.inputClamp,fe=le.globalFrame,ge=le.outputTexture;ne?(this._filterStackIndex>0&&(ie.x=this._filterStack[this._filterStackIndex-1].bounds.minX,ie.y=this._filterStack[this._filterStackIndex-1].bounds.minY),ce[0]=re.minX-ie.x,ce[1]=re.minY-ie.y):(ce[0]=0,ce[1]=0),ce[2]=K.frameWidth,ce[3]=K.frameHeight,de[0]=K.source.width,de[1]=K.source.height,de[2]=1/de[0],de[3]=1/de[1],he[0]=K.source.pixelWidth,he[1]=K.source.pixelHeight,he[2]=1/he[0],he[3]=1/he[1],pe[0]=.5*he[2],pe[1]=.5*he[3],pe[2]=K.frameWidth*de[2]-.5*he[2],pe[3]=K.frameHeight*de[3]-.5*he[3];const me=this.renderer.renderTarget.rootRenderTarget.colorTexture;fe[0]=ie.x*se,fe[1]=ie.y*se,fe[2]=me.source.width*se,fe[3]=me.source.height*se;const ye=this.renderer.renderTarget.getRenderTarget(J);if(ee.renderTarget.bind(J,!!Q),J instanceof Texture?(ge[0]=J.frameWidth,ge[1]=J.frameHeight):(ge[0]=ye.width,ge[1]=ye.height),ge[2]=ye.isRoot?-1:1,ae.update(),ee.renderPipes.uniformBatch){const _e=ee.renderPipes.uniformBatch.getUniformBufferResource(this._filterGlobalUniforms);this._globalFilterBindGroup.setResource(_e,0)}else this._globalFilterBindGroup.setResource(ae,0);this._globalFilterBindGroup.setResource(K.source,1),this._globalFilterBindGroup.setResource(K.source.style,2),X.groups[0]=this._globalFilterBindGroup,ee.encoder.draw({geometry:W$5,shader:X,state:X._state,topology:"triangle-list"})}_getFilterData(){return{skip:!1,inputTexture:null,bounds:new Bounds,container:null,filterEffect:null,blendRequired:!1,previousRenderSurface:null}}calculateSpriteMatrix(X,K){const J=this._activeFilterData,Q=X.set(J.inputTexture._source.width,0,0,J.inputTexture._source.height,J.bounds.minX,J.bounds.minY),ee=K.worldTransform.copyTo(Matrix.shared);return ee.invert(),Q.prepend(ee),Q.scale(1/K.texture.frameWidth,1/K.texture.frameHeight),Q.translate(K.anchor.x,K.anchor.y),Q}}FilterSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem],name:"filter"};var l$g=`in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mapTexture;

uniform float alpha;
uniform vec4 maskClamp;

out vec4 fragColor;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = alpha; 
    vec4 original = texture(uSampler, vTextureCoord);
    vec4 masky = texture(mapTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    fragColor = original;
}
`,f$d=`in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 inputSize;
uniform vec4 outputFrame;
uniform vec4 outputTexture;
uniform mat3 filterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * outputFrame.zw + outputFrame.xy;
       
    position.x = position.x * (2.0 / outputTexture.x) - 1.0;
    position.y = position.y * (2.0*outputTexture.z / outputTexture.y) - outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (outputFrame.zw * inputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`,o$g=`struct GlobalFilterUniforms {
  inputSize:vec4<f32>,
  inputPixel:vec4<f32>,
  inputClamp:vec4<f32>,
  outputFrame:vec4<f32>,
  globalFrame:vec4<f32>,
  outputTexture:vec4<f32>,  
};

struct MaskUniforms {
  filterMatrix:mat3x3<f32>,
  maskClamp:vec4<f32>,
  alpha:f32,
};


@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uSampler: texture_2d<f32>;
@group(0) @binding(2) var mySampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var mapTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.outputFrame.zw + gfu.outputFrame.xy;

    position.x = position.x * (2.0 / gfu.outputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.outputTexture.z / gfu.outputTexture.y) - gfu.outputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.outputFrame.zw * gfu.inputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.globalFrame.zw) + (gfu.globalFrame.xy / gfu.globalFrame.zw);  
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.filterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{

  
  return gfu.globalFrame.zw;
}
  
@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.maskClamp;

     var clip = step(3.5,
        step(maskClamp.x, filterUv.x) +
        step(maskClamp.y, filterUv.y) +
        step(filterUv.x, maskClamp.z) +
        step(filterUv.y, maskClamp.w));

    var mask = textureSample(mapTexture, mySampler, filterUv);
    var source = textureSample(uSampler, mySampler, uv);
    
    var npmAlpha = 0.0;

    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);

    var a = (alphaMul * mask.r) * clip;

    return vec4(source.rgb, source.a) * a;
}`;class MaskFilter extends Filter{constructor({sprite:X}){const K=new TextureMatrix(X.texture),J=new UniformGroup({filterMatrix:{value:new Matrix,type:"mat3x3<f32>"},maskClamp:{value:K.uClampFrame,type:"vec4<f32>"},alpha:{value:1,type:"f32"}}),Q=new GpuProgram({vertex:{source:o$g,entryPoint:"mainVertex"},fragment:{source:o$g,entryPoint:"mainFragment"}}),ee=GlProgram.from({vertex:f$d,fragment:l$g,name:"mask-filter"});super({gpuProgram:Q,glProgram:ee,resources:{filterUniforms:J,mapTexture:X.texture.source}}),this.sprite=X,this._textureMatrix=K}apply(X,K,J,Q){this._textureMatrix.texture=this.sprite.texture,X.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.filterMatrix,this.sprite).prepend(this._textureMatrix.mapCoord),this.resources.mapTexture=this.sprite.texture.source,X.applyFilter(this,K,J,Q)}}class Triangle{constructor(X=0,K=0,J=0,Q=0,ee=0,te=0){this.type="triangle",this.x=X,this.y=K,this.x2=J,this.y2=Q,this.x3=ee,this.y3=te}contains(X,K){const J=(this.x-this.x3)*(K-this.y3)-(this.y-this.y3)*(X-this.x3),Q=(this.x2-this.x)*(K-this.y)-(this.y2-this.y)*(X-this.x);if(J<0!=Q<0&&J!==0&&Q!==0)return!1;const ee=(this.x3-this.x2)*(K-this.y2)-(this.y3-this.y2)*(X-this.x2);return ee===0||ee<0==J+Q<=0}clone(){return new Triangle(this.x,this.y,this.x2,this.y2,this.x3,this.y3)}copyFrom(X){return this.x=X.x,this.y=X.y,this.x2=X.x2,this.y2=X.y2,this.x3=X.x3,this.y3=X.y3,this}copyTo(X){return X.copyFrom(this),X}getBounds(X){X=X||new Rectangle;const K=Math.min(this.x,this.x2,this.x3),J=Math.max(this.x,this.x2,this.x3),Q=Math.min(this.y,this.y2,this.y3),ee=Math.max(this.y,this.y2,this.y3);return X.x=K,X.y=Q,X.width=J-K,X.height=ee-Q,X}}function addBits(Z,X,K){if(Z)for(const J in Z){const Q=J.toLocaleLowerCase(),ee=X[Q];if(ee){let te=Z[J];J==="header"&&(te=te.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),K&&ee.push(`//----${K}----//`),ee.push(te)}}}const findHooksRx=/\{\{(.*?)\}\}/g;function compileHooks(Z){var X,K;const J={};return((K=(X=Z.match(findHooksRx))==null?void 0:X.map(Q=>Q.replace(/[{()}]/g,"")))!=null?K:[]).forEach(Q=>{J[Q]=[]}),J}function o$f(Z,X){let K;const J=/@in\s+([^;]+);/g;for(;(K=J.exec(Z))!==null;)X.push(K[1])}function compileInputs(Z,X,K=!1){const J=[];o$f(X,J),Z.forEach(re=>{re.header&&o$f(re.header,J)});const Q=J;K&&Q.sort();const ee=Q.map((re,ie)=>`       @location(${ie}) ${re},`).join(`
`);let te=X.replace(/@in\s+[^;]+;\s*/g,"");return te=te.replace("{{in}}",`
${ee}
`),te}function i$c(Z,X){let K;const J=/@out\s+([^;]+);/g;for(;(K=J.exec(Z))!==null;)X.push(K[1])}function l$f(Z){const X=/\b(\w+)\s*:/g.exec(Z);return X?X[1]:""}function p$j(Z){const X=/@.*?\s+/g;return Z.replace(X,"")}function compileOutputs(Z,X){const K=[];i$c(X,K),Z.forEach(ie=>{ie.header&&i$c(ie.header,K)});let J=0;const Q=K.sort().map(ie=>ie.indexOf("builtin")>-1?ie:`@location(${J++}) ${ie}`).join(`,
`),ee=K.sort().map(ie=>`       var ${p$j(ie)};`).join(`
`),te=`return VSOutput(
                ${K.sort().map(ie=>` ${l$f(ie)}`).join(`,
`)});`;let re=X.replace(/@out\s+[^;]+;\s*/g,"");return re=re.replace("{{struct}}",`
${Q}
`),re=re.replace("{{start}}",`
${ee}
`),re=re.replace("{{return}}",`
${te}
`),re}function injectBits(Z,X){let K=Z;for(const J in X){const Q=X[J];Q.join(`
`).length?K=K.replace(`{{${J}}}`,`//-----${J} START-----//
${Q.join(`
`)}
//----${J} FINISH----//`):K=K.replace(`{{${J}}}`,"")}return K}const o$e=Object.create(null),m$g=new Map;let S$4=0;function compileHighShader({template:Z,bits:X}){const K=f$c(Z,X);if(o$e[K])return o$e[K];const{vertex:J,fragment:Q}=H$2(Z,X);return o$e[K]=u$e(J,Q,X),o$e[K]}function compileHighShaderGl({template:Z,bits:X}){const K=f$c(Z,X);return o$e[K]||(o$e[K]=u$e(Z.vertex,Z.fragment,X)),o$e[K]}function H$2(Z,X){const K=X.map(te=>te.vertex).filter(te=>!!te),J=X.map(te=>te.fragment).filter(te=>!!te);let Q=compileInputs(K,Z.vertex);Q=compileOutputs(K,Q);const ee=compileInputs(J,Z.fragment,!0);return{vertex:Q,fragment:ee}}function f$c(Z,X){return X.map(K=>(m$g.has(K)||m$g.set(K,S$4++),m$g.get(K))).sort((K,J)=>K-J).join("-")+Z.vertex+Z.fragment}function u$e(Z,X,K){const J=compileHooks(Z),Q=compileHooks(X);return K.forEach(ee=>{addBits(ee.vertex,J,ee.name),addBits(ee.fragment,Q,ee.name)}),{vertex:injectBits(Z,J),fragment:injectBits(X,Q)}}const o$d=`
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.worldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);
        vUV = aUV;

        {{main}}

        var modelViewProjectionMatrix = globalUniforms.projectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.worldAlpha;

        {{end}}

        {{return}}
    };
`,r$4=`
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`,t$3=`
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = worldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;

        {{start}}
        
        vColor = vec4(1.);
        vUV = aUV;

        {{main}}

        mat3 modelViewProjectionMatrix = projectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= worldAlpha;

        {{end}}
    }
`,i$b=`
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`,globalUniformsBit={name:"global-uniforms-bit",vertex:{header:`
        struct GlobalUniforms {
            projectionMatrix:mat3x3<f32>,
            worldTransformMatrix:mat3x3<f32>,
            worldAlpha: f32,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `}},globalUniformsBitGl={name:"global-uniforms-bit",vertex:{header:`
          uniform globalUniforms {
            mat3 projectionMatrix;
            mat3 worldTransformMatrix;
            float worldAlpha;
            vec2 uResolution;
          };
        `}};var a$k=Object.defineProperty,m$f=Object.getOwnPropertySymbols,n$j=Object.prototype.hasOwnProperty,p$i=Object.prototype.propertyIsEnumerable,i$a=(Z,X,K)=>X in Z?a$k(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$c=(Z,X)=>{for(var K in X||(X={}))n$j.call(X,K)&&i$a(Z,K,X[K]);if(m$f)for(var K of m$f(X))p$i.call(X,K)&&i$a(Z,K,X[K]);return Z};function compileHighShaderGpuProgram({bits:Z,name:X}){const K=compileHighShader({template:{fragment:r$4,vertex:o$d},bits:[globalUniformsBit,...Z]});return new GpuProgram({name:X,vertex:{source:K.vertex,entryPoint:"main"},fragment:{source:K.fragment,entryPoint:"main"}})}function compileHighShaderGlProgram({bits:Z,name:X}){return new GlProgram(o$c({name:X},compileHighShaderGl({template:{vertex:t$3,fragment:i$b},bits:[globalUniformsBitGl,...Z]})))}const colorBit={name:"color-bit",vertex:{header:`
            @in aColor: vec4<f32>;
        `,main:`
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `}},colorBitGl={name:"color-bit",vertex:{header:`
            in vec4 aColor;
        `,main:`
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `}},n$i={};function o$b(Z){const X=[];if(Z===1)X.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),X.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let K=0;for(let J=0;J<Z;J++)X.push(`@group(1) @binding(${K++}) var textureSource${J+1}: texture_2d<f32>;`),X.push(`@group(1) @binding(${K++}) var textureSampler${J+1}: sampler;`)}return X.join(`
`)}function a$j(Z){const X=[];if(Z===1)X.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{X.push("switch vTextureId {");for(let K=0;K<Z;K++)K===Z-1?X.push("  default:{"):X.push(`  case ${K}:{`),X.push(`      outColor = textureSampleGrad(textureSource${K+1}, textureSampler${K+1}, vUV, uvDx, uvDy);`),X.push("      break;}");X.push("}")}return X.join(`
`)}function generateTextureBatchBit(Z){return n$i[Z]||(n$i[Z]={name:"texture-batch-bit",vertex:{header:`
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `},fragment:{header:`
                @in @interpolate(flat) vTextureId: u32;
    
                ${o$b(16)}
            `,main:`
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);
    
                ${a$j(16)}
            `}}),n$i[Z]}const i$9={};function d$8(Z){const X=[];for(let K=0;K<Z;K++)K>0&&X.push("else"),K<Z-1&&X.push(`if(vTextureId < ${K}.5)`),X.push("{"),X.push(`	outColor = texture(uSamplers[${K}], vUV);`),X.push("}");return X.join(`
`)}function generateTextureBatchBitGl(Z){return i$9[Z]||(i$9[Z]={name:"texture-batch-bit",vertex:{header:`
                in vec2 aTextureIdAndRound;
                out float vTextureId;
              
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `},fragment:{header:`
                in float vTextureId;
    
                uniform sampler2D uSamplers[${Z}];
              
            `,main:`
    
                ${d$8(16)}
            `}}),i$9[Z]}const roundPixelsBit={name:"round-pixels-bit",vertex:{header:`
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;
            }
        `}},roundPixelsBitGl={name:"round-pixels-bit",vertex:{header:`   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;
            }
        `}},MAX_TEXTURES=16,o$a=new Int32Array(MAX_TEXTURES);for(let Z=0;Z<MAX_TEXTURES;Z++)o$a[Z]=Z;const batchSamplersUniformGroup=new UniformGroup({uSamplers:{value:o$a,type:"u32",size:MAX_TEXTURES}},{isStatic:!0});class GlBatchAdaptor{constructor(){this._didUpload=!1,this._tempState=State.for2d()}init(){const X=new UniformGroup({tint:{value:new Float32Array([1,1,1,1]),type:"f32"},translationMatrix:{value:new Matrix,type:"mat3x3<f32>"}}),K=compileHighShaderGlProgram({name:"batch",bits:[colorBitGl,generateTextureBatchBitGl(MAX_TEXTURES),roundPixelsBitGl]});this._shader=new Shader({glProgram:K,resources:{uniforms:X,batchSamplers:batchSamplersUniformGroup}})}start(X,K){const J=X.renderer;J.shader.bind(this._shader,this._didUpload),J.shader.bindUniformBlock(J.globalUniforms.uniformGroup,"globalUniforms",0),J.geometry.bind(K,this._shader.glProgram)}execute(X,K){const J=X.renderer;this._didUpload=!0,this._tempState.blendMode=K.blendMode,J.state.set(this._tempState);const Q=K.textures.textures;for(let ee=0;ee<Q.length;ee++)J.texture.bind(Q[ee],ee);J.geometry.draw("triangle-list",K.size,K.start)}destroy(){this._shader.destroy(!0),this._shader=null}}GlBatchAdaptor.extension={type:[u$v.WebGLPipesAdaptor],name:"batch"};const s$k=new Float32Array(1),n$h=new Uint32Array(1);class BatchGeometry extends Geometry{constructor(){const X=new Buffer({data:s$k,label:"attribute-batch-buffer",usage:BufferUsage.VERTEX|BufferUsage.COPY_DST,shrinkToFit:!1}),K=new Buffer({data:n$h,label:"index-batch-buffer",usage:BufferUsage.INDEX|BufferUsage.COPY_DST,shrinkToFit:!1}),J=6*4;super({attributes:{aPosition:{buffer:X,shaderLocation:0,format:"float32x2",stride:J,offset:0},aUV:{buffer:X,shaderLocation:1,format:"float32x2",stride:J,offset:2*4},aColor:{buffer:X,shaderLocation:2,format:"unorm8x4",stride:J,offset:4*4},aTextureIdAndRound:{buffer:X,shaderLocation:3,format:"uint16x2",stride:J,offset:5*4}},indexBuffer:K})}}function generateGPULayout(Z){const X=[];let K=0;for(let J=0;J<Z;J++)X[K]={texture:{sampleType:"float",viewDimension:"2d",multisampled:!1},binding:K,visibility:GPUShaderStage.FRAGMENT},K++,X[K]={sampler:{type:"filtering"},binding:K,visibility:GPUShaderStage.FRAGMENT},K++;return X}function generateLayout(Z){const X={};let K=0;for(let J=0;J<Z;J++)X[`textureSource${J+1}`]=K++,X[`textureSampler${J+1}`]=K++;return X}const i$8={};function getTextureBatchBindGroup(Z,X){let K=0;for(let J=0;J<X;J++)K=K*31+Z[J].uid>>>0;return i$8[K]||m$e(Z,K)}function m$e(Z,X){const K={};let J=0;for(let ee=0;ee<MAX_TEXTURES;ee++){const te=ee<Z.length?Z[ee]:Texture.EMPTY.source;K[J++]=te.source,K[J++]=te.style}const Q=new BindGroup(K);return i$8[X]=Q,Q}const n$g=State.for2d();class GpuBatchAdaptor{init(){const X=compileHighShaderGpuProgram({name:"batch",bits:[colorBit,generateTextureBatchBit(MAX_TEXTURES),roundPixelsBit]});this._shader=new Shader({gpuProgram:X,groups:{}})}start(X,K){const J=X.renderer,Q=J.encoder,ee=this._shader.gpuProgram;this._geometry=K,Q.setGeometry(K),n$g.blendMode="normal",J.pipeline.getPipeline(K,ee,n$g);const te=J.globalUniforms.bindGroup;Q.setBindGroup(0,te,ee)}execute(X,K){const J=this._shader.gpuProgram,Q=X.renderer,ee=Q.encoder;if(!K.bindGroup){const ie=K.textures;K.bindGroup=getTextureBatchBindGroup(ie.textures,ie.count)}n$g.blendMode=K.blendMode;const te=Q.bindGroup.getBindGroup(K.bindGroup,J,1),re=Q.pipeline.getPipeline(this._geometry,J,n$g);K.bindGroup._touch(Q.textureGC.count),ee.setPipeline(re),ee.renderPassEncoder.setBindGroup(1,te),ee.renderPassEncoder.drawIndexed(K.size,1,K.start)}destroy(){this._shader.destroy(!0),this._shader=null}}GpuBatchAdaptor.extension={type:[u$v.WebGPUPipesAdaptor],name:"batch"};class ViewableBuffer{constructor(X){typeof X=="number"?this.rawBinaryData=new ArrayBuffer(X):X instanceof Uint8Array?this.rawBinaryData=X.buffer:this.rawBinaryData=X,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData),this.size=this.rawBinaryData.byteLength}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}get float64View(){return this._float64Array||(this._float64Array=new Float64Array(this.rawBinaryData)),this._float64Array}get bigUint64View(){return this._bigUint64Array||(this._bigUint64Array=new BigUint64Array(this.rawBinaryData)),this._bigUint64Array}view(X){return this[`${X}View`]}destroy(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this.uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null}static sizeOf(X){switch(X){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${X} isn't a valid view type`)}}}function fastCopy(Z,X){const K=Z.byteLength/8|0,J=new Float64Array(Z,0,K),Q=new Float64Array(X,0,K);for(let re=0;re<K;re++)Q[re]=J[re];const ee=new Uint8Array(Z,K*8),te=new Uint8Array(X,K*8);for(let re=0;re<ee.length;re++)te[re]=ee[re]}const BLEND_TO_NPM={normal:"normal-npm",add:"add-npm",screen:"screen-npm"};var STENCIL_MODES=(Z=>(Z[Z.DISABLED=0]="DISABLED",Z[Z.RENDERING_MASK_ADD=1]="RENDERING_MASK_ADD",Z[Z.MASK_ACTIVE=2]="MASK_ACTIVE",Z[Z.RENDERING_MASK_REMOVE=3]="RENDERING_MASK_REMOVE",Z[Z.NONE=4]="NONE",Z))(STENCIL_MODES||{});function getAdjustedBlendModeBlend(Z,X){return X.alphaMode==="no-premultiply-alpha"&&BLEND_TO_NPM[Z]||Z}class BatchTextureArray{constructor(){this.ids=Object.create(null),this.textures=[],this.count=0}clear(){for(let X=0;X<this.count;X++){const K=this.textures[X];this.textures[X]=null,this.ids[K.uid]=null}this.count=0}}var P$4=Object.defineProperty,z$1=Object.getOwnPropertySymbols,M$2=Object.prototype.hasOwnProperty,T$6=Object.prototype.propertyIsEnumerable,I$2=(Z,X,K)=>X in Z?P$4(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,B$1=(Z,X)=>{for(var K in X||(X={}))M$2.call(X,K)&&I$2(Z,K,X[K]);if(z$1)for(var K of z$1(X))T$6.call(X,K)&&I$2(Z,K,X[K]);return Z};class Batch{constructor(){this.renderPipeId="batch",this.action="startBatch",this.start=0,this.size=0,this.blendMode="normal",this.canBundle=!0}destroy(){this.textures=null,this.gpuBindGroup=null,this.bindGroup=null,this.batcher=null}}let d$7=0;const p$h=class{constructor(Z={}){this.uid=uid("batcher"),this.dirty=!0,this.batchIndex=0,this.batches=[],this._vertexSize=6,this._elements=[],this._batchPool=[],this._batchPoolIndex=0,this._textureBatchPool=[],this._textureBatchPoolIndex=0,Z=B$1(B$1({},p$h.defaultOptions),Z);const{vertexSize:X,indexSize:K}=Z;this.attributeBuffer=new ViewableBuffer(X*this._vertexSize*4),this.indexBuffer=new Uint32Array(K)}begin(){this.batchIndex=0,this.elementSize=0,this.elementStart=0,this.indexSize=0,this.attributeSize=0,this._batchPoolIndex=0,this._textureBatchPoolIndex=0,this._batchIndexStart=0,this._batchIndexSize=0,this.dirty=!0}add(Z){this._elements[this.elementSize++]=Z,Z.indexStart=this.indexSize,Z.location=this.attributeSize,Z.batcher=this,this.indexSize+=Z.indexSize,this.attributeSize+=Z.vertexSize*this._vertexSize}checkAndUpdateTexture(Z,X){const K=Z.batch.textures.ids[X._source.uid];return!K&&K!==0?!1:(Z.textureId=K,Z.texture=X,!0)}updateElement(Z){this.dirty=!0,Z.packAttributes(this.attributeBuffer.float32View,this.attributeBuffer.uint32View,Z.location,Z.textureId)}break(Z){const X=this._elements;let K=this._textureBatchPool[this._textureBatchPoolIndex++]||new BatchTextureArray;if(K.clear(),!X[this.elementStart])return;const J=X[this.elementStart];let Q=getAdjustedBlendModeBlend(J.blendMode,J.texture._source);this.attributeSize*4>this.attributeBuffer.size&&this._resizeAttributeBuffer(this.attributeSize*4),this.indexSize>this.indexBuffer.length&&this._resizeIndexBuffer(this.indexSize);const ee=this.attributeBuffer.float32View,te=this.attributeBuffer.uint32View,re=this.indexBuffer;let ie=this._batchIndexSize,ne=this._batchIndexStart,se="startBatch",oe=this._batchPool[this._batchPoolIndex++]||new Batch;for(let ae=this.elementStart;ae<this.elementSize;++ae){const le=X[ae];X[ae]=null;const ce=le.texture._source,de=getAdjustedBlendModeBlend(le.blendMode,ce),he=Q!==de;if(ce._batchTick===d$7&&!he){le.textureId=ce._textureBindLocation,ie+=le.indexSize,le.packAttributes(ee,te,le.location,le.textureId),le.packIndex(re,le.indexStart,le.location/this._vertexSize),le.batch=oe;continue}ce._batchTick=d$7,(K.count>=MAX_TEXTURES||he)&&(this._finishBatch(oe,ne,ie-ne,K,Q,Z,se),se="renderBatch",ne=ie,Q=de,K=this._textureBatchPool[this._textureBatchPoolIndex++]||new BatchTextureArray,K.clear(),oe=this._batchPool[this._batchPoolIndex++]||new Batch,++d$7),le.textureId=ce._textureBindLocation=K.count,K.ids[ce.uid]=K.count,K.textures[K.count++]=ce,le.batch=oe,ie+=le.indexSize,le.packAttributes(ee,te,le.location,le.textureId),le.packIndex(re,le.indexStart,le.location/this._vertexSize)}K.count>0&&(this._finishBatch(oe,ne,ie-ne,K,Q,Z,se),ne=ie,++d$7),this.elementStart=this.elementSize,this._batchIndexStart=ne,this._batchIndexSize=ie}_finishBatch(Z,X,K,J,Q,ee,te){Z.gpuBindGroup=null,Z.action=te,Z.batcher=this,Z.textures=J,Z.blendMode=Q,Z.start=X,Z.size=K,++d$7,ee.add(Z)}finish(Z){this.break(Z)}ensureAttributeBuffer(Z){Z*4<=this.attributeBuffer.size||this._resizeAttributeBuffer(Z*4)}ensureIndexBuffer(Z){Z<=this.indexBuffer.length||this._resizeIndexBuffer(Z)}_resizeAttributeBuffer(Z){const X=Math.max(Z,this.attributeBuffer.size*2),K=new ViewableBuffer(X);fastCopy(this.attributeBuffer.rawBinaryData,K.rawBinaryData),this.attributeBuffer=K}_resizeIndexBuffer(Z){const X=this.indexBuffer,K=Math.max(Z,X.length*2),J=new Uint32Array(K);fastCopy(X.buffer,J.buffer),this.indexBuffer=J}destroy(){for(let Z=0;Z<this.batches.length;Z++)this.batches[Z].destroy();this.batches=null;for(let Z=0;Z<this._elements.length;Z++)this._elements[Z].batch=null;this._elements=null,this.indexBuffer=null,this.attributeBuffer.destroy(),this.attributeBuffer=null}};let Batcher=p$h;Batcher.defaultOptions={vertexSize:4,indexSize:6};class BatcherPipe{constructor(X,K){this.state=State.for2d(),this._batches=Object.create(null),this._geometries=Object.create(null),this.renderer=X,this._adaptor=K,this._adaptor.init()}buildStart(X){if(!this._batches[X.uid]){const K=new Batcher;this._batches[X.uid]=K,this._geometries[K.uid]=new BatchGeometry}this._activeBatch=this._batches[X.uid],this._activeGeometry=this._geometries[this._activeBatch.uid],this._activeBatch.begin()}addToBatch(X){this._activeBatch.add(X)}break(X){this._activeBatch.break(X)}buildEnd(X){const K=this._activeBatch,J=this._activeGeometry;K.finish(X),J.indexBuffer.setDataWithSize(K.indexBuffer,K.indexSize,!0),J.buffers[0].setDataWithSize(K.attributeBuffer.float32View,K.attributeSize,!1)}upload(X){const K=this._batches[X.uid],J=this._geometries[K.uid];K.dirty&&(K.dirty=!1,J.buffers[0].update(K.attributeSize*4))}execute(X){if(X.action==="startBatch"){const K=X.batcher,J=this._geometries[K.uid];this._adaptor.start(this,J)}this._adaptor.execute(this,X)}destroy(){this.state=null,this.renderer=null,this._adaptor.destroy(),this._adaptor=null;for(const X in this._batches)this._batches[X].destroy();this._batches=null;for(const X in this._geometries)this._geometries[X].destroy();this._geometries=null}}BatcherPipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"batch"};function formatShader(Z){const X=Z.split(/([\n{}])/g).map(J=>J.trim()).filter(J=>J.length);let K="";return X.map(J=>{let Q=K+J;return J==="{"?K+="    ":J==="}"&&(K=K.substr(0,K.length-4),Q=K+J),Q}).join(`
`)}var t$2=Object.defineProperty,u$d=Object.defineProperties,m$d=Object.getOwnPropertyDescriptors,e$1=Object.getOwnPropertySymbols,f$b=Object.prototype.hasOwnProperty,s$j=Object.prototype.propertyIsEnumerable,a$i=(Z,X,K)=>X in Z?t$2(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,n$f=(Z,X)=>{for(var K in X||(X={}))f$b.call(X,K)&&a$i(Z,K,X[K]);if(e$1)for(var K of e$1(X))s$j.call(X,K)&&a$i(Z,K,X[K]);return Z},l$e=(Z,X)=>u$d(Z,m$d(X));const localUniformBit={name:"local-uniform-bit",vertex:{header:`

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}},localUniformBitGroup2=l$e(n$f({},localUniformBit),{vertex:l$e(n$f({},localUniformBit.vertex),{header:localUniformBit.vertex.header.replace("group(1)","group(2)")})}),localUniformBitGl={name:"local-uniform-bit",vertex:{header:`

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}},textureBit={name:"texture-bit",fragment:{header:`
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `,main:`
            outColor = textureSample(uTexture, uSampler, vUV);
        `}},textureBitGl={name:"texture-bit",fragment:{header:`
        uniform sampler2D uTexture;

         
        `,main:`
            outColor = texture(uTexture, vUV);
        `}};class LayerRenderable extends eventemitter3{constructor({original:X,view:K}){super(),this.uid=uid("renderable"),this.view=K,this._original=X,this.layerTransform=new Matrix,this.layerColor=4294967295,this.layerVisibleRenderable=3,this.view.owner=this}get layerBlendMode(){return this._original.layerBlendMode}onViewUpdate(){this.didViewUpdate=!0,this._original.layerGroup.onChildViewUpdate(this)}get isRenderable(){return this._original.isRenderable}}function buildInstructions(Z,X){const K=Z.root,J=Z.instructionSet;J.reset(),X.batch.buildStart(J),X.blendMode.buildStart(),X.colorMask.buildStart(),K.sortableChildren&&K.sortChildren(),s$i(K,J,X,!0),X.batch.buildEnd(J),X.blendMode.buildEnd(J)}function collectAllRenderables(Z,X,K){Z.layerVisibleRenderable<3||!Z.includeInBuild||(Z.sortableChildren&&Z.sortChildren(),Z.isSimple?a$h(Z,X,K):s$i(Z,X,K,!1))}function a$h(Z,X,K){const J=Z.view;if(J&&(K.blendMode.setBlendMode(Z,Z.layerBlendMode,X),Z.didViewUpdate=!1,K[J.renderPipeId].addRenderable(Z,X)),!Z.isLayerRoot){const Q=Z.children,ee=Q.length;for(let te=0;te<ee;te++)collectAllRenderables(Q[te],X,K)}}function s$i(Z,X,K,J){var Q;if(J){const ee=Z.layerGroup;if(ee.root.view){const te=(Q=ee.proxyRenderable)!=null?Q:f$a(ee);te&&(K.blendMode.setBlendMode(te,te.layerBlendMode,X),K[te.view.renderPipeId].addRenderable(te,X))}}else for(let ee=0;ee<Z.effects.length;ee++){const te=Z.effects[ee];K[te.pipe].push(te,Z,X)}if(!J&&Z.isLayerRoot)K.layer.addLayerGroup(Z.layerGroup,X);else{const ee=Z.view;ee&&(K.blendMode.setBlendMode(Z,Z.layerBlendMode,X),Z.didViewUpdate=!1,K[ee.renderPipeId].addRenderable(Z,X));const te=Z.children;if(te.length)for(let re=0;re<te.length;re++)collectAllRenderables(te[re],X,K)}if(!J)for(let ee=Z.effects.length-1;ee>=0;ee--){const te=Z.effects[ee];K[te.pipe].pop(te,Z,X)}}function f$a(Z){const X=Z.root;Z.proxyRenderable=new LayerRenderable({original:X,view:X.view})}const g$7=new Bounds;class I$1 extends FilterEffect{constructor(){super({filters:[new MaskFilter({sprite:new Sprite(Texture.EMPTY)})]})}get sprite(){return this.filters[0].sprite}set sprite(X){this.filters[0].sprite=X}}class AlphaMaskPipe{constructor(X){this._activeMaskStage=[],this._renderer=X}push(X,K,J){const Q=this._renderer;if(Q.renderPipes.batch.break(J),J.add({renderPipeId:"alphaMask",action:"pushMaskBegin",mask:X,canBundle:!1,maskedContainer:K}),X.renderMaskToTexture){const ee=X.mask;ee.includeInBuild=!0,collectAllRenderables(ee,J,Q.renderPipes),ee.includeInBuild=!1}Q.renderPipes.batch.break(J),J.add({renderPipeId:"alphaMask",action:"pushMaskEnd",mask:X,maskedContainer:K,canBundle:!1})}pop(X,K,J){this._renderer.renderPipes.batch.break(J),J.add({renderPipeId:"alphaMask",action:"popMaskEnd",mask:X,canBundle:!1})}execute(X){const K=this._renderer,J=X.mask.renderMaskToTexture;if(X.action==="pushMaskBegin"){const Q=BigPool.get(I$1);if(J){X.mask.mask.measurable=!0;const ee=getGlobalBounds(X.mask.mask,!0,g$7);X.mask.mask.measurable=!1,ee.ceil();const te=TexturePool.getOptimalTexture(ee.width,ee.height,1,!1);K.renderTarget.push(te,!0),K.globalUniforms.push({offset:ee,worldColor:4294967295});const re=Q.sprite;re.texture=te,re.worldTransform.tx=ee.minX,re.worldTransform.ty=ee.minY,this._activeMaskStage.push({filterEffect:Q,maskedContainer:X.maskedContainer,filterTexture:te})}else Q.sprite=X.mask.mask,this._activeMaskStage.push({filterEffect:Q,maskedContainer:X.maskedContainer})}else if(X.action==="pushMaskEnd"){const Q=this._activeMaskStage[this._activeMaskStage.length-1];J&&(K.renderTarget.pop(),K.globalUniforms.pop()),K.filter.push({renderPipeId:"filter",action:"pushFilter",container:Q.maskedContainer,filterEffect:Q.filterEffect,canBundle:!1})}else if(X.action==="popMaskEnd"){K.filter.pop();const Q=this._activeMaskStage.pop();J&&TexturePool.returnTexture(Q.filterTexture),BigPool.return(Q.filterEffect)}}destroy(){this._renderer=null,this._activeMaskStage=null}}AlphaMaskPipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"alphaMask"};class ColorMaskPipe{constructor(X){this._colorStack=[],this._colorStackIndex=0,this._currentColor=0,this._renderer=X}buildStart(){this._colorStack[0]=15,this._colorStackIndex=1,this._currentColor=15}push(X,K,J){this._renderer.renderPipes.batch.break(J);const Q=this._colorStack;Q[this._colorStackIndex]=Q[this._colorStackIndex-1]&X.mask;const ee=this._colorStack[this._colorStackIndex];ee!==this._currentColor&&(this._currentColor=ee,J.add({renderPipeId:"colorMask",colorMask:ee,canBundle:!1})),this._colorStackIndex++}pop(X,K,J){this._renderer.renderPipes.batch.break(J);const Q=this._colorStack;this._colorStackIndex--;const ee=Q[this._colorStackIndex-1];ee!==this._currentColor&&(this._currentColor=ee,J.add({renderPipeId:"colorMask",colorMask:ee,canBundle:!1}))}execute(X){this._renderer.colorMask.setMask(X.colorMask)}destroy(){this._colorStack=null}}ColorMaskPipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"colorMask"};class ScissorMask{constructor(X){this.priority=0,this.pipe="scissorMask",this.mask=X,this.mask.renderable=!1,this.mask.measurable=!1}addBounds(X,K){addMaskBounds(this.mask,X,K)}addLocalBounds(X,K){addMaskLocalBounds(this.mask,X,K)}containsPoint(X,K){const J=this.mask;return K(J,X)}reset(){this.mask.measurable=!0,this.mask=null}destroy(){this.reset()}}var CLEAR=(Z=>(Z[Z.NONE=0]="NONE",Z[Z.COLOR=16384]="COLOR",Z[Z.STENCIL=1024]="STENCIL",Z[Z.DEPTH=256]="DEPTH",Z[Z.COLOR_DEPTH=16640]="COLOR_DEPTH",Z[Z.COLOR_STENCIL=17408]="COLOR_STENCIL",Z[Z.DEPTH_STENCIL=1280]="DEPTH_STENCIL",Z[Z.ALL=17664]="ALL",Z))(CLEAR||{});class StencilMaskPipe{constructor(X){this._maskStackHash={},this._maskHash=new WeakMap,this._renderer=X}push(X,K,J){const Q=X,ee=this._renderer;ee.renderPipes.batch.break(J),ee.renderPipes.blendMode.setBlendMode(Q.mask,"none",J),J.add({renderPipeId:"stencilMask",action:"pushMaskBegin",mask:X,canBundle:!1});const te=Q.mask;te.includeInBuild=!0,this._maskHash.has(Q)||this._maskHash.set(Q,{instructionsStart:0,instructionsLength:0});const re=this._maskHash.get(Q);re.instructionsStart=J.instructionSize,collectAllRenderables(te,J,ee.renderPipes),te.includeInBuild=!1,ee.renderPipes.batch.break(J),J.add({renderPipeId:"stencilMask",action:"pushMaskEnd",mask:X,canBundle:!1});const ie=J.instructionSize-re.instructionsStart-1;re.instructionsLength=ie;const ne=ee.renderTarget.renderTarget.uid;this._maskStackHash[ne]===void 0&&(this._maskStackHash[ne]=0),this._maskStackHash[ne]++}pop(X,K,J){const Q=X,ee=this._renderer,te=ee.renderTarget.renderTarget.uid;this._maskStackHash[te]--,ee.renderPipes.batch.break(J),ee.renderPipes.blendMode.setBlendMode(Q.mask,"none",J),J.add({renderPipeId:"stencilMask",action:"popMaskBegin",canBundle:!1});const re=this._maskHash.get(X);if(this._maskStackHash[te]!==0)for(let ie=0;ie<re.instructionsLength;ie++)J.instructions[J.instructionSize++]=J.instructions[re.instructionsStart++];J.add({renderPipeId:"stencilMask",action:"popMaskEnd",canBundle:!1})}execute(X){var K;const J=this._renderer,Q=J.renderTarget.renderTarget.uid;let ee=(K=this._maskStackHash[Q])!=null?K:0;X.action==="pushMaskBegin"?(ee++,J.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD,ee),J.colorMask.setMask(0)):X.action==="pushMaskEnd"?(J.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE,ee),J.colorMask.setMask(15)):X.action==="popMaskBegin"?(ee--,ee!==0?(J.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE,ee),J.colorMask.setMask(0)):J.renderTarget.clear(CLEAR.STENCIL)):X.action==="popMaskEnd"&&(ee===0?J.stencil.setStencilMode(STENCIL_MODES.DISABLED,ee):J.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE,ee),J.colorMask.setMask(15)),this._maskStackHash[Q]=ee}destroy(){this._renderer=null,this._maskStackHash=null,this._maskHash=null}}StencilMaskPipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"stencilMask"};var BUFFER_TYPE=(Z=>(Z[Z.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",Z[Z.ARRAY_BUFFER=34962]="ARRAY_BUFFER",Z[Z.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER",Z))(BUFFER_TYPE||{});class GlBuffer{constructor(X,K){this.buffer=X||null,this.updateID=-1,this.byteLength=-1,this.type=K}}class GlBufferSystem{constructor(X){this._gpuBuffers=Object.create(null),this._boundBufferBases=Object.create(null),this._renderer=X}destroy(){this.destroyAll(!0),this._renderer=null,this._gl=null,this._gpuBuffers=null,this._boundBufferBases=null}contextChange(){this.destroyAll(!0),this._gl=this._renderer.gl}getGlBuffer(X){return this._gpuBuffers[X.uid]||this.createGLBuffer(X)}bind(X){const{_gl:K}=this,J=this.getGlBuffer(X);K.bindBuffer(J.type,J.buffer)}bindBufferBase(X,K){const{_gl:J}=this;if(this._boundBufferBases[K]!==X){const Q=this.getGlBuffer(X);this._boundBufferBases[K]=X,J.bindBufferBase(J.UNIFORM_BUFFER,K,Q.buffer)}}bindBufferRange(X,K,J){const{_gl:Q}=this;J=J||0;const ee=this.getGlBuffer(X);Q.bindBufferRange(Q.UNIFORM_BUFFER,K||0,ee.buffer,J*256,256)}updateBuffer(X){const{_gl:K}=this,J=this.getGlBuffer(X);if(X._updateID===J.updateID)return J;if(J.updateID=X._updateID,K.bindBuffer(J.type,J.buffer),J.byteLength>=X.data.byteLength)K.bufferSubData(J.type,0,X.data,0,X._updateSize/4);else{const Q=X.descriptor.usage&BufferUsage.STATIC?K.STATIC_DRAW:K.DYNAMIC_DRAW;J.byteLength=X.data.byteLength,K.bufferData(J.type,X.data,Q)}return J}destroyAll(X){const K=this._gl;if(!X)for(const J in this._gpuBuffers)K.deleteBuffer(this._gpuBuffers[J].buffer);this._gpuBuffers={}}onBufferDestroy(X,K){const J=this._gpuBuffers[X.uid],Q=this._gl;K||Q.deleteBuffer(J.buffer),this._gpuBuffers[X.uid]=null}createGLBuffer(X){const{_gl:K}=this;let J=BUFFER_TYPE.ARRAY_BUFFER;X.descriptor.usage&BufferUsage.INDEX?J=BUFFER_TYPE.ELEMENT_ARRAY_BUFFER:X.descriptor.usage&BufferUsage.UNIFORM&&(J=BUFFER_TYPE.UNIFORM_BUFFER);const Q=new GlBuffer(K.createBuffer(),J);return this._gpuBuffers[X.uid]=Q,X.on("destroy",this.onBufferDestroy,this),Q}}GlBufferSystem.extension={type:[u$v.WebGLSystem],name:"buffer"};class GlContextSystem{constructor(X){this._renderer=X,this.webGLVersion=2,this.extensions=Object.create(null),this.supports={uint32Indices:!1},this.handleContextLost=this.handleContextLost.bind(this),this.handleContextRestored=this.handleContextRestored.bind(this)}get isLost(){return!this.gl||this.gl.isContextLost()}contextChange(X){this.gl=X,this._renderer.gl=X,X.isContextLost()&&X.getExtension("WEBGL_lose_context")&&X.getExtension("WEBGL_lose_context").restoreContext()}init(X){var K,J;if(X!=null&&X.context)this.initFromContext(X.context);else{const Q=this._renderer.background.alpha<1,ee=(K=X.premultipliedAlpha)!=null?K:!0,te=X.antialias&&!this._renderer.backBuffer.useBackBuffer;this.initFromOptions({alpha:Q,premultipliedAlpha:ee,antialias:te,stencil:!0,preserveDrawingBuffer:X.preserveDrawingBuffer,powerPreference:(J=X.powerPreference)!=null?J:"default"})}}initFromContext(X){this.gl=X,this.validateContext(X),this._renderer.runners.contextChange.emit(X);const K=this._renderer.view.canvas;K.addEventListener("webglcontextlost",this.handleContextLost,!1),K.addEventListener("webglcontextrestored",this.handleContextRestored,!1)}initFromOptions(X){const K=this.createContext(this._renderer.view.canvas,X);this.initFromContext(K)}createContext(X,K){const J=X.getContext("webgl2",K);return this.webGLVersion=2,this.gl=J,this.getExtensions(),this.gl}getExtensions(){const{gl:X}=this,K={anisotropicFiltering:X.getExtension("EXT_texture_filter_anisotropic"),floatTextureLinear:X.getExtension("OES_texture_float_linear"),s3tc:X.getExtension("WEBGL_compressed_texture_s3tc"),s3tc_sRGB:X.getExtension("WEBGL_compressed_texture_s3tc_srgb"),etc:X.getExtension("WEBGL_compressed_texture_etc"),etc1:X.getExtension("WEBGL_compressed_texture_etc1"),pvrtc:X.getExtension("WEBGL_compressed_texture_pvrtc")||X.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),atc:X.getExtension("WEBGL_compressed_texture_atc"),astc:X.getExtension("WEBGL_compressed_texture_astc"),bptc:X.getExtension("EXT_texture_compression_bptc")};Object.assign(this.extensions,K,{colorBufferFloat:X.getExtension("EXT_color_buffer_float")})}handleContextLost(X){X.preventDefault()}handleContextRestored(){this._renderer.runners.contextChange.emit(this.gl)}destroy(){const X=this._renderer.view.canvas;this._renderer=null,X.removeEventListener("webglcontextlost",this.handleContextLost),X.removeEventListener("webglcontextrestored",this.handleContextRestored),this.gl.useProgram(null),this.extensions.loseContext&&this.extensions.loseContext.loseContext()}validateContext(X){const K=X.getContextAttributes(),J="WebGL2RenderingContext"in globalThis&&X instanceof globalThis.WebGL2RenderingContext;J&&(this.webGLVersion=2),K&&K.stencil;const Q=J||!!X.getExtension("OES_element_index_uint");this.supports.uint32Indices=Q}}GlContextSystem.extension={type:[u$v.WebGLSystem],name:"context"},GlContextSystem.defaultOptions={context:null,premultipliedAlpha:!0,preserveDrawingBuffer:!1,powerPreference:void 0};var GL_FORMATS=(Z=>(Z[Z.RGBA=6408]="RGBA",Z[Z.RGB=6407]="RGB",Z[Z.RG=33319]="RG",Z[Z.RED=6403]="RED",Z[Z.RGBA_INTEGER=36249]="RGBA_INTEGER",Z[Z.RGB_INTEGER=36248]="RGB_INTEGER",Z[Z.RG_INTEGER=33320]="RG_INTEGER",Z[Z.RED_INTEGER=36244]="RED_INTEGER",Z[Z.ALPHA=6406]="ALPHA",Z[Z.LUMINANCE=6409]="LUMINANCE",Z[Z.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",Z[Z.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",Z[Z.DEPTH_STENCIL=34041]="DEPTH_STENCIL",Z))(GL_FORMATS||{}),GL_TARGETS=(Z=>(Z[Z.TEXTURE_2D=3553]="TEXTURE_2D",Z[Z.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",Z[Z.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",Z[Z.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",Z[Z.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",Z[Z.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",Z[Z.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",Z[Z.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",Z[Z.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",Z))(GL_TARGETS||{}),GL_WRAP_MODES=(Z=>(Z[Z.CLAMP=33071]="CLAMP",Z[Z.REPEAT=10497]="REPEAT",Z[Z.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT",Z))(GL_WRAP_MODES||{}),GL_TYPES=(Z=>(Z[Z.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",Z[Z.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",Z[Z.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",Z[Z.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",Z[Z.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",Z[Z.UNSIGNED_INT=5125]="UNSIGNED_INT",Z[Z.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",Z[Z.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",Z[Z.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",Z[Z.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",Z[Z.BYTE=5120]="BYTE",Z[Z.SHORT=5122]="SHORT",Z[Z.INT=5124]="INT",Z[Z.FLOAT=5126]="FLOAT",Z[Z.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",Z[Z.HALF_FLOAT=36193]="HALF_FLOAT",Z))(GL_TYPES||{});const i$7={uint8x2:{type:GL_TYPES.UNSIGNED_BYTE,size:2,normalised:!1},uint8x4:{type:GL_TYPES.UNSIGNED_BYTE,size:4,normalised:!1},sint8x2:{type:GL_TYPES.BYTE,size:2,normalised:!1},sint8x4:{type:GL_TYPES.BYTE,size:4,normalised:!1},unorm8x2:{type:GL_TYPES.UNSIGNED_BYTE,size:2,normalised:!0},unorm8x4:{type:GL_TYPES.UNSIGNED_BYTE,size:4,normalised:!0},snorm8x2:{type:GL_TYPES.BYTE,size:2,normalised:!0},snorm8x4:{type:GL_TYPES.BYTE,size:4,normalised:!0},uint16x2:{type:GL_TYPES.UNSIGNED_SHORT,size:2,normalised:!1},uint16x4:{type:GL_TYPES.UNSIGNED_SHORT,size:4,normalised:!1},sint16x2:{type:GL_TYPES.SHORT,size:2,normalised:!1},sint16x4:{type:GL_TYPES.SHORT,size:4,normalised:!1},unorm16x2:{type:GL_TYPES.UNSIGNED_SHORT,size:2,normalised:!0},unorm16x4:{type:GL_TYPES.UNSIGNED_SHORT,size:4,normalised:!0},snorm16x2:{type:GL_TYPES.SHORT,size:2,normalised:!0},snorm16x4:{type:GL_TYPES.SHORT,size:4,normalised:!0},float16x2:{type:GL_TYPES.HALF_FLOAT,size:2,normalised:!1},float16x4:{type:GL_TYPES.HALF_FLOAT,size:4,normalised:!1},float32:{type:GL_TYPES.FLOAT,size:1,normalised:!1},float32x2:{type:GL_TYPES.FLOAT,size:2,normalised:!1},float32x3:{type:GL_TYPES.FLOAT,size:3,normalised:!1},float32x4:{type:GL_TYPES.FLOAT,size:4,normalised:!1},uint32:{type:GL_TYPES.UNSIGNED_INT,size:1,normalised:!1},uint32x2:{type:GL_TYPES.UNSIGNED_INT,size:2,normalised:!1},uint32x3:{type:GL_TYPES.UNSIGNED_INT,size:3,normalised:!1},uint32x4:{type:GL_TYPES.UNSIGNED_INT,size:4,normalised:!1},sint32:{type:GL_TYPES.INT,size:1,normalised:!1},sint32x2:{type:GL_TYPES.INT,size:2,normalised:!1},sint32x3:{type:GL_TYPES.INT,size:3,normalised:!1},sint32x4:{type:GL_TYPES.INT,size:4,normalised:!1}};function getGlInfoFromFormat(Z){var X;return(X=i$7[Z])!=null?X:i$7.float32}const h$g={5126:4,5123:2,5121:1},p$g={"point-list":0,"line-list":1,"line-strip":3,"triangle-list":4,"triangle-strip":5};class GlGeometrySystem{constructor(X){this._geometryVaoHash={},this._renderer=X,this._activeGeometry=null,this._activeVao=null,this.hasVao=!0,this.hasInstance=!0,this.canUseUInt32ElementIndex=!0}contextChange(){this.gl=this._renderer.gl}bind(X,K){const J=this.gl;this._activeGeometry=X;const Q=this.getVao(X,K);this._activeVao!==Q&&(this._activeVao=Q,J.bindVertexArray(Q)),this.updateBuffers()}reset(){this.unbind()}updateBuffers(){const X=this._activeGeometry,K=this._renderer.buffer;for(let J=0;J<X.buffers.length;J++){const Q=X.buffers[J];K.updateBuffer(Q)}}checkCompatibility(X,K){const J=X.attributes,Q=K._attributeData;for(const ee in Q)if(!J[ee])throw new Error(`shader and geometry incompatible, geometry missing the "${ee}" attribute`)}getSignature(X,K){const J=X.attributes,Q=K._attributeData,ee=["g",X.uid];for(const te in J)Q[te]&&ee.push(te,Q[te].location);return ee.join("-")}getVao(X,K){var J;return((J=this._geometryVaoHash[X.uid])==null?void 0:J[K._key])||this.initGeometryVao(X,K)}initGeometryVao(X,K,J=!0){const Q=this._renderer.gl,ee=this._renderer.buffer;this._renderer.shader._getProgramData(K),this.checkCompatibility(X,K);const te=this.getSignature(X,K);this._geometryVaoHash[X.uid]||(this._geometryVaoHash[X.uid]=Object.create(null),X.on("destroy",this.onGeometryDestroy,this));const re=this._geometryVaoHash[X.uid];let ie=re[te];if(ie)return re[K._key]=ie,ie;const ne=X.buffers,se=X.attributes,oe={},ae={};for(const le in ne)oe[le]=0,ae[le]=0;for(const le in se)!se[le].size&&K._attributeData[le]?se[le].size=K._attributeData[le].size:se[le].size,oe[se[le].buffer.uid]+=se[le].size*h$g[se[le].type];for(const le in se){const ce=se[le],de=ce.size;ce.stride===void 0&&(oe[ce.buffer.uid]===de*h$g[ce.type]?ce.stride=0:ce.stride=oe[ce.buffer.uid]),ce.start===void 0&&(ce.start=ae[ce.buffer.uid],ae[ce.buffer.uid]+=de*h$g[ce.type])}ie=Q.createVertexArray(),Q.bindVertexArray(ie);for(let le=0;le<ne.length;le++){const ce=ne[le];ee.bind(ce)}return this.activateVao(X,K),re[K._key]=ie,re[te]=ie,Q.bindVertexArray(null),ie}onGeometryDestroy(X,K){const J=this._geometryVaoHash[X.uid],Q=this.gl;if(J){if(K)for(const ee in J)this._activeVao!==J[ee]&&this.unbind(),Q.deleteVertexArray(J[ee]);this._geometryVaoHash[X.uid]=null}}destroyAll(X=!1){const K=this.gl;for(const J in this._geometryVaoHash){if(X)for(const Q in this._geometryVaoHash[J]){const ee=this._geometryVaoHash[J];this._activeVao!==ee&&this.unbind(),K.deleteVertexArray(ee[Q])}this._geometryVaoHash[J]=null}}activateVao(X,K){const J=this._renderer.gl,Q=this._renderer.buffer,ee=X.attributes;X.indexBuffer&&Q.bind(X.indexBuffer);let te=null;for(const re in ee){const ie=ee[re],ne=ie.buffer,se=Q.getGlBuffer(ne);if(K._attributeData[re]){te!==se&&(Q.bind(ne),te=se);const oe=K._attributeData[re].location;J.enableVertexAttribArray(oe);const ae=getGlInfoFromFormat(ie.format);if(J.vertexAttribPointer(oe,ae.size,ae.type,ae.normalised,ie.stride,ie.offset),ie.instance)if(this.hasInstance)J.vertexAttribDivisor(oe,1);else throw new Error("geometry error, GPU Instancing is not supported on this device")}}}draw(X,K,J,Q){const{gl:ee}=this._renderer,te=this._activeGeometry,re=p$g[te.topology||X];if(te.indexBuffer){const ie=te.indexBuffer.data.BYTES_PER_ELEMENT,ne=ie===2?ee.UNSIGNED_SHORT:ee.UNSIGNED_INT;te.instanced?ee.drawElementsInstanced(re,K||te.indexBuffer.data.length,ne,(J||0)*ie,te.instanceCount||1):ee.drawElements(re,K||te.indexBuffer.data.length,ne,(J||0)*ie)}else te.instanced?ee.drawArraysInstanced(re,J,K||te.getSize(),Q||1):ee.drawArrays(re,J,K||te.getSize());return this}unbind(){this.gl.bindVertexArray(null),this._activeVao=null,this._activeGeometry=null}destroy(){this._renderer=null,this.gl=null,this._activeVao=null,this._activeGeometry=null}}GlGeometrySystem.extension={type:[u$v.WebGLSystem],name:"geometry"};var c$c=Object.defineProperty,n$e=Object.getOwnPropertySymbols,d$6=Object.prototype.hasOwnProperty,l$d=Object.prototype.propertyIsEnumerable,f$9=(Z,X,K)=>X in Z?c$c(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,s$h=(Z,X)=>{for(var K in X||(X={}))d$6.call(X,K)&&f$9(Z,K,X[K]);if(n$e)for(var K of n$e(X))l$d.call(X,K)&&f$9(Z,K,X[K]);return Z};const m$c=new GlProgram({vertex:`
        out vec2 vUv;

        void main() {
            vUv = vec2((gl_VertexID << 1) & 2, (gl_VertexID & 2));

            gl_Position = vec4(vUv * 2.0f + -1.0f, 0.0f, 1.0f);

            // flip dem UVs
            vUv.y = 1.0f - vUv.y;
        }`,fragment:`
        in vec2 vUv;
        out vec4 fragColor;

        uniform sampler2D uTexture;

        void main() {
            fragColor = texture(uTexture, vUv);
        }`,name:"big-triangle"}),o$9=new Shader({glProgram:m$c,resources:{uTexture:Texture.WHITE.source}}),a$g=class{constructor(Z){this.useBackBuffer=!1,this._useBackBufferThisRender=!1,this._renderer=Z}init(Z={}){const{useBackBuffer:X,antialias:K}=s$h(s$h({},a$g.defaultOptions),Z);this.useBackBuffer=X,this._antialias=K}renderStart(Z){const X=this._renderer.renderTarget.getRenderTarget(Z.target);if(this._useBackBufferThisRender=this.useBackBuffer&&!!X.isRoot,this._useBackBufferThisRender){const K=this._renderer.renderTarget.getRenderTarget(Z.target);this._targetTexture=K.colorTexture,Z.target=this._getBackBufferTexture(K.colorTexture)}}renderEnd(){this._presentBackBuffer()}_presentBackBuffer(){const Z=this._renderer;if(Z.renderTarget.finishRenderPass(),!this._useBackBufferThisRender)return;const X=Z.gl;Z.renderTarget.bind(this._targetTexture,!1),o$9.resources.uTexture=this._backBufferTexture.source,Z.shader.bind(o$9,!1),Z.state.set(State.for2d()),X.drawArrays(X.TRIANGLES,0,3)}_getBackBufferTexture(Z){return this._backBufferTexture=this._backBufferTexture||new Texture({source:new TextureSource({width:Z.width,height:Z.height,resolution:Z._resolution,antialias:this._antialias})}),this._backBufferTexture.source.resize(Z.width,Z.height,Z._resolution),this._backBufferTexture}destroy(){this._backBufferTexture&&(this._backBufferTexture.destroy(),this._backBufferTexture=null)}};let GlBackBufferSystem=a$g;GlBackBufferSystem.extension={type:[u$v.WebGLSystem],name:"backBuffer",priority:1},GlBackBufferSystem.defaultOptions={useBackBuffer:!1};class GlColorMaskSystem{constructor(X){this._colorMaskCache=15,this._renderer=X}setMask(X){this._colorMaskCache!==X&&(this._colorMaskCache=X,this._renderer.gl.colorMask(!!(X&8),!!(X&4),!!(X&2),!!(X&1)))}}GlColorMaskSystem.extension={type:[u$v.WebGLSystem],name:"colorMask"};class GlEncoderSystem{constructor(X){this.commandFinished=Promise.resolve(),this._renderer=X}setGeometry(X,K){this._renderer.geometry.bind(X,K.glProgram)}finishRenderPass(){}draw(X){const K=this._renderer,{geometry:J,shader:Q,state:ee,skipSync:te,topology:re,size:ie,start:ne,instanceCount:se}=X;K.shader.bind(Q,te),K.geometry.bind(J,K.shader._activeProgram),ee&&K.state.set(ee),K.geometry.draw(re,ie,ne,se)}destroy(){this._renderer=null}}GlEncoderSystem.extension={type:[u$v.WebGLSystem],name:"encoder"};class GlRenderTarget{constructor(){this.width=-1,this.height=-1,this.msaa=!1,this.msaaRenderBuffer=[]}}class GlRenderTargetAdaptor{constructor(){this._clearColorCache=[0,0,0,0],this._viewPortCache=new Rectangle}init(X,K){this._renderer=X,this._renderTargetSystem=K}copyToTexture(X,K,J,Q){const ee=this._renderTargetSystem,te=this._renderer,re=ee.getGpuRenderTarget(X),ie=te.gl;return this.finishRenderPass(X),ie.bindFramebuffer(ie.FRAMEBUFFER,re.resolveTargetFramebuffer),te.texture.bind(K,0),ie.copyTexSubImage2D(ie.TEXTURE_2D,0,0,0,J.x,J.y,Q.width,Q.height),K}startRenderPass(X,K=!0,J,Q){const ee=this._renderTargetSystem,te=X.colorTexture,re=ee.getGpuRenderTarget(X);let ie=Q.y;X.isRoot&&(ie=te.pixelHeight-Q.height),X.colorTextures.forEach(oe=>{this._renderer.texture.unbind(oe)});const ne=this._renderer.gl;ne.bindFramebuffer(ne.FRAMEBUFFER,re.framebuffer);const se=this._viewPortCache;(se.x!==Q.x||se.y!==ie||se.width!==Q.width||se.height!==Q.height)&&(se.x=Q.x,se.y=ie,se.width=Q.width,se.height=Q.height,ne.viewport(Q.x,ie,Q.width,Q.height)),this.clear(X,K,J)}finishRenderPass(X){const K=this._renderTargetSystem.getGpuRenderTarget(X);if(!K.msaa)return;const J=this._renderer.gl;J.bindFramebuffer(J.FRAMEBUFFER,K.resolveTargetFramebuffer),J.bindFramebuffer(J.READ_FRAMEBUFFER,K.framebuffer),J.blitFramebuffer(0,0,K.width,K.height,0,0,K.width,K.height,J.COLOR_BUFFER_BIT,J.NEAREST),J.bindFramebuffer(J.FRAMEBUFFER,K.framebuffer)}initGpuRenderTarget(X){const K=this._renderer.gl,J=new GlRenderTarget;return CanvasSource.test(X.colorTexture.resource)?(J.framebuffer=null,J):(this._initColor(X,J),X.stencil&&this._initStencil(J),K.bindFramebuffer(K.FRAMEBUFFER,null),J)}clear(X,K,J){if(!K)return;const Q=this._renderTargetSystem;typeof K=="boolean"&&(K=K?CLEAR.ALL:CLEAR.NONE);const ee=this._renderer.gl;if(K&CLEAR.COLOR){J!=null||(J=Q.defaultClearColor);const te=this._clearColorCache,re=J;(te[0]!==re[0]||te[1]!==re[1]||te[2]!==re[2]||te[3]!==re[3])&&(te[0]=re[0],te[1]=re[1],te[2]=re[2],te[3]=re[3],ee.clearColor(re[0],re[1],re[2],re[3]))}ee.clear(K)}resizeGpuRenderTarget(X){if(X.isRoot)return;const K=this._renderTargetSystem.getGpuRenderTarget(X);this._resizeColor(X,K),X.stencil&&this._resizeStencil(K)}_initColor(X,K){const J=this._renderer,Q=J.gl,ee=Q.createFramebuffer();if(K.resolveTargetFramebuffer=ee,Q.bindFramebuffer(Q.FRAMEBUFFER,ee),K.width=X.colorTexture.source.pixelWidth,K.height=X.colorTexture.source.pixelHeight,X.colorTextures.forEach((te,re)=>{const ie=te.source;ie.antialias&&(K.msaa=!0),J.texture.bindSource(ie,0);const ne=J.texture.getGlSource(ie).texture;Q.framebufferTexture2D(Q.FRAMEBUFFER,Q.COLOR_ATTACHMENT0+re,3553,ne,0)}),K.msaa){const te=Q.createFramebuffer();K.framebuffer=te,Q.bindFramebuffer(Q.FRAMEBUFFER,te),X.colorTextures.forEach((re,ie)=>{const ne=Q.createRenderbuffer();K.msaaRenderBuffer[ie]=ne})}else K.framebuffer=ee;this._resizeColor(X,K)}_resizeColor(X,K){const J=X.colorTexture.source;if(K.width=J.pixelWidth,K.height=J.pixelHeight,X.colorTextures.forEach((Q,ee)=>{ee!==0&&Q.source.resize(J.width,J.height,J._resolution)}),K.msaa){const Q=this._renderer,ee=Q.gl,te=K.framebuffer;ee.bindFramebuffer(ee.FRAMEBUFFER,te),X.colorTextures.forEach((re,ie)=>{const ne=re.source;Q.texture.bindSource(ne,0);const se=Q.texture.getGlSource(ne).internalFormat,oe=K.msaaRenderBuffer[ie];ee.bindRenderbuffer(ee.RENDERBUFFER,oe),ee.renderbufferStorageMultisample(ee.RENDERBUFFER,4,se,ne.pixelWidth,ne.pixelHeight),ee.framebufferRenderbuffer(ee.FRAMEBUFFER,ee.COLOR_ATTACHMENT0+ie,ee.RENDERBUFFER,oe)})}}_initStencil(X){const K=this._renderer.gl,J=K.createRenderbuffer();X.depthStencilRenderBuffer=J,K.bindRenderbuffer(K.RENDERBUFFER,J),K.framebufferRenderbuffer(K.FRAMEBUFFER,K.DEPTH_STENCIL_ATTACHMENT,K.RENDERBUFFER,J),this._resizeStencil(X)}_resizeStencil(X){const K=this._renderer.gl;K.bindRenderbuffer(K.RENDERBUFFER,X.depthStencilRenderBuffer),X.msaa?K.renderbufferStorageMultisample(K.RENDERBUFFER,4,K.DEPTH24_STENCIL8,X.width,X.height):K.renderbufferStorage(K.RENDERBUFFER,K.DEPTH24_STENCIL8,X.width,X.height)}}function calculateProjection(Z,X,K,J,Q,ee){const te=ee?1:-1;return Z.identity(),Z.a=1/J*2,Z.d=te*(1/Q*2),Z.tx=-1-X*Z.a,Z.ty=-te-K*Z.d,Z}var u$c=Object.defineProperty,n$d=Object.getOwnPropertySymbols,p$f=Object.prototype.hasOwnProperty,c$b=Object.prototype.propertyIsEnumerable,a$f=(Z,X,K)=>X in Z?u$c(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,s$g=(Z,X)=>{for(var K in X||(X={}))p$f.call(X,K)&&a$f(Z,K,X[K]);if(n$d)for(var K of n$d(X))c$b.call(X,K)&&a$f(Z,K,X[K]);return Z};const o$8=new Map;function getCanvasTexture(Z,X){if(!o$8.has(Z)){const K=new Texture({source:new CanvasSource(s$g({resource:Z},X))});o$8.set(Z,K)}return o$8.get(Z)}function isRenderingToScreen(Z){const X=Z.colorTexture.source.resource;return X instanceof HTMLCanvasElement&&document.body.contains(X)}var a$e=Object.defineProperty,h$f=Object.getOwnPropertySymbols,T$5=Object.prototype.hasOwnProperty,b$9=Object.prototype.propertyIsEnumerable,l$c=(Z,X,K)=>X in Z?a$e(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$7=(Z,X)=>{for(var K in X||(X={}))T$5.call(X,K)&&l$c(Z,K,X[K]);if(h$f)for(var K of h$f(X))b$9.call(X,K)&&l$c(Z,K,X[K]);return Z};const s$f=class{constructor(Z={}){if(this.uid=uid("renderTarget"),this.colorTextures=[],this.dirtyId=0,this.isRoot=!1,this._size=new Float32Array(2),Z=o$7(o$7({},s$f.defaultDescriptor),Z),this.stencil=Z.stencil,typeof Z.colorTextures=="number")for(let X=0;X<Z.colorTextures;X++)this.colorTextures.push(new TextureSource({width:Z.width,height:Z.height,resolution:Z.resolution,antialias:Z.antialias}));else{this.colorTextures=[...Z.colorTextures.map(K=>K.source)];const X=this.colorTexture.source;this._resize(X.width,X.height,X._resolution)}this.colorTexture.source.on("resize",this.onSourceResize,this),Z.depthTexture&&(Z.depthTexture instanceof Texture||Z.depthTexture instanceof TextureSource?this.depthTexture=Z.depthTexture.source:this.depthTexture=new TextureSource({width:this.width,height:this.height,resolution:this.resolution,format:"stencil8"}))}get size(){const Z=this._size;return Z[0]=this.pixelWidth,Z[1]=this.pixelHeight,Z}get width(){return this.colorTexture.source.width}get height(){return this.colorTexture.source.height}get pixelWidth(){return this.colorTexture.source.pixelWidth}get pixelHeight(){return this.colorTexture.source.pixelHeight}get resolution(){return this.colorTexture.source._resolution}get colorTexture(){return this.colorTextures[0]}onSourceResize(Z){this._resize(Z.width,Z.height,Z._resolution,!0)}_resize(Z,X,K=this.resolution,J=!1){this.dirtyId++,this.colorTextures.forEach((Q,ee)=>{J&&ee===0||Q.source.resize(Z,X,K)}),this.depthTexture&&this.depthTexture.source.resize(Z,X,K)}destroy(){this.colorTexture.source.off("resize",this.onSourceResize,this)}};let RenderTarget=s$f;RenderTarget.defaultDescriptor={width:0,height:0,resolution:1,colorTextures:1,stencil:!0,antialias:!1};const f$8=new Rectangle(0,0,1,1);class RenderTargetSystem{constructor(X){this.rootViewPort=new Rectangle,this.viewport=new Rectangle,this.onRenderTargetChange=new SystemRunner("onRenderTargetChange"),this.projectionMatrix=new Matrix,this.defaultClearColor=[0,0,0,0],this._renderSurfaceToRenderTargetHash=new Map,this._gpuRenderTargetHash=Object.create(null),this._renderTargetStack=[],this._renderer=X}finishRenderPass(){this.adaptor.finishRenderPass(this.renderTarget)}renderStart({target:X,clear:K,clearColor:J,frame:Q}){this._renderTargetStack.length=0,this.push(X,K,J!=null?J:this._renderer.background.colorRgba,Q),this.rootViewPort.copyFrom(this.viewport),this.rootRenderTarget=this.renderTarget,this.renderingToScreen=isRenderingToScreen(this.rootRenderTarget)}bind(X,K=!0,J,Q){const ee=this.getRenderTarget(X),te=this.renderTarget!==ee;this.renderTarget=ee,Q||(Q=X instanceof Texture?X.layout.frame:f$8);const re=this.getGpuRenderTarget(ee);(ee.pixelWidth!==re.width||ee.pixelHeight!==re.height)&&(this.adaptor.resizeGpuRenderTarget(ee),re.width=ee.pixelWidth,re.height=ee.pixelHeight);const ie=ee.colorTexture,ne=this.viewport,se=ie.pixelWidth,oe=ie.pixelHeight;return ne.x=Q.x*se+.5|0,ne.y=Q.y*oe+.5|0,ne.width=Q.width*se+.5|0,ne.height=Q.height*oe+.5|0,calculateProjection(this.projectionMatrix,0,0,ne.width/ie.resolution,ne.height/ie.resolution,!ee.isRoot),this.adaptor.startRenderPass(ee,K,J,ne),te&&this.onRenderTargetChange.emit(ee),ee}clear(X=CLEAR.ALL,K){X&&this.adaptor.clear(this.renderTarget,X,K,this.viewport)}push(X,K=CLEAR.ALL,J,Q){const ee=this.bind(X,K,J,Q);return this._renderTargetStack.push({renderTarget:ee,frame:Q}),ee}pop(){this._renderTargetStack.pop();const X=this._renderTargetStack[this._renderTargetStack.length-1];this.bind(X.renderTarget,!1,null,X.frame)}getRenderTarget(X){var K;return X instanceof Texture&&(X=X.source),(K=this._renderSurfaceToRenderTargetHash.get(X))!=null?K:this._initRenderTarget(X)}copyToTexture(X,K,J,Q){return this.adaptor.copyToTexture(X,K,J,Q)}destroy(){this._renderer=null,this._renderSurfaceToRenderTargetHash.forEach((X,K)=>{X!==K&&X.destroy()}),this._renderSurfaceToRenderTargetHash.clear(),this._gpuRenderTargetHash=Object.create(null)}_initRenderTarget(X){let K=null;return CanvasSource.test(X)&&(X=getCanvasTexture(X)),X instanceof RenderTarget?K=X:X instanceof TextureSource&&(K=new RenderTarget({colorTextures:[X],depthTexture:X.source.depthStencil}),CanvasSource.test(X.source.resource)&&(K.isRoot=!0),X.on("destroy",()=>{K.destroy()})),this._renderSurfaceToRenderTargetHash.set(X,K),K}getGpuRenderTarget(X){return this._gpuRenderTargetHash[X.uid]||(this._gpuRenderTargetHash[X.uid]=this.adaptor.initGpuRenderTarget(X))}}class GlRenderTargetSystem extends RenderTargetSystem{constructor(X){super(X),this.adaptor=new GlRenderTargetAdaptor,this.adaptor.init(X,this)}}GlRenderTargetSystem.extension={type:[u$v.WebGLSystem],name:"renderTarget"};const GpuStencilModesToPixi=[];GpuStencilModesToPixi[STENCIL_MODES.NONE]=void 0,GpuStencilModesToPixi[STENCIL_MODES.DISABLED]={format:"stencil8",depthCompare:"always",depthWriteEnabled:!1,stencilWriteMask:0,stencilReadMask:0,stencilBack:{compare:"always",passOp:"keep"}},GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD]={format:"stencil8",depthCompare:"always",depthWriteEnabled:!1,stencilBack:{compare:"always",passOp:"increment-clamp"}},GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD]={format:"stencil8",depthCompare:"always",depthWriteEnabled:!1,stencilBack:{compare:"always",passOp:"increment-clamp"}},GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE]={format:"stencil8",depthCompare:"always",depthWriteEnabled:!1,stencilBack:{compare:"always",passOp:"decrement-clamp"}},GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE]={format:"stencil8",depthCompare:"always",depthWriteEnabled:!1,stencilWriteMask:0,stencilBack:{compare:"equal",passOp:"keep"}};class GlStencilSystem{constructor(X){this._stencilCache={enabled:!1,stencilReference:0,stencilMode:STENCIL_MODES.NONE},this._renderTargetStencilState=Object.create(null),X.renderTarget.onRenderTargetChange.add(this)}contextChange(X){this._gl=X,this._comparisonFuncMapping={always:X.ALWAYS,never:X.NEVER,equal:X.EQUAL,"not-equal":X.NOTEQUAL,less:X.LESS,"less-equal":X.LEQUAL,greater:X.GREATER,"greater-equal":X.GEQUAL},this._stencilOpsMapping={keep:X.KEEP,zero:X.ZERO,replace:X.REPLACE,invert:X.INVERT,"increment-clamp":X.INCR,"decrement-clamp":X.DECR,"increment-wrap":X.INCR_WRAP,"decrement-wrap":X.DECR_WRAP}}onRenderTargetChange(X){if(this._activeRenderTarget===X)return;this._activeRenderTarget=X;let K=this._renderTargetStencilState[X.uid];K||(K=this._renderTargetStencilState[X.uid]={stencilMode:STENCIL_MODES.DISABLED,stencilReference:0}),this.setStencilMode(K.stencilMode,K.stencilReference)}setStencilMode(X,K){const J=this._renderTargetStencilState[this._activeRenderTarget.uid],Q=this._gl,ee=GpuStencilModesToPixi[X],te=this._stencilCache;if(J.stencilMode=X,J.stencilReference=K,X===STENCIL_MODES.DISABLED){this._stencilCache.enabled&&(this._stencilCache.enabled=!1,Q.disable(Q.STENCIL_TEST));return}this._stencilCache.enabled||(this._stencilCache.enabled=!0,Q.enable(Q.STENCIL_TEST)),(X!==te.stencilMode||te.stencilReference!==K)&&(te.stencilMode=X,te.stencilReference=K,Q.stencilFunc(this._comparisonFuncMapping[ee.stencilBack.compare],K,255),Q.stencilOp(Q.KEEP,Q.KEEP,this._stencilOpsMapping[ee.stencilBack.passOp]))}}GlStencilSystem.extension={type:[u$v.WebGLSystem],name:"stencil"};class IGLUniformData{}class GlProgramData{constructor(X,K){this.program=X,this.uniformData=K,this.uniformGroups={},this.uniformDirtyGroups={},this.uniformBlockBindings={}}destroy(){this.uniformData=null,this.uniformGroups=null,this.uniformDirtyGroups=null,this.uniformBlockBindings=null,this.program=null}}class BufferResource extends eventemitter3{constructor({buffer:X,offset:K,size:J}){super(),this.uid=uid("buffer"),this._resourceType="bufferResource",this._touched=0,this._resourceId=uid("buffer"),this._bufferResource=!0,this.buffer=X,this.offset=K|0,this.size=J,this.buffer.on("change",this.onBufferChange,this)}onBufferChange(){this._resourceId=uid("buffer"),this.emit("change",this)}destroy(X=!1){X&&this.buffer.destroy(),this.buffer=null}}function compileShader(Z,X,K){const J=Z.createShader(X);return Z.shaderSource(J,K),Z.compileShader(J),J}function n$c(Z){const X=new Array(Z);for(let K=0;K<X.length;K++)X[K]=!1;return X}function defaultValue(Z,X){switch(Z){case"float":return 0;case"vec2":return new Float32Array(2*X);case"vec3":return new Float32Array(3*X);case"vec4":return new Float32Array(4*X);case"int":case"uint":case"sampler2D":case"sampler2DArray":return 0;case"ivec2":return new Int32Array(2*X);case"ivec3":return new Int32Array(3*X);case"ivec4":return new Int32Array(4*X);case"uvec2":return new Uint32Array(2*X);case"uvec3":return new Uint32Array(3*X);case"uvec4":return new Uint32Array(4*X);case"bool":return!1;case"bvec2":return n$c(2*X);case"bvec3":return n$c(3*X);case"bvec4":return n$c(4*X);case"mat2":return new Float32Array([1,0,0,1]);case"mat3":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const t$1={float:1,vec2:2,vec3:3,vec4:4,int:1,ivec2:2,ivec3:3,ivec4:4,uint:1,uvec2:2,uvec3:3,uvec4:4,bool:1,bvec2:2,bvec3:3,bvec4:4,mat2:4,mat3:9,mat4:16,sampler2D:1};function mapSize(Z){return t$1[Z]}let _$2=null;const N={FLOAT:"float",FLOAT_VEC2:"vec2",FLOAT_VEC3:"vec3",FLOAT_VEC4:"vec4",INT:"int",INT_VEC2:"ivec2",INT_VEC3:"ivec3",INT_VEC4:"ivec4",UNSIGNED_INT:"uint",UNSIGNED_INT_VEC2:"uvec2",UNSIGNED_INT_VEC3:"uvec3",UNSIGNED_INT_VEC4:"uvec4",BOOL:"bool",BOOL_VEC2:"bvec2",BOOL_VEC3:"bvec3",BOOL_VEC4:"bvec4",FLOAT_MAT2:"mat2",FLOAT_MAT3:"mat3",FLOAT_MAT4:"mat4",SAMPLER_2D:"sampler2D",INT_SAMPLER_2D:"sampler2D",UNSIGNED_INT_SAMPLER_2D:"sampler2D",SAMPLER_CUBE:"samplerCube",INT_SAMPLER_CUBE:"samplerCube",UNSIGNED_INT_SAMPLER_CUBE:"samplerCube",SAMPLER_2D_ARRAY:"sampler2DArray",INT_SAMPLER_2D_ARRAY:"sampler2DArray",UNSIGNED_INT_SAMPLER_2D_ARRAY:"sampler2DArray"};function mapType(Z,X){if(!_$2){const K=Object.keys(N);_$2={};for(let J=0;J<K.length;++J){const Q=K[J];_$2[Z[Q]]=N[Q]}}return _$2[X]}function getAttributeData(Z,X){const K={},J=X.getProgramParameter(Z,X.ACTIVE_ATTRIBUTES);for(let Q=0;Q<J;Q++){const ee=X.getActiveAttrib(Z,Q);if(ee.name.startsWith("gl_"))continue;const te=mapType(X,ee.type),re={type:te,name:ee.name,size:mapSize(te),location:X.getAttribLocation(Z,ee.name)};K[ee.name]=re}return K}function getUniformBufferData(Z,X){const K={},J=X.getProgramParameter(Z,X.ACTIVE_UNIFORM_BLOCKS);for(let Q=0;Q<J;Q++){const ee=X.getActiveUniformBlockName(Z,Q),te=X.getUniformBlockIndex(Z,ee),re=X.getActiveUniformBlockParameter(Z,Q,X.UNIFORM_BLOCK_DATA_SIZE);K[ee]={name:ee,index:te,size:re}}return K}function getUniformData(Z,X){const K={},J=X.getProgramParameter(Z,X.ACTIVE_UNIFORMS);for(let Q=0;Q<J;Q++){const ee=X.getActiveUniform(Z,Q),te=ee.name.replace(/\[.*?\]$/,""),re=!!ee.name.match(/\[.*?\]$/),ie=mapType(X,ee.type);K[te]={name:te,index:Q,type:ie,size:ee.size,isArray:re,value:defaultValue(ie,ee.size)}}return K}function c$a(Z,X){const K=Z.getShaderSource(X).split(`
`).map((ne,se)=>`${se}: ${ne}`),J=Z.getShaderInfoLog(X),Q=J.split(`
`),ee={},te=Q.map(ne=>parseFloat(ne.replace(/^ERROR\: 0\:([\d]+)\:.*$/,"$1"))).filter(ne=>ne&&!ee[ne]?(ee[ne]=!0,!0):!1),re=[""];te.forEach(ne=>{K[ne-1]=`%c${K[ne-1]}%c`,re.push("background: #FF0000; color:#FFFFFF; font-size: 10px","font-size: 10px")});const ie=K.join(`
`);re[0]=ie,console.error(J),console.groupCollapsed("click to view full shader code"),console.warn(...re),console.groupEnd()}function logProgramError(Z,X,K,J){Z.getProgramParameter(X,Z.LINK_STATUS)||(Z.getShaderParameter(K,Z.COMPILE_STATUS)||c$a(Z,K),Z.getShaderParameter(J,Z.COMPILE_STATUS)||c$a(Z,J),console.error("PixiJS Error: Could not initialize shader."),Z.getProgramInfoLog(X)!==""&&console.warn("PixiJS Warning: gl.getProgramInfoLog()",Z.getProgramInfoLog(X)))}function generateProgram(Z,X){const K=compileShader(Z,Z.VERTEX_SHADER,X.vertex),J=compileShader(Z,Z.FRAGMENT_SHADER,X.fragment),Q=Z.createProgram();Z.attachShader(Q,K),Z.attachShader(Q,J);const ee=X.transformFeedbackVaryings;ee&&(typeof Z.transformFeedbackVaryings!="function"||Z.transformFeedbackVaryings(Q,ee.names,ee.bufferMode==="separate"?Z.SEPARATE_ATTRIBS:Z.INTERLEAVED_ATTRIBS)),Z.linkProgram(Q),Z.getProgramParameter(Q,Z.LINK_STATUS)||logProgramError(Z,Q,K,J),X._attributeData=getAttributeData(Q,Z),X._uniformData=getUniformData(Q,Z),X._uniformBlockData=getUniformBufferData(Q,Z),Z.deleteShader(K),Z.deleteShader(J);const te={};for(const re in X._uniformData){const ie=X._uniformData[re];te[re]={location:Z.getUniformLocation(Q,re),value:defaultValue(ie.type,ie.size)}}return new GlProgramData(Q,te)}const a$d={textureCount:0,blockIndex:0};class GlShaderSystem{constructor(X){this._activeProgram=null,this._programDataHash=Object.create(null),this._nextIndex=0,this._boundUniformsIdsToIndexHash=Object.create(null),this._boundIndexToUniformsHash=Object.create(null),this._renderer=X}contextChange(X){this._gl=X,this._maxBindings=X.getParameter(X.MAX_UNIFORM_BUFFER_BINDINGS)}bind(X,K){if(this._setProgram(X.glProgram),K)return;a$d.textureCount=0,a$d.blockIndex=0;const J=this._gl,Q=this._getProgramData(X.glProgram);for(const ee in X.groups){const te=X.groups[ee];for(const re in te.resources){const ie=te.resources[re];if(ie instanceof UniformGroup)ie.ubo?this.bindUniformBlock(ie,X._uniformBindMap[ee][re],a$d.blockIndex++):this._updateUniformGroup(ie);else if(ie instanceof BufferResource)this.bindUniformBlock(ie,X._uniformBindMap[ee][re],a$d.blockIndex++);else if(ie instanceof TextureSource){this._renderer.texture.bind(ie,a$d.textureCount);const ne=X._uniformBindMap[ee][re],se=Q.uniformData[ne];se&&(se.value!==a$d.textureCount&&J.uniform1i(se.location,a$d.textureCount),a$d.textureCount++)}else ie instanceof TextureStyle}}}_updateUniformGroup(X){this._renderer.uniformGroup.updateUniformGroup(X,this._activeProgram,a$d)}bindUniformBlock(X,K,J=0){const Q=this._renderer.buffer,ee=this._getProgramData(this._activeProgram),te=X._bufferResource;te&&this._renderer.uniformBuffer.updateUniformGroup(X),Q.updateBuffer(X.buffer);let re=this._boundUniformsIdsToIndexHash[X.uid];if(re===void 0){const se=this._nextIndex++%this._maxBindings,oe=this._boundIndexToUniformsHash[se];oe&&(this._boundUniformsIdsToIndexHash[oe.uid]=void 0),re=this._boundUniformsIdsToIndexHash[X.uid]=se,this._boundIndexToUniformsHash[se]=X,te?Q.bindBufferRange(X.buffer,se,X.offset):Q.bindBufferBase(X.buffer,se)}const ie=this._gl,ne=this._activeProgram._uniformBlockData[K].index;ee.uniformBlockBindings[J]!==re&&(ee.uniformBlockBindings[J]=re,ie.uniformBlockBinding(ee.program,ne,re))}_setProgram(X){if(this._activeProgram===X)return;this._activeProgram=X;const K=this._getProgramData(X);this._gl.useProgram(K.program)}_getProgramData(X){return this._programDataHash[X._key]||this._createProgramData(X)}_createProgramData(X){const K=X._key;return this._programDataHash[K]=generateProgram(this._gl,X),this._programDataHash[K]}destroy(){for(const X of Object.keys(this._programDataHash))this._programDataHash[X].destroy(),this._programDataHash[X]=null;this._programDataHash=null,this._boundUniformsIdsToIndexHash=null}}GlShaderSystem.extension={type:[u$v.WebGLSystem],name:"shader"};let a$c;function unsafeEvalSupported(){if(typeof a$c=="boolean")return a$c;try{a$c=new Function("param1","param2","param3","return param1[param2] === param3;")({a:"b"},"a","b")===!0}catch(Z){a$c=!1}return a$c}const uniformParsers=[{test:Z=>Z.type==="float"&&Z.size===1&&!Z.isArray,code:Z=>`
            if(uv["${Z}"] !== ud["${Z}"].value)
            {
                ud["${Z}"].value = uv["${Z}"]
                gl.uniform1f(ud["${Z}"].location, uv["${Z}"])
            }
            `},{test:(Z,X)=>(Z.type==="sampler2D"||Z.type==="samplerCube"||Z.type==="sampler2DArray")&&Z.size===1&&!Z.isArray&&(X==null||X instanceof Texture),code:Z=>`t = syncData.textureCount++;

            renderer.texture.bind(uv["${Z}"], t);

            if(ud["${Z}"].value !== t)
            {
                ud["${Z}"].value = t;
                gl.uniform1i(ud["${Z}"].location, t);
; // eslint-disable-line max-len
            }`},{test:(Z,X)=>Z.type==="mat3"&&Z.size===1&&!Z.isArray&&X.a!==void 0,code:Z=>`
            gl.uniformMatrix3fv(ud["${Z}"].location, false, uv["${Z}"].toArray(true));
            `},{test:(Z,X)=>Z.type==="vec2"&&Z.size===1&&!Z.isArray&&X.x!==void 0,code:Z=>`
                cv = ud["${Z}"].value;
                v = uv["${Z}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${Z}"].location, v.x, v.y);
                }`},{test:Z=>Z.type==="vec2"&&Z.size===1&&!Z.isArray,code:Z=>`
                cv = ud["${Z}"].value;
                v = uv["${Z}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${Z}"].location, v[0], v[1]);
                }
            `},{test:(Z,X)=>Z.type==="vec4"&&Z.size===1&&!Z.isArray&&X.width!==void 0,code:Z=>`
                cv = ud["${Z}"].value;
                v = uv["${Z}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${Z}"].location, v.x, v.y, v.width, v.height)
                }`},{test:(Z,X)=>Z.type==="vec4"&&Z.size===1&&!Z.isArray&&X.red!==void 0,code:Z=>`
                cv = ud["${Z}"].value;
                v = uv["${Z}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${Z}"].location, v.red, v.green, v.blue, v.alpha)
                }`},{test:(Z,X)=>Z.type==="vec3"&&Z.size===1&&!Z.isArray&&X.red!==void 0,code:Z=>`
                cv = ud["${Z}"].value;
                v = uv["${Z}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;

                    gl.uniform3f(ud["${Z}"].location, v.red, v.green, v.blue)
                }`},{test:Z=>Z.type==="vec4"&&Z.size===1&&!Z.isArray,code:Z=>`
                cv = ud["${Z}"].value;
                v = uv["${Z}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${Z}"].location, v[0], v[1], v[2], v[3])
                }`}],m$b={float:`
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,vec2:`
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,vec3:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,vec4:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,int:`
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,ivec2:`
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,ivec3:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,ivec4:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,uint:`
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,uvec2:`
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,uvec3:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,uvec4:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,bool:`
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,bvec2:`
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,bvec3:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,bvec4:`
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,mat2:"gl.uniformMatrix2fv(location, false, v)",mat3:"gl.uniformMatrix3fv(location, false, v)",mat4:"gl.uniformMatrix4fv(location, false, v)",sampler2D:`
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,samplerCube:`
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,sampler2DArray:`
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`},s$e={float:"gl.uniform1fv(location, v)",vec2:"gl.uniform2fv(location, v)",vec3:"gl.uniform3fv(location, v)",vec4:"gl.uniform4fv(location, v)",mat4:"gl.uniformMatrix4fv(location, false, v)",mat3:"gl.uniformMatrix3fv(location, false, v)",mat2:"gl.uniformMatrix2fv(location, false, v)",int:"gl.uniform1iv(location, v)",ivec2:"gl.uniform2iv(location, v)",ivec3:"gl.uniform3iv(location, v)",ivec4:"gl.uniform4iv(location, v)",uint:"gl.uniform1uiv(location, v)",uvec2:"gl.uniform2uiv(location, v)",uvec3:"gl.uniform3uiv(location, v)",uvec4:"gl.uniform4uiv(location, v)",bool:"gl.uniform1iv(location, v)",bvec2:"gl.uniform2iv(location, v)",bvec3:"gl.uniform3iv(location, v)",bvec4:"gl.uniform4iv(location, v)",sampler2D:"gl.uniform1iv(location, v)",samplerCube:"gl.uniform1iv(location, v)",sampler2DArray:"gl.uniform1iv(location, v)"};function generateUniformsSync(Z,X){const K=[`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];for(const J in Z.uniforms){const Q=X[J];if(!Q){Z.uniforms[J]instanceof UniformGroup?Z.uniforms[J].ubo?K.push(`
                        renderer.shader.bindUniformBlock(uv.${J}, "${J}");
                    `):K.push(`
                        renderer.shader.updateUniformGroup(uv.${J});
                    `):Z.uniforms[J]instanceof BufferResource&&K.push(`
                        renderer.shader.bindBufferResource(uv.${J}, "${J}");
                    `);continue}const ee=Z.uniforms[J];let te=!1;for(let re=0;re<uniformParsers.length;re++)if(uniformParsers[re].test(Q,ee)){K.push(uniformParsers[re].code(J,ee)),te=!0;break}if(!te){const re=(Q.size===1&&!Q.isArray?m$b:s$e)[Q.type].replace("location",`ud["${J}"].location`);K.push(`
            cu = ud["${J}"];
            cv = cu.value;
            v = uv["${J}"];
            ${re};`)}}return new Function("ud","uv","renderer","syncData",K.join(`
`))}class GlUniformGroupSystem{constructor(X){this._cache={},this._uniformGroupSyncHash={},this._renderer=X,this._systemCheck(),this.gl=null,this._cache={}}_systemCheck(){if(!unsafeEvalSupported())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}contextChange(X){this.gl=X}updateUniformGroup(X,K,J){const Q=this._renderer.shader._getProgramData(K);(!X.isStatic||X._dirtyId!==Q.uniformDirtyGroups[X.uid])&&(Q.uniformDirtyGroups[X.uid]=X._dirtyId,this._getUniformSyncFunction(X,K)(Q.uniformData,X.uniforms,this._renderer,J))}_getUniformSyncFunction(X,K){var J;return((J=this._uniformGroupSyncHash[X._signature])==null?void 0:J[K._key])||this._createUniformSyncFunction(X,K)}_createUniformSyncFunction(X,K){const J=this._uniformGroupSyncHash[X._signature]||(this._uniformGroupSyncHash[X._signature]={}),Q=this._getSignature(X,K._uniformData,"u");return this._cache[Q]||(this._cache[Q]=generateUniformsSync(X,K._uniformData)),J[K._key]=this._cache[Q],J[K._key]}_getSignature(X,K,J){const Q=X.uniforms,ee=[`${J}-`];for(const te in Q)ee.push(te),K[te]&&ee.push(K[te].type);return ee.join("-")}destroy(){this._renderer=null,this._cache=null}}GlUniformGroupSystem.extension={type:[u$v.WebGLSystem],name:"uniformGroup"};function migrateFragmentFromV7toV8(Z){return Z=Z.replaceAll("texture2D","texture").replaceAll("gl_FragColor","fragColor").replaceAll("varying","in"),Z=`
        out vec4 fragColor;
    ${Z}
    `,Z}function mapWebGLBlendModesToPixi(Z){const X={};return X.normal=[Z.ONE,Z.ONE_MINUS_SRC_ALPHA],X.add=[Z.ONE,Z.ONE],X.multiply=[Z.DST_COLOR,Z.ONE_MINUS_SRC_ALPHA,Z.ONE,Z.ONE_MINUS_SRC_ALPHA],X.screen=[Z.ONE,Z.ONE_MINUS_SRC_COLOR,Z.ONE,Z.ONE_MINUS_SRC_ALPHA],X.none=[0,0],X["normal-npm"]=[Z.SRC_ALPHA,Z.ONE_MINUS_SRC_ALPHA,Z.ONE,Z.ONE_MINUS_SRC_ALPHA],X["add-npm"]=[Z.SRC_ALPHA,Z.ONE,Z.ONE,Z.ONE],X["screen-npm"]=[Z.SRC_ALPHA,Z.ONE_MINUS_SRC_COLOR,Z.ONE,Z.ONE_MINUS_SRC_ALPHA],X.erase=[Z.ZERO,Z.ONE_MINUS_SRC_ALPHA],X}const h$e=0,n$b=1,a$b=2,c$9=3,p$e=4,b$8=5,i$6=class{constructor(){this.gl=null,this.stateId=0,this.polygonOffset=0,this.blendMode="none",this._blendEq=!1,this.map=[],this.map[h$e]=this.setBlend,this.map[n$b]=this.setOffset,this.map[a$b]=this.setCullFace,this.map[c$9]=this.setDepthTest,this.map[p$e]=this.setFrontFace,this.map[b$8]=this.setDepthMask,this.checks=[],this.defaultState=new State,this.defaultState.blend=!0}contextChange(Z){this.gl=Z,this.blendModesMap=mapWebGLBlendModesToPixi(Z),this.set(this.defaultState),this.reset()}set(Z){if(Z=Z||this.defaultState,this.stateId!==Z.data){let X=this.stateId^Z.data,K=0;for(;X;)X&1&&this.map[K].call(this,!!(Z.data&1<<K)),X=X>>1,K++;this.stateId=Z.data}for(let X=0;X<this.checks.length;X++)this.checks[X](this,Z)}forceState(Z){Z=Z||this.defaultState;for(let X=0;X<this.map.length;X++)this.map[X].call(this,!!(Z.data&1<<X));for(let X=0;X<this.checks.length;X++)this.checks[X](this,Z);this.stateId=Z.data}setBlend(Z){this._updateCheck(i$6._checkBlendMode,Z),this.gl[Z?"enable":"disable"](this.gl.BLEND)}setOffset(Z){this._updateCheck(i$6._checkPolygonOffset,Z),this.gl[Z?"enable":"disable"](this.gl.POLYGON_OFFSET_FILL)}setDepthTest(Z){this.gl[Z?"enable":"disable"](this.gl.DEPTH_TEST)}setDepthMask(Z){this.gl.depthMask(Z)}setCullFace(Z){this.gl[Z?"enable":"disable"](this.gl.CULL_FACE)}setFrontFace(Z){this.gl.frontFace(this.gl[Z?"CW":"CCW"])}setBlendMode(Z){if(this.blendModesMap[Z]||(Z="normal"),Z===this.blendMode)return;this.blendMode=Z;const X=this.blendModesMap[Z],K=this.gl;X.length===2?K.blendFunc(X[0],X[1]):K.blendFuncSeparate(X[0],X[1],X[2],X[3]),X.length===6?(this._blendEq=!0,K.blendEquationSeparate(X[4],X[5])):this._blendEq&&(this._blendEq=!1,K.blendEquationSeparate(K.FUNC_ADD,K.FUNC_ADD))}setPolygonOffset(Z,X){this.gl.polygonOffset(Z,X)}reset(){this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!1),this.forceState(this.defaultState),this._blendEq=!0,this.blendMode="",this.setBlendMode("normal")}_updateCheck(Z,X){const K=this.checks.indexOf(Z);X&&K===-1?this.checks.push(Z):!X&&K!==-1&&this.checks.splice(K,1)}static _checkBlendMode(Z,X){Z.setBlendMode(X.blendMode)}static _checkPolygonOffset(Z,X){Z.setPolygonOffset(1,X.polygonOffset)}destroy(){this.gl=null,this.checks.length=0}};let GlStateSystem=i$6;GlStateSystem.extension={type:[u$v.WebGLSystem],name:"state"};class GlTexture{constructor(X){this.target=GL_TARGETS.TEXTURE_2D,this.texture=X,this.width=-1,this.height=-1,this.type=GL_TYPES.UNSIGNED_BYTE,this.internalFormat=GL_FORMATS.RGBA,this.format=GL_FORMATS.RGBA,this.samplerType=0}}const glUploadBufferImageResource={id:"image",upload(Z,X,K){X.width===Z.width||X.height===Z.height?K.texSubImage2D(K.TEXTURE_2D,0,0,0,X.format,X.type,Z.resource):K.texImage2D(X.target,0,X.internalFormat,Z.width,Z.height,0,X.format,X.type,Z.resource),X.width=Z.width,X.height=Z.height}},s$d={"bc2-rgba-unorm":!0,"bc3-rgba-unorm":!0,"bc7-rgba-unorm":!0,"etc2-rgba8unorm":!0,"astc-4x4-unorm":!0},glUploadCompressedTextureResource={id:"compressed",upload(Z,X,K){K.pixelStorei(K.UNPACK_ALIGNMENT,4);let J=Z.pixelWidth,Q=Z.pixelHeight;const ee=!!s$d[Z.format];for(let te=0;te<Z.resource.length;te++){const re=Z.resource[te];ee?K.compressedTexImage2D(K.TEXTURE_2D,te,X.internalFormat,J,Q,0,re):K.texImage2D(K.TEXTURE_2D,te,X.internalFormat,J,Q,0,X.format,X.type,re),J=Math.max(J>>1,1),Q=Math.max(Q>>1,1)}}},glUploadImageResource={id:"image",upload(Z,X,K){const J=Z.alphaMode==="premultiply-alpha-on-upload";K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL,J);const Q=X.width,ee=X.height,te=Z.pixelWidth,re=Z.pixelHeight,ie=Z.resourceWidth,ne=Z.resourceHeight;ie<te||ne<re?((Q!==te||ee!==re)&&K.texImage2D(X.target,0,X.internalFormat,te,re,0,X.format,X.type,null),K.texSubImage2D(K.TEXTURE_2D,0,0,0,ie,ne,X.format,X.type,Z.resource)):Q===te||ee===re?K.texSubImage2D(K.TEXTURE_2D,0,0,0,X.format,X.type,Z.resource):K.texImage2D(X.target,0,X.internalFormat,te,re,0,X.format,X.type,Z.resource),X.width=te,X.height=re}},glUploadVideoResource={id:"video",upload(Z,X,K){if(!Z.isValid){K.texImage2D(X.target,0,X.internalFormat,1,1,0,X.format,X.type,null);return}glUploadImageResource.upload(Z,X,K)}},scaleModeToGlFilter={linear:9729,nearest:9728},mipmapScaleModeToGlFilter={linear:{linear:9987,nearest:9985},nearest:{linear:9986,nearest:9984}},wrapModeToGlAddress={"clamp-to-edge":33071,repeat:10497,"mirror-repeat":33648},compareModeToGlCompare={never:512,less:513,equal:514,"less-equal":515,greater:516,"not-equal":517,"greater-equal":518,always:519};function applyStyleParams(Z,X,K,J,Q,ee){const te=ee;if(X[Q](te,X.TEXTURE_WRAP_S,wrapModeToGlAddress[Z.addressModeU]),X[Q](te,X.TEXTURE_WRAP_T,wrapModeToGlAddress[Z.addressModeV]),X[Q](te,X.TEXTURE_WRAP_R,wrapModeToGlAddress[Z.addressModeW]),X[Q](te,X.TEXTURE_MAG_FILTER,scaleModeToGlFilter[Z.magFilter]),K){const re=mipmapScaleModeToGlFilter[Z.minFilter][Z.mipmapFilter];X[Q](te,X.TEXTURE_MIN_FILTER,re)}else X[Q](te,X.TEXTURE_MIN_FILTER,scaleModeToGlFilter[Z.minFilter]);if(J&&Z.maxAnisotropy>1){const re=Math.min(Z.maxAnisotropy,X.getParameter(J.MAX_TEXTURE_MAX_ANISOTROPY_EXT));X[Q](te,J.TEXTURE_MAX_ANISOTROPY_EXT,re)}Z.compare&&X[Q](te,X.TEXTURE_COMPARE_FUNC,compareModeToGlCompare[Z.compare])}function mapFormatToGlFormat(Z){return{r8unorm:Z.RED,r8snorm:Z.RED,r8uint:Z.RED,r8sint:Z.RED,r16uint:Z.RED,r16sint:Z.RED,r16float:Z.RED,rg8unorm:Z.RG,rg8snorm:Z.RG,rg8uint:Z.RG,rg8sint:Z.RG,r32uint:Z.RED,r32sint:Z.RED,r32float:Z.RED,rg16uint:Z.RG,rg16sint:Z.RG,rg16float:Z.RG,rgba8unorm:Z.RGBA,"rgba8unorm-srgb":Z.RGBA,rgba8snorm:Z.RGBA,rgba8uint:Z.RGBA,rgba8sint:Z.RGBA,bgra8unorm:Z.RGBA,"bgra8unorm-srgb":Z.RGBA,rgb9e5ufloat:Z.RGB,rgb10a2unorm:Z.RGBA,rg11b10ufloat:Z.RGB,rg32uint:Z.RG,rg32sint:Z.RG,rg32float:Z.RG,rgba16uint:Z.RGBA,rgba16sint:Z.RGBA,rgba16float:Z.RGBA,rgba32uint:Z.RGBA,rgba32sint:Z.RGBA,rgba32float:Z.RGBA,stencil8:Z.STENCIL_INDEX8,depth16unorm:Z.DEPTH_COMPONENT,depth24plus:Z.DEPTH_COMPONENT,"depth24plus-stencil8":Z.DEPTH_STENCIL,depth32float:Z.DEPTH_COMPONENT,"depth32float-stencil8":Z.DEPTH_STENCIL}}var a$a=Object.defineProperty,E$1=Object.getOwnPropertySymbols,t=Object.prototype.hasOwnProperty,C$1=Object.prototype.propertyIsEnumerable,A$2=(Z,X,K)=>X in Z?a$a(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,S$3=(Z,X)=>{for(var K in X||(X={}))t.call(X,K)&&A$2(Z,K,X[K]);if(E$1)for(var K of E$1(X))C$1.call(X,K)&&A$2(Z,K,X[K]);return Z};function mapFormatToGlInternalFormat(Z,X){return S$3(S$3(S$3(S$3(S$3({r8unorm:Z.R8,r8snorm:Z.R8_SNORM,r8uint:Z.R8UI,r8sint:Z.R8I,r16uint:Z.R16UI,r16sint:Z.R16I,r16float:Z.R16F,rg8unorm:Z.RG8,rg8snorm:Z.RG8_SNORM,rg8uint:Z.RG8UI,rg8sint:Z.RG8I,r32uint:Z.R32UI,r32sint:Z.R32I,r32float:Z.R32F,rg16uint:Z.RG16UI,rg16sint:Z.RG16I,rg16float:Z.RG16F,rgba8unorm:Z.RGBA,"rgba8unorm-srgb":Z.SRGB8_ALPHA8,rgba8snorm:Z.RGBA8_SNORM,rgba8uint:Z.RGBA8UI,rgba8sint:Z.RGBA8I,bgra8unorm:Z.RGBA8,"bgra8unorm-srgb":Z.SRGB8_ALPHA8,rgb9e5ufloat:Z.RGB9_E5,rgb10a2unorm:Z.RGB10_A2,rg11b10ufloat:Z.R11F_G11F_B10F,rg32uint:Z.RG32UI,rg32sint:Z.RG32I,rg32float:Z.RG32F,rgba16uint:Z.RGBA16UI,rgba16sint:Z.RGBA16I,rgba16float:Z.RGBA16F,rgba32uint:Z.RGBA32UI,rgba32sint:Z.RGBA32I,rgba32float:Z.RGBA32F,stencil8:Z.STENCIL_INDEX8,depth16unorm:Z.DEPTH_COMPONENT16,depth24plus:Z.DEPTH_COMPONENT24,"depth24plus-stencil8":Z.DEPTH24_STENCIL8,depth32float:Z.DEPTH_COMPONENT32F,"depth32float-stencil8":Z.DEPTH32F_STENCIL8},X.s3tc?{"bc2-rgba-unorm":X.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,"bc3-rgba-unorm":X.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT}:{}),X.s3tc_sRGB?{"bc2-rgba-unorm-srgb":X.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,"bc3-rgba-unorm-srgb":X.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}:{}),X.bptc?{"bc7-rgba-unorm":X.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,"bc7-rgba-unorm-srgb":X.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT}:{}),X.etc?{"etc2-rgb8unorm":X.etc.COMPRESSED_RGB8_ETC2,"etc2-rgb8unorm-srgb":X.etc.COMPRESSED_SRGB8_ETC2,"etc2-rgb8a1unorm":X.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,"etc2-rgb8a1unorm-srgb":X.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,"etc2-rgba8unorm":X.etc.COMPRESSED_RGBA8_ETC2_EAC,"etc2-rgba8unorm-srgb":X.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,"eac-r11unorm":X.etc.COMPRESSED_R11_EAC,"eac-rg11unorm":X.etc.COMPRESSED_SIGNED_RG11_EAC}:{}),X.astc?{"astc-4x4-unorm":X.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,"astc-4x4-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,"astc-5x5-unorm":X.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,"astc-5x5-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,"astc-6x5-unorm":X.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,"astc-6x5-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,"astc-6x6-unorm":X.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,"astc-6x6-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,"astc-8x5-unorm":X.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,"astc-8x5-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,"astc-8x6-unorm":X.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,"astc-8x6-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,"astc-8x8-unorm":X.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,"astc-8x8-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,"astc-10x5-unorm":X.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,"astc-10x5-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,"astc-10x6-unorm":X.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,"astc-10x6-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,"astc-10x8-unorm":X.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,"astc-10x8-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,"astc-10x10-unorm":X.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,"astc-10x10-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,"astc-12x10-unorm":X.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,"astc-12x10-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,"astc-12x12-unorm":X.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,"astc-12x12-unorm-srgb":X.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR}:{})}function mapFormatToGlType(Z){return{r8unorm:Z.UNSIGNED_BYTE,r8snorm:Z.BYTE,r8uint:Z.UNSIGNED_BYTE,r8sint:Z.BYTE,r16uint:Z.UNSIGNED_SHORT,r16sint:Z.SHORT,r16float:Z.HALF_FLOAT,rg8unorm:Z.UNSIGNED_BYTE,rg8snorm:Z.BYTE,rg8uint:Z.UNSIGNED_BYTE,rg8sint:Z.BYTE,r32uint:Z.UNSIGNED_INT,r32sint:Z.INT,r32float:Z.FLOAT,rg16uint:Z.UNSIGNED_SHORT,rg16sint:Z.SHORT,rg16float:Z.HALF_FLOAT,rgba8unorm:Z.UNSIGNED_BYTE,"rgba8unorm-srgb":Z.UNSIGNED_BYTE,rgba8snorm:Z.BYTE,rgba8uint:Z.UNSIGNED_BYTE,rgba8sint:Z.BYTE,bgra8unorm:Z.UNSIGNED_BYTE,"bgra8unorm-srgb":Z.UNSIGNED_BYTE,rgb9e5ufloat:Z.UNSIGNED_INT_5_9_9_9_REV,rgb10a2unorm:Z.UNSIGNED_INT_2_10_10_10_REV,rg11b10ufloat:Z.UNSIGNED_INT_10F_11F_11F_REV,rg32uint:Z.UNSIGNED_INT,rg32sint:Z.INT,rg32float:Z.FLOAT,rgba16uint:Z.UNSIGNED_SHORT,rgba16sint:Z.SHORT,rgba16float:Z.HALF_FLOAT,rgba32uint:Z.UNSIGNED_INT,rgba32sint:Z.INT,rgba32float:Z.FLOAT,stencil8:Z.UNSIGNED_BYTE,depth16unorm:Z.UNSIGNED_SHORT,depth24plus:Z.UNSIGNED_INT,"depth24plus-stencil8":Z.UNSIGNED_INT_24_8,depth32float:Z.FLOAT,"depth32float-stencil8":Z.FLOAT_32_UNSIGNED_INT_24_8_REV}}function unpremultiplyAlpha(Z){Z instanceof Uint8ClampedArray&&(Z=new Uint8Array(Z.buffer));const X=Z.length;for(let K=0;K<X;K+=4){const J=Z[K+3];if(J!==0){const Q=255.001/J;Z[K]=Z[K]*Q+.5,Z[K+1]=Z[K+1]*Q+.5,Z[K+2]=Z[K+2]*Q+.5}}}const y$6=new Rectangle,G=4;class GlTextureSystem{constructor(X){this.managedTextures=[],this._glTextures=Object.create(null),this._glSamplers=Object.create(null),this._boundTextures=[],this._activeTextureLocation=-1,this._boundSamplers=Object.create(null),this._uploads={image:glUploadImageResource,buffer:glUploadBufferImageResource,video:glUploadVideoResource,compressed:glUploadCompressedTextureResource},this._useSeparateSamplers=!1,this._renderer=X}contextChange(X){if(this._gl=X,!this._mapFormatToInternalFormat){const K=this._renderer.context.extensions;this._mapFormatToInternalFormat=mapFormatToGlInternalFormat(X,K),this._mapFormatToType=mapFormatToGlType(X),this._mapFormatToFormat=mapFormatToGlFormat(X)}for(let K=0;K<16;K++)this.bind(Texture.EMPTY,K)}bind(X,K=0){const J=X.source;X?(this.bindSource(J,K),this._useSeparateSamplers&&this._bindSampler(J.style,K)):(this.bindSource(null,K),this._useSeparateSamplers&&this._bindSampler(null,K))}bindSource(X,K=0){const J=this._gl;if(X._touched=this._renderer.textureGC.count,this._boundTextures[K]!==X){this._boundTextures[K]=X,this._activateLocation(K),X=X||Texture.EMPTY.source;const Q=this.getGlSource(X);J.bindTexture(Q.target,Q.texture)}}_bindSampler(X,K=0){const J=this._gl;if(!X){this._boundSamplers[K]=null,J.bindSampler(K,null);return}const Q=this._getGlSampler(X);this._boundSamplers[K]!==Q&&(this._boundSamplers[K]=Q,J.bindSampler(K,Q))}unbind(X){const K=X.source,J=this._boundTextures,Q=this._gl;for(let ee=0;ee<J.length;ee++)if(J[ee]===K){this._activateLocation(ee);const te=this.getGlSource(K);Q.bindTexture(te.target,null),J[ee]=null}}_activateLocation(X){this._activeTextureLocation!==X&&(this._activeTextureLocation=X,this._gl.activeTexture(this._gl.TEXTURE0+X))}_initSource(X){const K=this._gl,J=new GlTexture(K.createTexture());if(J.type=this._mapFormatToType[X.format],J.internalFormat=this._mapFormatToInternalFormat[X.format],J.format=this._mapFormatToFormat[X.format],X.autoGenerateMipmaps){const Q=Math.max(X.width,X.height);X.mipLevelCount=Math.floor(Math.log2(Q))+1}return this._glTextures[X.uid]=J,X.on("update",this.onSourceUpdate,this),X.on("resize",this.onSourceUpdate,this),X.on("styleChange",this.onStyleChange,this),X.on("destroy",this.onSourceDestroy,this),X.on("unload",this.onSourceUnload,this),this.managedTextures.push(X),this.onSourceUpdate(X),this.onStyleChange(X),J}onStyleChange(X){const K=this._gl,J=this._glTextures[X.uid];K.bindTexture(K.TEXTURE_2D,J.texture),this._boundTextures[this._activeTextureLocation]=X,applyStyleParams(X.style,K,X.mipLevelCount>1,this._renderer.context.extensions.anisotropicFiltering,"texParameteri",K.TEXTURE_2D)}onSourceUnload(X){const K=this._glTextures[X.uid];K&&(this.unbind(X),this._glTextures[X.uid]=null,this._gl.deleteTexture(K.texture))}onSourceUpdate(X){const K=this._gl,J=this.getGlSource(X);K.bindTexture(K.TEXTURE_2D,J.texture),this._boundTextures[this._activeTextureLocation]=X,this._uploads[X.uploadMethodId]?(this._uploads[X.uploadMethodId].upload(X,J,this._gl),X.autoGenerateMipmaps&&X.mipLevelCount>1&&K.generateMipmap(J.target)):K.texImage2D(K.TEXTURE_2D,0,K.RGBA,X.pixelWidth,X.pixelHeight,0,K.RGBA,K.UNSIGNED_BYTE,null)}onSourceDestroy(X){X.off("destroy",this.onSourceDestroy,this),X.off("update",this.onSourceUpdate,this),X.off("unload",this.onSourceUnload,this),X.off("styleChange",this.onStyleChange,this),this.managedTextures.splice(this.managedTextures.indexOf(X),1),this.onSourceUnload(X)}_initSampler(X){const K=this._gl,J=this._gl.createSampler();return this._glSamplers[X._resourceId]=J,applyStyleParams(X,K,this._boundTextures[this._activeTextureLocation].mipLevelCount>1,this._renderer.context.extensions.anisotropicFiltering,"samplerParameteri",J),this._glSamplers[X._resourceId]}_getGlSampler(X){return this._glSamplers[X._resourceId]||this._initSampler(X)}getGlSource(X){return this._glTextures[X.uid]||this._initSource(X)}generateCanvas(X){const{pixels:K,width:J,height:Q}=this.getPixels(X),ee=DOMAdapter.get().createCanvas();ee.width=J,ee.height=Q;const te=ee.getContext("2d");if(te){const re=te.createImageData(J,Q);re.data.set(K),te.putImageData(re,0,0)}return ee}getPixels(X){const K=X.source.resolution,J=y$6;J.x=X.frameX,J.y=X.frameY,J.width=X.frameWidth,J.height=X.frameHeight;const Q=Math.max(Math.round(J.width*K),1),ee=Math.max(Math.round(J.height*K),1),te=new Uint8Array(G*Q*ee),re=this._renderer,ie=re.renderTarget.getRenderTarget(X),ne=re.renderTarget.getGpuRenderTarget(ie),se=re.gl;return se.bindFramebuffer(se.FRAMEBUFFER,ne.resolveTargetFramebuffer),se.readPixels(Math.round(J.x*K),Math.round(J.y*K),Q,ee,se.RGBA,se.UNSIGNED_BYTE,te),{pixels:new Uint8ClampedArray(te.buffer),width:Q,height:ee}}destroy(){this.managedTextures.slice().forEach(X=>this.onSourceDestroy(X)),this.managedTextures=null,this._renderer=null}}GlTextureSystem.extension={type:[u$v.WebGLSystem],name:"texture"};class GlGraphicsAdaptor{init(){const X=new UniformGroup({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"}}),K=compileHighShaderGlProgram({name:"graphics",bits:[colorBitGl,generateTextureBatchBitGl(MAX_TEXTURES),localUniformBitGl,roundPixelsBitGl]});this.shader=new Shader({glProgram:K,resources:{localUniforms:X,batchSamplers:batchSamplersUniformGroup}})}execute(X,K){const J=K.view.context,Q=J.customShader||this.shader,ee=X.renderer,te=ee.graphicsContext,{geometry:re,instructions:ie}=te.getContextRenderData(J);ee.shader.bind(Q),ee.shader.bindUniformBlock(ee.globalUniforms.uniformGroup,"globalUniforms"),ee.geometry.bind(re,Q.glProgram);const ne=ie.instructions;for(let se=0;se<ie.instructionSize;se++){const oe=ne[se];if(oe.size){for(let ae=0;ae<oe.textures.textures.length;ae++)ee.texture.bind(oe.textures.textures[ae],ae);ee.geometry.draw("triangle-list",oe.size,oe.start)}}}destroy(){this.shader.destroy(!0),this.shader=null}}GlGraphicsAdaptor.extension={type:[u$v.WebGLPipesAdaptor],name:"graphics"};class GlMeshAdaptor{init(){const X=compileHighShaderGlProgram({name:"mesh",bits:[localUniformBitGl,textureBitGl,roundPixelsBitGl]});this._shader=new Shader({glProgram:X,resources:{uTexture:Texture.EMPTY.source}}),this._shader.addResource("globalUniforms",0,0),this._shader.addResource("localUniforms",1,0)}execute(X,K){const J=X.renderer,Q=K.view;let ee=Q._shader;if(!ee){ee=this._shader;const te=Q.texture.source;ee.resources.uTexture=te,ee.resources.uSampler=te.style}ee.groups[0]=J.globalUniforms.bindGroup,ee.groups[1]=X.localUniformsBindGroup,J.encoder.draw({geometry:Q._geometry,shader:ee,state:Q.state})}destroy(){this._shader.destroy(!0),this._shader=null}}GlMeshAdaptor.extension={type:[u$v.WebGLPipesAdaptor],name:"mesh"};function executeInstructions(Z,X){const K=Z.instructionSet,J=K.instructions;for(let Q=0;Q<K.instructionSize;Q++){const ee=J[Q];X[ee.renderPipeId].execute(ee)}}class LayerPipe{constructor(X){this._renderer=X}addLayerGroup(X,K){this._renderer.renderPipes.batch.break(K),K.add(X)}execute(X){X.isRenderable&&(this._renderer.globalUniforms.push({worldTransformMatrix:X.worldTransform,worldColor:X.worldColor}),executeInstructions(X,this._renderer.renderPipes),this._renderer.globalUniforms.pop())}destroy(){this._renderer=null}}LayerPipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"layer"};function collectLayerGroups(Z,X=[]){X.push(Z);for(let K=0;K<Z.layerGroupChildren.length;K++)collectLayerGroups(Z.layerGroupChildren[K],X);return X}function mixHexColors(Z,X,K){const J=Z>>16&255,Q=Z>>8&255,ee=Z&255,te=X>>16&255,re=X>>8&255,ie=X&255,ne=J+(te-J)*K,se=Q+(re-Q)*K,oe=ee+(ie-ee)*K;return(ne<<16)+(se<<8)+oe}const a$9=16777215+16777215;function mixColors(Z,X){const K=(Z>>24&255)/255,J=(X>>24&255)/255,Q=K*J*255,ee=Z&16777215,te=X&16777215;let re=16777215;return ee+(te<<32)!==a$9&&(ee===16777215?re=te:te===16777215?re=ee:re=mixHexColors(ee,te,.5)),re+(Q<<24)}function mixStandardAnd32BitColors(Z,X,K){const J=(K>>24&255)/255,Q=X*J*255,ee=((Z&255)<<16)+(Z&65280)+(Z>>16&255),te=K&16777215;let re=16777215;return ee+(te<<32)!==a$9&&(ee===16777215?re=te:te===16777215?re=ee:re=mixHexColors(ee,te,.5)),re+(Q<<24)}const h$d=new Container;function updateLayerGroupTransforms(Z,X=!1){updateLayerTransform(Z);const K=Z.childrenToUpdate,J=Z.updateTick;Z.updateTick++;for(const Q in K){const ee=K[Q],te=ee.list,re=ee.index;for(let ie=0;ie<re;ie++)updateTransformAndChildren(te[ie],J,0);ee.index=0}if(X)for(let Q=0;Q<Z.layerGroupChildren.length;Q++)updateLayerGroupTransforms(Z.layerGroupChildren[Q],X)}function updateLayerTransform(Z){Z.layerGroupParent?(Z.worldTransform.appendFrom(Z.root.layerTransform,Z.layerGroupParent.worldTransform),Z.worldColor=mixColors(Z.root.layerColor,Z.layerGroupParent.worldColor)):(Z.worldTransform.copyFrom(Z.root.layerTransform),Z.worldColor=Z.root.localColor)}function updateTransformAndChildren(Z,X,K){if(X===Z.updateTick)return;Z.updateTick=X,Z.didChange=!1;const J=Z.localTransform;updateLocalTransform(J,Z);const Q=Z.parent;if(Q&&!Q.isLayerRoot?(K=K|Z._updateFlags,Z.layerTransform.appendFrom(J,Q.layerTransform),K&&m$a(Z,Q,K)):(K=Z._updateFlags,Z.layerTransform.copyFrom(J),K&&m$a(Z,h$d,K)),!Z.isLayerRoot){const ee=Z.children,te=ee.length;for(let ie=0;ie<te;ie++)updateTransformAndChildren(ee[ie],X,K);const re=Z.layerGroup;Z.view&&!re.structureDidChange&&re.updateRenderable(Z)}}function m$a(Z,X,K){K&UPDATE_COLOR&&(Z.layerColor=mixColors(Z.localColor,X.layerColor)),K&UPDATE_BLEND&&(Z.layerBlendMode=Z.localBlendMode==="inherit"?X.layerBlendMode:Z.localBlendMode),K&UPDATE_VISIBLE&&(Z.layerVisibleRenderable=Z.localVisibleRenderable&X.layerVisibleRenderable),Z._updateFlags=0}function validateRenderables(Z,X){const{list:K,index:J}=Z.childrenRenderablesToUpdate;let Q=!1;for(let ee=0;ee<J;ee++){const te=K[ee],re=te.view;if(Q=X[re.renderPipeId].validateRenderable(te),Q)break}return Z.structureDidChange=Q,Q}class LayerSystem{constructor(X){this._renderer=X}render({container:X,transform:K}){X.layer=!0;const J=this._renderer,Q=collectLayerGroups(X.layerGroup,[]),ee=J.renderPipes;for(let te=0;te<Q.length;te++){const re=Q[te];re.runOnRender(),re.instructionSet.renderPipes=ee,re.structureDidChange||validateRenderables(re,ee),updateLayerGroupTransforms(re),re.structureDidChange?(re.structureDidChange=!1,buildInstructions(re,ee)):c$8(re),re.childrenRenderablesToUpdate.index=0,J.renderPipes.batch.upload(re.instructionSet)}K&&X.layerGroup.worldTransform.copyFrom(K),J.globalUniforms.start({worldTransformMatrix:X.layerGroup.worldTransform}),executeInstructions(X.layerGroup,ee),ee.uniformBatch&&ee.uniformBatch.renderEnd()}destroy(){this._renderer=null}}LayerSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem,u$v.CanvasSystem],name:"layer"};function c$8(Z){const{list:X,index:K}=Z.childrenRenderablesToUpdate;for(let J=0;J<K;J++){const Q=X[J];Q.didViewUpdate&&Z.updateRenderable(Q)}}function buildUvs(Z,X,K,J,Q,ee,te,re=null){let ie=0;K*=X,Q*=ee;const ne=re.a,se=re.b,oe=re.c,ae=re.d,le=re.tx,ce=re.ty;for(;ie<te;){const de=Z[K],he=Z[K+1];J[Q]=ne*de+oe*he+le,J[Q+1]=se*de+ae*he+ce,Q+=ee,K+=X,ie++}}function buildSimpleUvs(Z,X,K,J){let Q=0;for(X*=K;Q<J;)Z[X]=0,Z[X+1]=0,X+=K,Q++}function transformVertices(Z,X,K,J,Q){const ee=X.a,te=X.b,re=X.c,ie=X.d,ne=X.tx,se=X.ty;K=K||0,J=J||2,Q=Q||Z.length/J-K;let oe=K*J;for(let ae=0;ae<Q;ae++){const le=Z[oe],ce=Z[oe+1];Z[oe]=ee*le+re*ce+ne,Z[oe+1]=te*le+ie*ce+se,oe+=J}}class BatchableGraphics{constructor(){this.batcher=null,this.batch=null,this.applyTransform=!0,this.roundPixels=0}get blendMode(){return this.applyTransform?this.renderable.layerBlendMode:"normal"}packIndex(X,K,J){const Q=this.geometryData.indices;for(let ee=0;ee<this.indexSize;ee++)X[K++]=Q[ee+this.indexOffset]+J-this.vertexOffset}packAttributes(X,K,J,Q){const ee=this.geometryData,te=this.renderable,re=ee.vertices,ie=ee.uvs,ne=this.vertexOffset*2,se=(this.vertexOffset+this.vertexSize)*2,oe=this.color,ae=oe>>16|oe&65280|(oe&255)<<16;if(this.applyTransform){const le=mixColors(ae+(this.alpha*255<<24),te.layerColor),ce=te.layerTransform,de=Q<<16|this.roundPixels&65535,he=ce.a,pe=ce.b,fe=ce.c,ge=ce.d,me=ce.tx,ye=ce.ty;for(let _e=ne;_e<se;_e+=2){const Ce=re[_e],xe=re[_e+1];X[J]=he*Ce+fe*xe+me,X[J+1]=pe*Ce+ge*xe+ye,X[J+2]=ie[_e],X[J+3]=ie[_e+1],K[J+4]=le,K[J+5]=de,J+=6}}else{const le=ae+(this.alpha*255<<24);for(let ce=ne;ce<se;ce+=2)X[J]=re[ce],X[J+1]=re[ce+1],X[J+2]=ie[ce],X[J+3]=ie[ce+1],K[J+4]=le,K[J+5]=Q,J+=6}}get vertSize(){return this.vertexSize}copyTo(X){X.indexOffset=this.indexOffset,X.indexSize=this.indexSize,X.vertexOffset=this.vertexOffset,X.vertexSize=this.vertexSize,X.color=this.color,X.alpha=this.alpha,X.texture=this.texture,X.geometryData=this.geometryData}reset(){this.applyTransform=!0}}const buildCircle={build(Z,X){let K,J,Q,ee,te,re;if(Z.type==="circle"){const me=Z;K=me.x,J=me.y,te=re=me.radius,Q=ee=0}else if(Z.type==="ellipse"){const me=Z;K=me.x,J=me.y,te=me.halfWidth,re=me.halfHeight,Q=ee=0}else{const me=Z,ye=me.width/2,_e=me.height/2;K=me.x+ye,J=me.y+_e,te=re=Math.max(0,Math.min(me.radius,Math.min(ye,_e))),Q=ye-te,ee=_e-re}if(!(te>=0&&re>=0&&Q>=0&&ee>=0))return X;const ie=Math.ceil(2.3*Math.sqrt(te+re)),ne=ie*8+(Q?4:0)+(ee?4:0);if(ne===0)return X;if(ie===0)return X[0]=X[6]=K+Q,X[1]=X[3]=J+ee,X[2]=X[4]=K-Q,X[5]=X[7]=J-ee,X;let se=0,oe=ie*4+(Q?2:0)+2,ae=oe,le=ne,ce=Q+te,de=ee,he=K+ce,pe=K-ce,fe=J+de;if(X[se++]=he,X[se++]=fe,X[--oe]=fe,X[--oe]=pe,ee){const me=J-de;X[ae++]=pe,X[ae++]=me,X[--le]=me,X[--le]=he}for(let me=1;me<ie;me++){const ye=Math.PI/2*(me/ie),_e=Q+Math.cos(ye)*te,Ce=ee+Math.sin(ye)*re,xe=K+_e,be=K-_e,ve=J+Ce,Se=J-Ce;X[se++]=xe,X[se++]=ve,X[--oe]=ve,X[--oe]=be,X[ae++]=be,X[ae++]=Se,X[--le]=Se,X[--le]=xe}ce=Q,de=ee+re,he=K+ce,pe=K-ce,fe=J+de;const ge=J-de;return X[se++]=he,X[se++]=fe,X[--le]=ge,X[--le]=he,Q&&(X[se++]=pe,X[se++]=fe,X[--le]=ge,X[--le]=pe),X},triangulate(Z,X,K,J,Q,ee){if(Z.length===0)return;let te=0,re=0;const ie=Z.length/4;te+=Z[0],re+=Z[1],te+=Z[ie|0],re+=Z[(ie|0)+1],te+=Z[ie*2|0],re+=Z[(ie*2|0)+1],te+=Z[ie*3|0],re+=Z[(ie*3|0)+1],te/=4,re/=4;let ne=J;X[ne*K]=te,X[ne*K+1]=re,ne++;const se=J;X[ne*K]=Z[0],X[ne*K+1]=Z[1],ne++;for(let oe=2;oe<Z.length;oe+=2)X[ne*K]=Z[oe],X[ne*K+1]=Z[oe+1],Q[ee++]=ne,Q[ee++]=se,Q[ee++]=ne-1,ne++;Q[ee++]=ne-1,Q[ee++]=se,Q[ee++]=se+1}},closePointEps=1e-4,curveEps=1e-4;function getOrientationOfPoints(Z){const X=Z.length;if(X<6)return 1;let K=0;for(let J=0,Q=Z[X-2],ee=Z[X-1];J<X;J+=2){const te=Z[J],re=Z[J+1];K+=(te-Q)*(re+ee),Q=te,ee=re}return K<0?-1:1}function ue(Z,X,K,J,Q,ee,te,re){const ie=Z-K*Q,ne=X-J*Q,se=Z+K*ee,oe=X+J*ee;let ae,le;te?(ae=J,le=-K):(ae=-J,le=K);const ce=ie+ae,de=ne+le,he=se+ae,pe=oe+le;return re.push(ce,de),re.push(he,pe),2}function W$4(Z,X,K,J,Q,ee,te,re){const ie=K-Z,ne=J-X;let se=Math.atan2(ie,ne),oe=Math.atan2(Q-Z,ee-X);re&&se<oe?se+=Math.PI*2:!re&&se>oe&&(oe+=Math.PI*2);let ae=se;const le=oe-se,ce=Math.abs(le),de=Math.sqrt(ie*ie+ne*ne),he=(15*ce*Math.sqrt(de)/Math.PI>>0)+1,pe=le/he;if(ae+=pe,re){te.push(Z,X),te.push(K,J);for(let fe=1,ge=ae;fe<he;fe++,ge+=pe)te.push(Z,X),te.push(Z+Math.sin(ge)*de,X+Math.cos(ge)*de);te.push(Z,X),te.push(Q,ee)}else{te.push(K,J),te.push(Z,X);for(let fe=1,ge=ae;fe<he;fe++,ge+=pe)te.push(Z+Math.sin(ge)*de,X+Math.cos(ge)*de),te.push(Z,X);te.push(Q,ee),te.push(Z,X)}return he*2}function buildLine(Z,X,K,J,Q,ee,te,re,ie){const ne=closePointEps;if(Z.length===0)return;const se=X;let oe=se.alignment;if(X.alignment!==.5){let Me=getOrientationOfPoints(Z);K&&(Me*=-1),oe=(oe-.5)*Me+.5}const ae=new Point(Z[0],Z[1]),le=new Point(Z[Z.length-2],Z[Z.length-1]),ce=J,de=Math.abs(ae.x-le.x)<ne&&Math.abs(ae.y-le.y)<ne;if(ce){Z=Z.slice(),de&&(Z.pop(),Z.pop(),le.set(Z[Z.length-2],Z[Z.length-1]));const Me=(ae.x+le.x)*.5,De=(le.y+ae.y)*.5;Z.unshift(Me,De),Z.push(Me,De)}const he=Q,pe=Z.length/2;let fe=Z.length;const ge=he.length/2,me=se.width/2,ye=me*me,_e=se.miterLimit*se.miterLimit;let Ce=Z[0],xe=Z[1],be=Z[2],ve=Z[3],Se=0,Pe=0,Te=-(xe-ve),Ae=Ce-be,Ie=0,we=0,Be=Math.sqrt(Te*Te+Ae*Ae);Te/=Be,Ae/=Be,Te*=me,Ae*=me;const Re=oe,Ee=(1-Re)*2,$e=Re*2;ce||(se.cap==="round"?fe+=W$4(Ce-Te*(Ee-$e)*.5,xe-Ae*(Ee-$e)*.5,Ce-Te*Ee,xe-Ae*Ee,Ce+Te*$e,xe+Ae*$e,he,!0)+2:se.cap==="square"&&(fe+=ue(Ce,xe,Te,Ae,Ee,$e,!0,he))),he.push(Ce-Te*Ee,xe-Ae*Ee),he.push(Ce+Te*$e,xe+Ae*$e);for(let Me=1;Me<pe-1;++Me){Ce=Z[(Me-1)*2],xe=Z[(Me-1)*2+1],be=Z[Me*2],ve=Z[Me*2+1],Se=Z[(Me+1)*2],Pe=Z[(Me+1)*2+1],Te=-(xe-ve),Ae=Ce-be,Be=Math.sqrt(Te*Te+Ae*Ae),Te/=Be,Ae/=Be,Te*=me,Ae*=me,Ie=-(ve-Pe),we=be-Se,Be=Math.sqrt(Ie*Ie+we*we),Ie/=Be,we/=Be,Ie*=me,we*=me;const De=be-Ce,Ue=xe-ve,Ne=be-Se,Le=Pe-ve,je=De*Ne+Ue*Le,He=Ue*Ne-Le*De,Ve=He<0;if(Math.abs(He)<.001*Math.abs(je)){he.push(be-Te*Ee,ve-Ae*Ee),he.push(be+Te*$e,ve+Ae*$e),je>=0&&(se.join==="round"?fe+=W$4(be,ve,be-Te*Ee,ve-Ae*Ee,be-Ie*Ee,ve-we*Ee,he,!1)+4:fe+=2,he.push(be-Ie*$e,ve-we*$e),he.push(be+Ie*Ee,ve+we*Ee));continue}const Ye=(-Te+Ce)*(-Ae+ve)-(-Te+be)*(-Ae+xe),Ze=(-Ie+Se)*(-we+ve)-(-Ie+be)*(-we+Pe),ze=(De*Ze-Ne*Ye)/He,We=(Le*Ye-Ue*Ze)/He,Xe=(ze-be)*(ze-be)+(We-ve)*(We-ve),Fe=be+(ze-be)*Ee,Ge=ve+(We-ve)*Ee,Oe=be-(ze-be)*$e,ke=ve-(We-ve)*$e,Je=Math.min(De*De+Ue*Ue,Ne*Ne+Le*Le),qe=Ve?Ee:$e,Qe=Je+qe*qe*ye;Xe<=Qe?se.join==="bevel"||Xe/ye>_e?(Ve?(he.push(Fe,Ge),he.push(be+Te*$e,ve+Ae*$e),he.push(Fe,Ge),he.push(be+Ie*$e,ve+we*$e)):(he.push(be-Te*Ee,ve-Ae*Ee),he.push(Oe,ke),he.push(be-Ie*Ee,ve-we*Ee),he.push(Oe,ke)),fe+=2):se.join==="round"?Ve?(he.push(Fe,Ge),he.push(be+Te*$e,ve+Ae*$e),fe+=W$4(be,ve,be+Te*$e,ve+Ae*$e,be+Ie*$e,ve+we*$e,he,!0)+4,he.push(Fe,Ge),he.push(be+Ie*$e,ve+we*$e)):(he.push(be-Te*Ee,ve-Ae*Ee),he.push(Oe,ke),fe+=W$4(be,ve,be-Te*Ee,ve-Ae*Ee,be-Ie*Ee,ve-we*Ee,he,!1)+4,he.push(be-Ie*Ee,ve-we*Ee),he.push(Oe,ke)):(he.push(Fe,Ge),he.push(Oe,ke)):(he.push(be-Te*Ee,ve-Ae*Ee),he.push(be+Te*$e,ve+Ae*$e),se.join==="round"?Ve?fe+=W$4(be,ve,be+Te*$e,ve+Ae*$e,be+Ie*$e,ve+we*$e,he,!0)+2:fe+=W$4(be,ve,be-Te*Ee,ve-Ae*Ee,be-Ie*Ee,ve-we*Ee,he,!1)+2:se.join==="miter"&&Xe/ye<=_e&&(Ve?(he.push(Oe,ke),he.push(Oe,ke)):(he.push(Fe,Ge),he.push(Fe,Ge)),fe+=2),he.push(be-Ie*Ee,ve-we*Ee),he.push(be+Ie*$e,ve+we*$e),fe+=2)}Ce=Z[(pe-2)*2],xe=Z[(pe-2)*2+1],be=Z[(pe-1)*2],ve=Z[(pe-1)*2+1],Te=-(xe-ve),Ae=Ce-be,Be=Math.sqrt(Te*Te+Ae*Ae),Te/=Be,Ae/=Be,Te*=me,Ae*=me,he.push(be-Te*Ee,ve-Ae*Ee),he.push(be+Te*$e,ve+Ae*$e),ce||(se.cap==="round"?fe+=W$4(be-Te*(Ee-$e)*.5,ve-Ae*(Ee-$e)*.5,be-Te*Ee,ve-Ae*Ee,be+Te*$e,ve+Ae*$e,he,!1)+2:se.cap==="square"&&(fe+=ue(be,ve,Te,Ae,Ee,$e,!1,he)));const Ke=curveEps*curveEps;for(let Me=ge;Me<fe+ge-2;++Me)Ce=he[Me*2],xe=he[Me*2+1],be=he[(Me+1)*2],ve=he[(Me+1)*2+1],Se=he[(Me+2)*2],Pe=he[(Me+2)*2+1],!(Math.abs(Ce*(ve-Pe)+be*(Pe-xe)+Se*(xe-ve))<Ke)&&re.push(Me,Me+1,Me+2)}var earcut_1=earcut,_default=earcut;function earcut(Z,X,K){K=K||2;var J=X&&X.length,Q=J?X[0]*K:Z.length,ee=linkedList(Z,0,Q,K,!0),te=[];if(!ee||ee.next===ee.prev)return te;var re,ie,ne,se,oe,ae,le;if(J&&(ee=eliminateHoles(Z,X,ee,K)),Z.length>80*K){re=ne=Z[0],ie=se=Z[1];for(var ce=K;ce<Q;ce+=K)oe=Z[ce],ae=Z[ce+1],oe<re&&(re=oe),ae<ie&&(ie=ae),oe>ne&&(ne=oe),ae>se&&(se=ae);le=Math.max(ne-re,se-ie),le=le!==0?32767/le:0}return earcutLinked(ee,te,K,re,ie,le,0),te}function linkedList(Z,X,K,J,Q){var ee,te;if(Q===signedArea(Z,X,K,J)>0)for(ee=X;ee<K;ee+=J)te=insertNode(ee,Z[ee],Z[ee+1],te);else for(ee=K-J;ee>=X;ee-=J)te=insertNode(ee,Z[ee],Z[ee+1],te);return te&&equals(te,te.next)&&(removeNode(te),te=te.next),te}function filterPoints(Z,X){if(!Z)return Z;X||(X=Z);var K=Z,J;do if(J=!1,!K.steiner&&(equals(K,K.next)||area(K.prev,K,K.next)===0)){if(removeNode(K),K=X=K.prev,K===K.next)break;J=!0}else K=K.next;while(J||K!==X);return X}function earcutLinked(Z,X,K,J,Q,ee,te){if(Z){!te&&ee&&indexCurve(Z,J,Q,ee);for(var re=Z,ie,ne;Z.prev!==Z.next;){if(ie=Z.prev,ne=Z.next,ee?isEarHashed(Z,J,Q,ee):isEar(Z)){X.push(ie.i/K|0),X.push(Z.i/K|0),X.push(ne.i/K|0),removeNode(Z),Z=ne.next,re=ne.next;continue}if(Z=ne,Z===re){te?te===1?(Z=cureLocalIntersections(filterPoints(Z),X,K),earcutLinked(Z,X,K,J,Q,ee,2)):te===2&&splitEarcut(Z,X,K,J,Q,ee):earcutLinked(filterPoints(Z),X,K,J,Q,ee,1);break}}}}function isEar(Z){var X=Z.prev,K=Z,J=Z.next;if(area(X,K,J)>=0)return!1;for(var Q=X.x,ee=K.x,te=J.x,re=X.y,ie=K.y,ne=J.y,se=Q<ee?Q<te?Q:te:ee<te?ee:te,oe=re<ie?re<ne?re:ne:ie<ne?ie:ne,ae=Q>ee?Q>te?Q:te:ee>te?ee:te,le=re>ie?re>ne?re:ne:ie>ne?ie:ne,ce=J.next;ce!==X;){if(ce.x>=se&&ce.x<=ae&&ce.y>=oe&&ce.y<=le&&pointInTriangle(Q,re,ee,ie,te,ne,ce.x,ce.y)&&area(ce.prev,ce,ce.next)>=0)return!1;ce=ce.next}return!0}function isEarHashed(Z,X,K,J){var Q=Z.prev,ee=Z,te=Z.next;if(area(Q,ee,te)>=0)return!1;for(var re=Q.x,ie=ee.x,ne=te.x,se=Q.y,oe=ee.y,ae=te.y,le=re<ie?re<ne?re:ne:ie<ne?ie:ne,ce=se<oe?se<ae?se:ae:oe<ae?oe:ae,de=re>ie?re>ne?re:ne:ie>ne?ie:ne,he=se>oe?se>ae?se:ae:oe>ae?oe:ae,pe=zOrder(le,ce,X,K,J),fe=zOrder(de,he,X,K,J),ge=Z.prevZ,me=Z.nextZ;ge&&ge.z>=pe&&me&&me.z<=fe;){if(ge.x>=le&&ge.x<=de&&ge.y>=ce&&ge.y<=he&&ge!==Q&&ge!==te&&pointInTriangle(re,se,ie,oe,ne,ae,ge.x,ge.y)&&area(ge.prev,ge,ge.next)>=0||(ge=ge.prevZ,me.x>=le&&me.x<=de&&me.y>=ce&&me.y<=he&&me!==Q&&me!==te&&pointInTriangle(re,se,ie,oe,ne,ae,me.x,me.y)&&area(me.prev,me,me.next)>=0))return!1;me=me.nextZ}for(;ge&&ge.z>=pe;){if(ge.x>=le&&ge.x<=de&&ge.y>=ce&&ge.y<=he&&ge!==Q&&ge!==te&&pointInTriangle(re,se,ie,oe,ne,ae,ge.x,ge.y)&&area(ge.prev,ge,ge.next)>=0)return!1;ge=ge.prevZ}for(;me&&me.z<=fe;){if(me.x>=le&&me.x<=de&&me.y>=ce&&me.y<=he&&me!==Q&&me!==te&&pointInTriangle(re,se,ie,oe,ne,ae,me.x,me.y)&&area(me.prev,me,me.next)>=0)return!1;me=me.nextZ}return!0}function cureLocalIntersections(Z,X,K){var J=Z;do{var Q=J.prev,ee=J.next.next;!equals(Q,ee)&&intersects(Q,J,J.next,ee)&&locallyInside(Q,ee)&&locallyInside(ee,Q)&&(X.push(Q.i/K|0),X.push(J.i/K|0),X.push(ee.i/K|0),removeNode(J),removeNode(J.next),J=Z=ee),J=J.next}while(J!==Z);return filterPoints(J)}function splitEarcut(Z,X,K,J,Q,ee){var te=Z;do{for(var re=te.next.next;re!==te.prev;){if(te.i!==re.i&&isValidDiagonal(te,re)){var ie=splitPolygon(te,re);te=filterPoints(te,te.next),ie=filterPoints(ie,ie.next),earcutLinked(te,X,K,J,Q,ee,0),earcutLinked(ie,X,K,J,Q,ee,0);return}re=re.next}te=te.next}while(te!==Z)}function eliminateHoles(Z,X,K,J){var Q=[],ee,te,re,ie,ne;for(ee=0,te=X.length;ee<te;ee++)re=X[ee]*J,ie=ee<te-1?X[ee+1]*J:Z.length,ne=linkedList(Z,re,ie,J,!1),ne===ne.next&&(ne.steiner=!0),Q.push(getLeftmost(ne));for(Q.sort(compareX),ee=0;ee<Q.length;ee++)K=eliminateHole(Q[ee],K);return K}function compareX(Z,X){return Z.x-X.x}function eliminateHole(Z,X){var K=findHoleBridge(Z,X);if(!K)return X;var J=splitPolygon(K,Z);return filterPoints(J,J.next),filterPoints(K,K.next)}function findHoleBridge(Z,X){var K=X,J=Z.x,Q=Z.y,ee=-1/0,te;do{if(Q<=K.y&&Q>=K.next.y&&K.next.y!==K.y){var re=K.x+(Q-K.y)*(K.next.x-K.x)/(K.next.y-K.y);if(re<=J&&re>ee&&(ee=re,te=K.x<K.next.x?K:K.next,re===J))return te}K=K.next}while(K!==X);if(!te)return null;var ie=te,ne=te.x,se=te.y,oe=1/0,ae;K=te;do J>=K.x&&K.x>=ne&&J!==K.x&&pointInTriangle(Q<se?J:ee,Q,ne,se,Q<se?ee:J,Q,K.x,K.y)&&(ae=Math.abs(Q-K.y)/(J-K.x),locallyInside(K,Z)&&(ae<oe||ae===oe&&(K.x>te.x||K.x===te.x&&sectorContainsSector(te,K)))&&(te=K,oe=ae)),K=K.next;while(K!==ie);return te}function sectorContainsSector(Z,X){return area(Z.prev,Z,X.prev)<0&&area(X.next,Z,Z.next)<0}function indexCurve(Z,X,K,J){var Q=Z;do Q.z===0&&(Q.z=zOrder(Q.x,Q.y,X,K,J)),Q.prevZ=Q.prev,Q.nextZ=Q.next,Q=Q.next;while(Q!==Z);Q.prevZ.nextZ=null,Q.prevZ=null,sortLinked(Q)}function sortLinked(Z){var X,K,J,Q,ee,te,re,ie,ne=1;do{for(K=Z,Z=null,ee=null,te=0;K;){for(te++,J=K,re=0,X=0;X<ne&&(re++,J=J.nextZ,!!J);X++);for(ie=ne;re>0||ie>0&&J;)re!==0&&(ie===0||!J||K.z<=J.z)?(Q=K,K=K.nextZ,re--):(Q=J,J=J.nextZ,ie--),ee?ee.nextZ=Q:Z=Q,Q.prevZ=ee,ee=Q;K=J}ee.nextZ=null,ne*=2}while(te>1);return Z}function zOrder(Z,X,K,J,Q){return Z=(Z-K)*Q|0,X=(X-J)*Q|0,Z=(Z|Z<<8)&16711935,Z=(Z|Z<<4)&252645135,Z=(Z|Z<<2)&858993459,Z=(Z|Z<<1)&1431655765,X=(X|X<<8)&16711935,X=(X|X<<4)&252645135,X=(X|X<<2)&858993459,X=(X|X<<1)&1431655765,Z|X<<1}function getLeftmost(Z){var X=Z,K=Z;do(X.x<K.x||X.x===K.x&&X.y<K.y)&&(K=X),X=X.next;while(X!==Z);return K}function pointInTriangle(Z,X,K,J,Q,ee,te,re){return(Q-te)*(X-re)>=(Z-te)*(ee-re)&&(Z-te)*(J-re)>=(K-te)*(X-re)&&(K-te)*(ee-re)>=(Q-te)*(J-re)}function isValidDiagonal(Z,X){return Z.next.i!==X.i&&Z.prev.i!==X.i&&!intersectsPolygon(Z,X)&&(locallyInside(Z,X)&&locallyInside(X,Z)&&middleInside(Z,X)&&(area(Z.prev,Z,X.prev)||area(Z,X.prev,X))||equals(Z,X)&&area(Z.prev,Z,Z.next)>0&&area(X.prev,X,X.next)>0)}function area(Z,X,K){return(X.y-Z.y)*(K.x-X.x)-(X.x-Z.x)*(K.y-X.y)}function equals(Z,X){return Z.x===X.x&&Z.y===X.y}function intersects(Z,X,K,J){var Q=sign(area(Z,X,K)),ee=sign(area(Z,X,J)),te=sign(area(K,J,Z)),re=sign(area(K,J,X));return!!(Q!==ee&&te!==re||Q===0&&onSegment(Z,K,X)||ee===0&&onSegment(Z,J,X)||te===0&&onSegment(K,Z,J)||re===0&&onSegment(K,X,J))}function onSegment(Z,X,K){return X.x<=Math.max(Z.x,K.x)&&X.x>=Math.min(Z.x,K.x)&&X.y<=Math.max(Z.y,K.y)&&X.y>=Math.min(Z.y,K.y)}function sign(Z){return Z>0?1:Z<0?-1:0}function intersectsPolygon(Z,X){var K=Z;do{if(K.i!==Z.i&&K.next.i!==Z.i&&K.i!==X.i&&K.next.i!==X.i&&intersects(K,K.next,Z,X))return!0;K=K.next}while(K!==Z);return!1}function locallyInside(Z,X){return area(Z.prev,Z,Z.next)<0?area(Z,X,Z.next)>=0&&area(Z,Z.prev,X)>=0:area(Z,X,Z.prev)<0||area(Z,Z.next,X)<0}function middleInside(Z,X){var K=Z,J=!1,Q=(Z.x+X.x)/2,ee=(Z.y+X.y)/2;do K.y>ee!=K.next.y>ee&&K.next.y!==K.y&&Q<(K.next.x-K.x)*(ee-K.y)/(K.next.y-K.y)+K.x&&(J=!J),K=K.next;while(K!==Z);return J}function splitPolygon(Z,X){var K=new Node(Z.i,Z.x,Z.y),J=new Node(X.i,X.x,X.y),Q=Z.next,ee=X.prev;return Z.next=X,X.prev=Z,K.next=Q,Q.prev=K,J.next=K,K.prev=J,ee.next=J,J.prev=ee,J}function insertNode(Z,X,K,J){var Q=new Node(Z,X,K);return J?(Q.next=J.next,Q.prev=J,J.next.prev=Q,J.next=Q):(Q.prev=Q,Q.next=Q),Q}function removeNode(Z){Z.next.prev=Z.prev,Z.prev.next=Z.next,Z.prevZ&&(Z.prevZ.nextZ=Z.nextZ),Z.nextZ&&(Z.nextZ.prevZ=Z.prevZ)}function Node(Z,X,K){this.i=Z,this.x=X,this.y=K,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}earcut.deviation=function(Z,X,K,J){var Q=X&&X.length,ee=Q?X[0]*K:Z.length,te=Math.abs(signedArea(Z,0,ee,K));if(Q)for(var re=0,ie=X.length;re<ie;re++){var ne=X[re]*K,se=re<ie-1?X[re+1]*K:Z.length;te-=Math.abs(signedArea(Z,ne,se,K))}var oe=0;for(re=0;re<J.length;re+=3){var ae=J[re]*K,le=J[re+1]*K,ce=J[re+2]*K;oe+=Math.abs((Z[ae]-Z[ce])*(Z[le+1]-Z[ae+1])-(Z[ae]-Z[le])*(Z[ce+1]-Z[ae+1]))}return te===0&&oe===0?0:Math.abs((oe-te)/te)};function signedArea(Z,X,K,J){for(var Q=0,ee=X,te=K-J;ee<K;ee+=J)Q+=(Z[te]-Z[ee])*(Z[ee+1]+Z[te+1]),te=ee;return Q}earcut.flatten=function(Z){for(var X=Z[0][0].length,K={vertices:[],holes:[],dimensions:X},J=0,Q=0;Q<Z.length;Q++){for(var ee=0;ee<Z[Q].length;ee++)for(var te=0;te<X;te++)K.vertices.push(Z[Q][ee][te]);Q>0&&(J+=Z[Q-1].length,K.holes.push(J))}return K},earcut_1.default=_default;function triangulateWithHoles(Z,X,K,J,Q,ee,te){const re=earcut_1(Z,X,2);if(!re)return;for(let ne=0;ne<re.length;ne+=3)ee[te++]=re[ne]+Q,ee[te++]=re[ne+1]+Q,ee[te++]=re[ne+2]+Q;let ie=Q*J;for(let ne=0;ne<Z.length;ne+=2)K[ie]=Z[ne],K[ie+1]=Z[ne+1],ie+=J}const l$b=[],buildPolygon={build(Z,X){for(let K=0;K<Z.points.length;K++)X[K]=Z.points[K];return X},triangulate(Z,X,K,J,Q,ee){triangulateWithHoles(Z,l$b,X,K,J,Q,ee)}},buildRectangle={build(Z,X){const K=Z,J=K.x,Q=K.y,ee=K.width,te=K.height;return ee>=0&&te>=0&&(X[0]=J,X[1]=Q,X[2]=J+ee,X[3]=Q,X[4]=J+ee,X[5]=Q+te,X[6]=J,X[7]=Q+te),X},triangulate(Z,X,K,J,Q,ee){let te=0;J*=K,X[J+te]=Z[0],X[J+te+1]=Z[1],te+=K,X[J+te]=Z[2],X[J+te+1]=Z[3],te+=K,X[J+te]=Z[6],X[J+te+1]=Z[7],te+=K,X[J+te]=Z[4],X[J+te+1]=Z[5],te+=K;const re=J/K;Q[ee++]=re,Q[ee++]=re+1,Q[ee++]=re+2,Q[ee++]=re+1,Q[ee++]=re+3,Q[ee++]=re+2}},buildTriangle={build(Z,X){return X[0]=Z.x,X[1]=Z.y,X[2]=Z.x2,X[3]=Z.y2,X[4]=Z.x3,X[5]=Z.y3,X},triangulate(Z,X,K,J,Q,ee){let te=0;J*=K,X[J+te]=Z[0],X[J+te+1]=Z[1],te+=K,X[J+te]=Z[2],X[J+te+1]=Z[3],te+=K,X[J+te]=Z[4],X[J+te+1]=Z[5];const re=J/K;Q[ee++]=re,Q[ee++]=re+1,Q[ee++]=re+2}},y$5={rectangle:buildRectangle,polygon:buildPolygon,triangle:buildTriangle,circle:buildCircle,ellipse:buildCircle,roundedRectangle:buildCircle},M$1=new Rectangle;function buildContextBatches(Z){const X={vertices:[],uvs:[],indices:[]},K=[];for(let J=0;J<Z.instructions.length;J++){const Q=Z.instructions[J];if(Q.action==="texture")W$3(Q.data,K,X);else if(Q.action==="fill"||Q.action==="stroke"){const ee=Q.action==="stroke",te=Q.data.path.shapePath,re=Q.data.style,ie=Q.data.hole;ee&&ie&&I(ie.shapePath,re,null,!0,K,X),I(te,re,ie,ee,K,X)}}return K}function W$3(Z,X,K){const{vertices:J,uvs:Q,indices:ee}=K,te=ee.length,re=J.length/2,ie=[],ne=y$5.rectangle,se=M$1,oe=Z.image;se.x=Z.dx,se.y=Z.dy,se.width=Z.dw,se.height=Z.dh;const ae=Z.transform;ne.build(se,ie),ae&&transformVertices(ie,ae),ne.triangulate(ie,J,2,re,ee,te);const le=oe.layout.uvs;Q.push(le.x0,le.y0,le.x1,le.y1,le.x3,le.y3,le.x2,le.y2);const ce=BigPool.get(BatchableGraphics);ce.indexOffset=te,ce.indexSize=ee.length-te,ce.vertexOffset=re,ce.vertexSize=J.length/2-re,ce.color=Z.style,ce.alpha=Z.alpha,ce.texture=oe,ce.geometryData=K,X.push(ce)}function I(Z,X,K,J,Q,ee){const{vertices:te,uvs:re,indices:ie}=ee,ne=Z.shapePrimitives.length-1;Z.shapePrimitives.forEach(({shape:se,transform:oe},ae)=>{var le;const ce=ie.length,de=te.length/2,he=[],pe=y$5[se.type];if(pe.build(se,he),oe&&transformVertices(he,oe),J){const ye=(le=se.closePath)!=null?le:!0;buildLine(he,X,!1,ye,te,2,de,ie,ce)}else if(K&&ne===ae){ne!==0&&console.warn("[Pixi Graphics] only the last shape have be cut out");const ye=[],_e=he.slice();L(K.shapePath).forEach(Ce=>{ye.push(_e.length/2),_e.push(...Ce)}),triangulateWithHoles(_e,ye,te,2,de,ie,ce)}else pe.triangulate(he,te,2,de,ie,ce);const fe=re.length/2,ge=X.texture;if(ge!==Texture.WHITE){const ye=X.matrix;oe&&ye.append(oe.clone().invert()),buildUvs(te,2,de,re,fe,2,te.length/2-de,ye)}else buildSimpleUvs(re,fe,2,te.length/2-de);const me=BigPool.get(BatchableGraphics);me.indexOffset=ce,me.indexSize=ie.length-ce,me.vertexOffset=de,me.vertexSize=te.length/2-de,me.color=X.color,me.alpha=X.alpha,me.texture=ge,me.geometryData=ee,Q.push(me)})}function L(Z){if(!Z)return[];const X=Z.shapePrimitives,K=[];for(let J=0;J<X.length;J++){const Q=X[J].shape,ee=[];y$5[Q.type].build(Q,ee),K.push(ee)}return K}class GpuGraphicsContext{}class GraphicsContextRenderData{constructor(){this.geometry=new BatchGeometry,this.instructions=new InstructionSet}init(){this.instructions.reset()}}class GraphicsContextSystem{constructor(){this._activeBatchers=[],this._gpuContextHash={},this._graphicsDataContextHash=Object.create(null),this._needsContextNeedsRebuild=[]}prerender(){this._returnActiveBatchers()}getContextRenderData(X){return this._graphicsDataContextHash[X.uid]||this._initContextRenderData(X)}updateGpuContext(X){let K=this._gpuContextHash[X.uid]||this._initContext(X);if(X.dirty){K?this._cleanGraphicsContextData(X):K=this._initContext(X);const J=buildContextBatches(X);let Q=0;const ee=X.batchMode;let te=!0;if(X.customShader||ee==="no-batch")te=!1;else if(ee==="auto"){for(let re=0;re<J.length;re++)if(Q+=J[re].vertexSize,Q>400){te=!1;break}}K=this._gpuContextHash[X.uid]={isBatchable:te,batches:J},X.dirty=!1}return K}getGpuContext(X){return this._gpuContextHash[X.uid]||this._initContext(X)}_returnActiveBatchers(){for(let X=0;X<this._activeBatchers.length;X++)BigPool.return(this._activeBatchers[X]);this._activeBatchers.length=0}_initContextRenderData(X){const K=BigPool.get(GraphicsContextRenderData),J=this._gpuContextHash[X.uid].batches;let Q=0,ee=0;J.forEach(ne=>{ne.applyTransform=!1,Q+=ne.geometryData.vertices.length,ee+=ne.geometryData.indices.length});const te=BigPool.get(Batcher);this._activeBatchers.push(te),te.ensureAttributeBuffer(Q),te.ensureIndexBuffer(ee),te.begin();for(let ne=0;ne<J.length;ne++){const se=J[ne];te.add(se)}te.finish(K.instructions);const re=K.geometry;re.indexBuffer.setDataWithSize(te.indexBuffer,te.indexSize,!0),re.buffers[0].setDataWithSize(te.attributeBuffer.float32View,te.attributeSize,!0);const ie=te.batches;for(let ne=0;ne<ie.length;ne++){const se=ie[ne];se.bindGroup=getTextureBatchBindGroup(se.textures.textures,se.textures.count)}return this._graphicsDataContextHash[X.uid]=K,K}_initContext(X){const K=new GpuGraphicsContext;return this._gpuContextHash[X.uid]=K,X.on("update",this.onGraphicsContextUpdate,this),X.on("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[X.uid]}onGraphicsContextUpdate(X){this._needsContextNeedsRebuild.push(X)}onGraphicsContextDestroy(X){this._cleanGraphicsContextData(X),this._gpuContextHash[X.uid]=null}_cleanGraphicsContextData(X){const K=this._gpuContextHash[X.uid];K.isBatchable||this._graphicsDataContextHash[X.uid]&&(BigPool.return(this.getContextRenderData(X)),this._graphicsDataContextHash[X.uid]=null),K.batches&&K.batches.forEach(J=>{BigPool.return(J)})}destroy(){for(const X of this._needsContextNeedsRebuild)this._cleanGraphicsContextData(X),this._gpuContextHash[X.uid]=null;this._needsContextNeedsRebuild.length=0}}GraphicsContextSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem,u$v.CanvasSystem],name:"graphicsContext"};function colorToUniform(Z,X,K,J){K[J++]=(Z>>16&255)/255,K[J++]=(Z>>8&255)/255,K[J++]=(Z&255)/255,K[J++]=X}function color32BitToUniform(Z,X,K){X[K++]=(Z&255)/255,X[K++]=(Z>>8&255)/255,X[K++]=(Z>>16&255)/255,X[K++]=(Z>>24&255)/255}class GraphicsPipe{constructor(X,K){this.state=State.for2d(),this._renderableBatchesHash=Object.create(null),this.renderer=X,this._adaptor=K,this._adaptor.init()}validateRenderable(X){const K=X.view.context,J=!!this._renderableBatchesHash[X.uid],Q=this.renderer.graphicsContext.updateGpuContext(K);return!!(Q.isBatchable||J!==Q.isBatchable)}addRenderable(X,K){const J=this.renderer.graphicsContext.updateGpuContext(X.view.context);X.view._didUpdate&&(X.view._didUpdate=!1,this._rebuild(X)),J.isBatchable?this._addToBatcher(X,K):(this.renderer.renderPipes.batch.break(K),K.add({renderPipeId:"graphics",renderable:X}))}updateRenderable(X){const K=this._renderableBatchesHash[X.uid];if(K)for(let J=0;J<K.length;J++){const Q=K[J];Q.batcher.updateElement(Q)}}destroyRenderable(X){this._removeBatchForRenderable(X.uid)}execute({renderable:X}){if(!X.isRenderable)return;const K=this.renderer,J=X.view.context;if(!K.graphicsContext.getGpuContext(J).batches.length)return;const Q=J.customShader||this._adaptor.shader;this.state.blendMode=X.layerBlendMode;const ee=Q.resources.localUniforms.uniforms;ee.uTransformMatrix=X.layerTransform,ee.uRound=K._roundPixels|X.view.roundPixels,color32BitToUniform(X.layerColor,ee.uColor,0),this._adaptor.execute(this,X)}_rebuild(X){const K=!!this._renderableBatchesHash[X.uid],J=this.renderer.graphicsContext.updateGpuContext(X.view.context);K&&this._removeBatchForRenderable(X.uid),J.isBatchable&&this._initBatchesForRenderable(X),X.view.batched=J.isBatchable}_addToBatcher(X,K){const J=this.renderer.renderPipes.batch,Q=this._getBatchesForRenderable(X);for(let ee=0;ee<Q.length;ee++){const te=Q[ee];J.addToBatch(te,K)}}_getBatchesForRenderable(X){return this._renderableBatchesHash[X.uid]||this._initBatchesForRenderable(X)}_initBatchesForRenderable(X){const K=X.view.context,J=this.renderer.graphicsContext.getGpuContext(K),Q=this.renderer._roundPixels|X.view.roundPixels,ee=J.batches.map(te=>{const re=BigPool.get(BatchableGraphics);return te.copyTo(re),re.renderable=X,re.roundPixels=Q,re});return this._renderableBatchesHash[X.uid]=ee,X.on("destroyed",()=>{this.destroyRenderable(X)}),ee}_removeBatchForRenderable(X){this._renderableBatchesHash[X].forEach(K=>{BigPool.return(K)}),this._renderableBatchesHash[X]=null}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null;for(const X in this._renderableBatchesHash)this._removeBatchForRenderable(X);this._renderableBatchesHash=null}}GraphicsPipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"graphics"};class BatchableMesh{constructor(){this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.layerBlendMode}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null}packIndex(X,K,J){const Q=this.renderable.view.geometry.indices;for(let ee=0;ee<Q.length;ee++)X[K++]=Q[ee]+J}packAttributes(X,K,J,Q){const ee=this.renderable,te=this.renderable.view.geometry,re=ee.layerTransform,ie=Q<<16|this.roundPixels&65535,ne=re.a,se=re.b,oe=re.c,ae=re.d,le=re.tx,ce=re.ty,de=te.positions,he=te.uvs,pe=ee.layerColor;for(let fe=0;fe<de.length;fe+=2){const ge=de[fe],me=de[fe+1];X[J]=ne*ge+oe*me+le,X[J+1]=se*ge+ae*me+ce,X[J+2]=he[fe],X[J+3]=he[fe+1],K[J+4]=pe,K[J+5]=ie,J+=6}}get vertexSize(){return this.renderable.view.geometry.positions.length/2}get indexSize(){return this.renderable.view.geometry.indices.length}}class MeshPipe{constructor(X,K){this.localUniforms=new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new BindGroup({0:this.localUniforms}),this._renderableHash=Object.create(null),this._gpuBatchableMeshHash=Object.create(null),this.renderer=X,this._adaptor=K,this._adaptor.init()}validateRenderable(X){const K=this._getRenderableData(X),J=K.batched,Q=X.view.batched;if(K.batched=Q,J!==Q)return!0;if(Q){const ee=X.view._geometry;if(ee.indices.length!==K.indexSize||ee.positions.length!==K.vertexSize)return K.indexSize=ee.indices.length,K.vertexSize=ee.positions.length,!0;const te=this._getBatchableMesh(X),re=X.view.texture;if(te.texture._source!==re._source&&te.texture._source!==re._source)return te.batcher.checkAndUpdateTexture(te,re)}return!1}addRenderable(X,K){const J=this.renderer.renderPipes.batch,{batched:Q}=this._getRenderableData(X);if(Q){const ee=this._getBatchableMesh(X);ee.texture=X.view._texture,J.addToBatch(ee)}else J.break(K),K.add({renderPipeId:"mesh",renderable:X})}updateRenderable(X){if(X.view.batched){const K=this._gpuBatchableMeshHash[X.uid];K.texture=X.view._texture,K.batcher.updateElement(K)}}destroyRenderable(X){this._renderableHash[X.uid]=null;const K=this._gpuBatchableMeshHash[X.uid];BigPool.return(K),this._gpuBatchableMeshHash[X.uid]=null}execute({renderable:X}){if(!X.isRenderable)return;const K=X.view;K.state.blendMode=X.layerBlendMode;const J=this.localUniforms;J.uniforms.uTransformMatrix=X.layerTransform,J.uniforms.uRound=this.renderer._roundPixels|X.view.roundPixels,J.update(),color32BitToUniform(X.layerColor,J.uniforms.uColor,0),this._adaptor.execute(this,X)}_getRenderableData(X){return this._renderableHash[X.uid]||this._initRenderableData(X)}_initRenderableData(X){const K=X.view;return this._renderableHash[X.uid]={batched:K.batched,indexSize:K._geometry.indices.length,vertexSize:K._geometry.positions.length},X.on("destroyed",()=>{this.destroyRenderable(X)}),this._renderableHash[X.uid]}_getBatchableMesh(X){return this._gpuBatchableMeshHash[X.uid]||this._initBatchableMesh(X)}_initBatchableMesh(X){const K=BigPool.get(BatchableMesh);return K.renderable=X,K.texture=X.view._texture,K.roundPixels=this.renderer._roundPixels|X.view.roundPixels,this._gpuBatchableMeshHash[X.uid]=K,K.renderable=X,K}destroy(){for(const X in this._gpuBatchableMeshHash)this._gpuBatchableMeshHash[X]&&BigPool.return(this._gpuBatchableMeshHash[X]);this._gpuBatchableMeshHash=null,this._renderableHash=null,this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}MeshPipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"mesh"};class BatchableSprite{constructor(){this.vertexSize=4,this.indexSize=6,this.location=0,this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.layerBlendMode}packAttributes(X,K,J,Q){const ee=this.renderable,te=this.texture,re=ee.layerTransform,ie=re.a,ne=re.b,se=re.c,oe=re.d,ae=re.tx,le=re.ty,ce=this.bounds,de=ce[1],he=ce[0],pe=ce[3],fe=ce[2],ge=te._layout.uvs,me=ee.layerColor,ye=Q<<16|this.roundPixels&65535;X[J+0]=ie*he+se*fe+ae,X[J+1]=oe*fe+ne*he+le,X[J+2]=ge.x0,X[J+3]=ge.y0,K[J+4]=me,K[J+5]=ye,X[J+6]=ie*de+se*fe+ae,X[J+7]=oe*fe+ne*de+le,X[J+8]=ge.x1,X[J+9]=ge.y1,K[J+10]=me,K[J+11]=ye,X[J+12]=ie*de+se*pe+ae,X[J+13]=oe*pe+ne*de+le,X[J+14]=ge.x2,X[J+15]=ge.y2,K[J+16]=me,K[J+17]=ye,X[J+18]=ie*he+se*pe+ae,X[J+19]=oe*pe+ne*he+le,X[J+20]=ge.x3,X[J+21]=ge.y3,K[J+22]=me,K[J+23]=ye}packIndex(X,K,J){X[K]=J+0,X[K+1]=J+1,X[K+2]=J+2,X[K+3]=J+0,X[K+4]=J+2,X[K+5]=J+3}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null,this.bounds=null}}let i$5;class SpritePipe{constructor(X){this._gpuSpriteHash=Object.create(null),this._renderer=X,i$5=this._gpuSpriteHash}addRenderable(X,K){const J=this._getGpuSprite(X);X.view._didUpdate&&this._updateBatchableSprite(X,J),this._renderer.renderPipes.batch.addToBatch(J)}updateRenderable(X){const K=i$5[X.uid];X.view._didUpdate&&this._updateBatchableSprite(X,K),K.batcher.updateElement(K)}validateRenderable(X){const K=X.view._texture,J=this._getGpuSprite(X);return J.texture._source!==K._source?!J.batcher.checkAndUpdateTexture(J,K):!1}destroyRenderable(X){const K=i$5[X.uid];BigPool.return(K),i$5[X.uid]=null}_updateBatchableSprite(X,K){const J=X.view;J._didUpdate=!1,K.bounds=J.bounds,K.texture=J._texture}_getGpuSprite(X){return i$5[X.uid]||this._initGPUSprite(X)}_initGPUSprite(X){const K=BigPool.get(BatchableSprite);K.renderable=X;const J=X.view;return K.texture=J._texture,K.bounds=J.bounds,K.roundPixels=this._renderer._roundPixels|J.roundPixels,i$5[X.uid]=K,X.view._didUpdate=!1,X.on("destroyed",()=>{this.destroyRenderable(X)}),K}destroy(){for(const X in this._gpuSpriteHash)BigPool.return(this._gpuSpriteHash[X]);this._gpuSpriteHash=null,this._renderer=null}}SpritePipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"sprite"};class ProxyRenderable extends eventemitter3{constructor({original:X,view:K}){super(),this.uid=uid("renderable"),this.didViewUpdate=!1,this.view=K,X&&this.init(X)}init(X){this._original=X,this.layerTransform=X.layerTransform}get layerColor(){return this._original.layerColor}get layerBlendMode(){return this._original.layerBlendMode}get layerVisibleRenderable(){return this._original.layerVisibleRenderable}get isRenderable(){return this._original.isRenderable}}const u$b=new Polygon;class MeshView{constructor(X){this.uid=uid("meshView"),this.renderPipeId="mesh",this.canBundle=!0,this.owner=emptyViewObserver,this.state=State.for2d(),this.roundPixels=0;var K,J,Q;this.shader=X.shader,this.texture=(Q=(J=X.texture)!=null?J:(K=this.shader)==null?void 0:K.texture)!=null?Q:Texture.WHITE,this._geometry=X.geometry,this._geometry.on("update",this.onUpdate,this)}set shader(X){this._shader!==X&&(this._shader=X,this.onUpdate())}get shader(){return this._shader}set geometry(X){var K;this._geometry!==X&&((K=this._geometry)==null||K.off("update",this.onUpdate,this),X.on("update",this.onUpdate,this),this._geometry=X,this.onUpdate())}get geometry(){return this._geometry}set texture(X){this._texture!==X&&(this.shader&&(this.shader.texture=X),this._texture=X,this.onUpdate())}get texture(){return this._texture}get batched(){return this._shader?!1:this._geometry.batchMode==="auto"?this._geometry.positions.length/2<=100:this._geometry.batchMode==="batch"}addBounds(X){X.addVertexData(this.geometry.positions,0,this.geometry.positions.length)}containsPoint(X){const{x:K,y:J}=X,Q=this.geometry.getBuffer("aPosition").data,ee=u$b.points,te=this.geometry.getIndex().data,re=te.length,ie=this.geometry.topology==="triangle-strip"?3:1;for(let ne=0;ne+2<re;ne+=ie){const se=te[ne]*2,oe=te[ne+1]*2,ae=te[ne+2]*2;if(ee[0]=Q[se],ee[1]=Q[se+1],ee[2]=Q[oe],ee[3]=Q[oe+1],ee[4]=Q[ae],ee[5]=Q[ae+1],u$b.contains(K,J))return!0}return!1}onUpdate(){this.owner.onViewUpdate()}destroy(X=!1){var K;if(typeof X=="boolean"?X:X!=null&&X.texture){const J=typeof X=="boolean"?X:X==null?void 0:X.textureSource;this._texture.destroy(J)}(K=this._geometry)==null||K.off("update",this.onUpdate,this),this._texture=null,this._geometry=null,this._shader=null}}var h$c=Object.defineProperty,u$a=Object.getOwnPropertySymbols,b$7=Object.prototype.hasOwnProperty,g$6=Object.prototype.propertyIsEnumerable,p$d=(Z,X,K)=>X in Z?h$c(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,a$8=(Z,X)=>{for(var K in X||(X={}))b$7.call(X,K)&&p$d(Z,K,X[K]);if(u$a)for(var K of u$a(X))g$6.call(X,K)&&p$d(Z,K,X[K]);return Z};const n$a=class extends Geometry{constructor(...Z){var X;let K=(X=Z[0])!=null?X:{};K instanceof Float32Array&&(deprecation(v8_0_0,"use new MeshGeometry({ positions, uvs, indices }) instead"),K={positions:K,uvs:Z[1],indices:Z[2]}),K=a$8(a$8({},n$a.defaultOptions),K);const J=K.positions||new Float32Array([0,0,1,0,1,1,0,1]),Q=K.uvs||new Float32Array([0,0,1,0,1,1,0,1]),ee=K.indices||new Uint32Array([0,1,2,0,2,3]),te=new Buffer({data:J,label:"attribute-mesh-positions",usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),re=new Buffer({data:Q,label:"attribute-mesh-uvs",usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),ie=new Buffer({data:ee,label:"index-mesh-buffer",usage:BufferUsage.INDEX|BufferUsage.COPY_DST});super({attributes:{aPosition:{buffer:te,shaderLocation:0,format:"float32x2",stride:2*4,offset:0},aUV:{buffer:re,shaderLocation:1,format:"float32x2",stride:2*4,offset:0}},indexBuffer:ie,topology:K.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(Z){this.attributes.aPosition.buffer.data=Z}get uvs(){return this.attributes.aUV.buffer.data}set uvs(Z){this.attributes.aUV.buffer.data=Z}get indices(){return this.indexBuffer.data}set indices(Z){this.indexBuffer.data=Z}};let MeshGeometry=n$a;MeshGeometry.defaultOptions={topology:"triangle-list"};class QuadGeometry extends MeshGeometry{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}const tilingBit={name:"tiling-bit",vertex:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`
            vUV = (tilingUniforms.uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `},fragment:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `}},tilingBitGl={name:"tiling-bit",vertex:{header:`
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,main:`
            vUV = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `},fragment:{header:`
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,main:`

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0
    
        `}};class TilingSpriteShader extends Shader{constructor(X){const K=compileHighShaderGpuProgram({name:"tiling-sprite-shader",bits:[localUniformBit,tilingBit,roundPixelsBit]}),J=compileHighShaderGlProgram({name:"tiling-sprite-shader",bits:[localUniformBitGl,tilingBitGl,roundPixelsBitGl]}),Q=new UniformGroup({uMapCoord:{value:new Matrix,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new Matrix,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,200,.5,.5]),type:"vec4<f32>"}});super({glProgram:J,gpuProgram:K,resources:{tilingUniforms:Q,uTexture:X.texture.source,uSampler:X.texture.source.style}})}get texture(){return this._texture}set texture(X){this._texture!==X&&(this._texture=X,this.resources.uTexture=X.source,this.resources.uSampler=X.source.style)}}const T$4=new QuadGeometry;class TilingSpritePipe{constructor(X){this._renderableHash=Object.create(null),this._renderer=X}validateRenderable(X){const K=X.view.texture.textureMatrix;let J=!1;const Q=this._getRenderableData(X);return Q.batched!==K.isSimple&&(Q.batched=K.isSimple,J=!0),J}addRenderable(X,K){X.view._didUpdate&&(X.view._didUpdate=!1,this._rebuild(X));const{batched:J}=this._getRenderableData(X);if(J){const Q=this._getBatchedTilingSprite(X);this._renderer.renderPipes.mesh.addRenderable(Q,K)}else{const Q=this._getGpuTilingSprite(X);this._renderer.renderPipes.mesh.addRenderable(Q.meshRenderable,K)}}updateRenderable(X){X.view._didUpdate&&(X.view._didUpdate=!1,this._rebuild(X));const{batched:K}=this._getRenderableData(X);if(K){const J=this._getBatchedTilingSprite(X);this._renderer.renderPipes.mesh.updateRenderable(J)}else{const J=this._getGpuTilingSprite(X);this._renderer.renderPipes.mesh.updateRenderable(J.meshRenderable)}}destroyRenderable(X){var K,J;const Q=this._renderableHash[X.uid];(K=Q.batchedMesh)==null||K.view.destroy(),(J=Q.gpuTilingSprite)==null||J.meshRenderable.view.destroy(),this._renderableHash[X.uid]=null,X.off("destroyed",this.destroyRenderable,this)}_getRenderableData(X){return this._renderableHash[X.uid]||this._initRenderableData(X)}_initRenderableData(X){const K={batched:!0,renderable:X};return this._renderableHash[X.uid]=K,this.validateRenderable(X),X.on("destroyed",()=>{this.destroyRenderable(X)}),K}_rebuild(X){const K=this._getRenderableData(X),J=X.view,Q=J.texture.textureMatrix;if(K.batched){const ee=this._getBatchedTilingSprite(X);ee.view.texture=J.texture;const te=J.texture.source.style;te.addressMode!=="repeat"&&(te.addressMode="repeat",te.update()),this._updateBatchPositions(X),this._updateBatchUvs(X)}else{const ee=this._getGpuTilingSprite(X),{meshRenderable:te}=ee,re=te.view;re.shader.texture=J.texture;const ie=re.shader.resources.tilingUniforms,ne=J.width,se=J.height,oe=J.texture.width,ae=J.texture.height,le=J._tileTransform.matrix,ce=ie.uniforms.uTextureTransform;ce.set(le.a*oe/ne,le.b*oe/se,le.c*ae/ne,le.d*ae/se,le.tx/ne,le.ty/se),ce.invert(),ie.uniforms.uMapCoord=Q.mapCoord,ie.uniforms.uClampFrame=Q.uClampFrame,ie.uniforms.uClampOffset=Q.uClampOffset,ie.uniforms.uTextureTransform=ce,ie.uniforms.uSizeAnchor[0]=ne,ie.uniforms.uSizeAnchor[1]=se,ie.uniforms.uSizeAnchor[2]=X.view.anchor.x,ie.uniforms.uSizeAnchor[3]=X.view.anchor.y,ie.update()}}_getGpuTilingSprite(X){return this._renderableHash[X.uid].gpuTilingSprite||this._initGpuTilingSprite(X)}_initGpuTilingSprite(X){const K=X.view,J=K.texture.source.style;J.addressMode="repeat",J.update();const Q=new MeshView({geometry:T$4,shader:new TilingSpriteShader({texture:K.texture})}),ee=new ProxyRenderable({original:X,view:Q}),te=new Matrix,re={meshRenderable:ee,textureMatrix:te};return this._renderableHash[X.uid].gpuTilingSprite=re,re}_getBatchedTilingSprite(X){return this._renderableHash[X.uid].batchedMesh||this._initBatchedTilingSprite(X)}_initBatchedTilingSprite(X){const K=new MeshView({geometry:new QuadGeometry,texture:X.view.texture});K.roundPixels=this._renderer._roundPixels|X.view.roundPixels;const J=new ProxyRenderable({original:X,view:K});return this._renderableHash[X.uid].batchedMesh=J,J}_updateBatchPositions(X){const K=this._getBatchedTilingSprite(X),J=X.view,Q=K.view.geometry.getBuffer("aPosition").data,ee=J.anchor.x,te=J.anchor.y;Q[0]=-ee*J.width,Q[1]=-te*J.height,Q[2]=(1-ee)*J.width,Q[3]=-te*J.height,Q[4]=(1-ee)*J.width,Q[5]=(1-te)*J.height,Q[6]=-ee*J.width,Q[7]=(1-te)*J.height}_updateBatchUvs(X){const K=X.view,J=K.texture.frameWidth,Q=K.texture.frameHeight,ee=this._getBatchedTilingSprite(X).view.geometry.getBuffer("aUV").data;let te=0,re=0;K._applyAnchorToTexture&&(te=K.anchor.x,re=K.anchor.y),ee[0]=ee[6]=-te,ee[2]=ee[4]=1-te,ee[1]=ee[3]=-re,ee[5]=ee[7]=1-re;const ie=Matrix.shared;ie.copyFrom(K._tileTransform.matrix),ie.tx/=K.width,ie.ty/=K.height,ie.invert(),ie.scale(K.width/J,K.height/Q),S$2(ee,2,0,ie)}destroy(){for(const X in this._renderableHash)this.destroyRenderable(this._renderableHash[X].renderable);this._renderableHash=null,this._renderer=null}}TilingSpritePipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"tilingSprite"};function S$2(Z,X,K,J){let Q=0;const ee=Z.length/(X||2),te=J.a,re=J.b,ie=J.c,ne=J.d,se=J.tx,oe=J.ty;for(K*=X;Q<ee;){const ae=Z[K],le=Z[K+1];Z[K]=te*ae+ie*le+se,Z[K+1]=re*ae+ne*le+oe,K+=X,Q++}}class GraphicsView{constructor(X){this.uid=uid("graphicsView"),this.canBundle=!0,this.owner=emptyViewObserver,this.renderPipeId="graphics",this.roundPixels=0,X?this._context=X:this._context=this._ownedContext=new GraphicsContext,this._context.on("update",this.onGraphicsContextUpdate,this)}set context(X){X!==this._context&&(this._context.off("update",this.onGraphicsContextUpdate,this),this._context=X,this._context.on("update",this.onGraphicsContextUpdate,this),this.onGraphicsContextUpdate())}get context(){return this._context}addBounds(X){X.addBounds(this._context.bounds)}containsPoint(X){return this._context.containsPoint(X)}onGraphicsContextUpdate(){this._didUpdate=!0,this.owner.onViewUpdate()}destroy(X){this.owner=null,this._ownedContext&&X===!1?this._ownedContext.destroy(X):(X===!0||(X==null?void 0:X.context)===!0)&&this._context.destroy(X),this._ownedContext=null,this._context=null}}const localUniformMSDFBit={name:"local-uniform-msdf-bit",vertex:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `},fragment:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,main:` 
            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);
        `}},localUniformMSDFBitGl={name:"local-uniform-msdf-bit",vertex:{header:`
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `},fragment:{header:`
            uniform float uDistance;
         `,main:` 
            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);
        `}},mSDFBit={name:"msdf-bit",fragment:{header:`
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `}},mSDFBitGl={name:"msdf-bit",fragment:{header:`
            float calculateMSDFAlpha(vec4 msdfColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `}};class SdfShader extends Shader{constructor(){const X=new UniformGroup({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}}),K=compileHighShaderGpuProgram({name:"sdf-shader",bits:[colorBit,generateTextureBatchBit(MAX_TEXTURES),localUniformMSDFBit,mSDFBit,roundPixelsBit]}),J=compileHighShaderGlProgram({name:"sdf-shader",bits:[colorBitGl,generateTextureBatchBitGl(MAX_TEXTURES),localUniformMSDFBitGl,mSDFBitGl,roundPixelsBitGl]});super({glProgram:J,gpuProgram:K,resources:{localUniforms:X,batchSamplers:batchSamplersUniformGroup}})}}const i$4=["_fontFamily","_fontStyle","_fontVariant","_fontWeight","_breakWords","_align","_leading","_letterSpacing","_lineHeight","_textBaseline","_whiteSpace","_wordWrap","_wordWrapWidth","_padding","_cssOverrides"];function generateTextStyleKey(Z){const X=[];let K=0;for(let J=0;J<i$4.length;J++){const Q=i$4[J];X[K++]=Z[Q]}return K=a$7(Z._fill,X,K),K=l$a(Z._stroke,X,K),X.join("-")}function a$7(Z,X,K){var J;return Z&&(X[K++]=Z.color,X[K++]=Z.alpha,X[K++]=(J=Z.fill)==null?void 0:J.uid),K}function l$a(Z,X,K){return Z&&(K=a$7(Z,X,K),X[K++]=Z.width,X[K++]=Z.alignment,X[K++]=Z.cap,X[K++]=Z.join,X[K++]=Z.miterLimit),K}var c$7=Object.defineProperty,y$4=Object.getOwnPropertySymbols,m$9=Object.prototype.hasOwnProperty,_$1=Object.prototype.propertyIsEnumerable,g$5=(Z,X,K)=>X in Z?c$7(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,h$b=(Z,X)=>{for(var K in X||(X={}))m$9.call(X,K)&&g$5(Z,K,X[K]);if(y$4)for(var K of y$4(X))_$1.call(X,K)&&g$5(Z,K,X[K]);return Z};const n$9=class extends eventemitter3{constructor(Z={}){super(),W$2(Z);const X=h$b(h$b({},n$9.defaultTextStyle),Z);for(const K in n$9.defaultTextStyle){const J=K;this[J]=X[K]}this.dropShadow=null,typeof X.fill=="string"?this.fontSize=parseInt(X.fontSize,10):this.fontSize=X.fontSize,Z.dropShadow&&(Z.dropShadow instanceof Boolean?Z.dropShadow===!0&&(this.dropShadow=h$b({},n$9.defaultTextStyle.dropShadow)):this.dropShadow=h$b(h$b({},n$9.defaultTextStyle.dropShadow),Z.dropShadow)),this.update()}get align(){return this._align}set align(Z){this._align=Z,this.update()}get breakWords(){return this._breakWords}set breakWords(Z){this._breakWords=Z,this.update()}get dropShadow(){return this._dropShadow}set dropShadow(Z){this._dropShadow=Z,this.update()}get fontFamily(){return this._fontFamily}set fontFamily(Z){this._fontFamily=Z,this.update()}get fontSize(){return this._fontSize}set fontSize(Z){this._fontSize=Z,this.update()}get fontStyle(){return this._fontStyle}set fontStyle(Z){this._fontStyle=Z,this.update()}get fontVariant(){return this._fontVariant}set fontVariant(Z){this._fontVariant=Z,this.update()}get fontWeight(){return this._fontWeight}set fontWeight(Z){this._fontWeight=Z,this.update()}get leading(){return this._leading}set leading(Z){this._leading=Z,this.update()}get letterSpacing(){return this._letterSpacing}set letterSpacing(Z){this._letterSpacing=Z,this.update()}get lineHeight(){return this._lineHeight}set lineHeight(Z){this._lineHeight=Z,this.update()}get padding(){return this._padding}set padding(Z){this._padding=Z,this.update()}get textBaseline(){return this._textBaseline}set textBaseline(Z){this._textBaseline=Z,this.update()}get whiteSpace(){return this._whiteSpace}set whiteSpace(Z){this._whiteSpace=Z,this.update()}get wordWrap(){return this._wordWrap}set wordWrap(Z){this._wordWrap=Z,this.update()}get wordWrapWidth(){return this._wordWrapWidth}set wordWrapWidth(Z){this._wordWrapWidth=Z,this.update()}get fill(){return this._originalFill}set fill(Z){Z!==this._originalFill&&(this._originalFill=Z,this._fill=convertFillInputToFillStyle(Z,GraphicsContext.defaultFillStyle),this.update())}get stroke(){return this._originalStroke}set stroke(Z){Z!==this._originalFill&&(this._originalFill=Z,this._stroke=convertFillInputToFillStyle(Z,GraphicsContext.defaultStrokeStyle),this.update())}_generateKey(){return this._styleKey=generateTextStyleKey(this),this._styleKey}update(){this._styleKey=null,this.emit("update",this)}get styleKey(){return this._styleKey||this._generateKey()}clone(){return new n$9({align:this.align,breakWords:this.breakWords,dropShadow:this.dropShadow,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,leading:this.leading,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,textBaseline:this.textBaseline,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth})}destroy(Z=!1){var X,K,J,Q;if(this.removeAllListeners(),typeof Z=="boolean"?Z:Z==null?void 0:Z.texture){const ee=typeof Z=="boolean"?Z:Z==null?void 0:Z.textureSource;(X=this._fill)!=null&&X.texture&&this._fill.texture.destroy(ee),(K=this._originalFill)!=null&&K.texture&&this._originalFill.texture.destroy(ee),(J=this._stroke)!=null&&J.texture&&this._stroke.texture.destroy(ee),(Q=this._originalStroke)!=null&&Q.texture&&this._originalStroke.texture.destroy(ee)}this._fill=null,this._stroke=null,this.dropShadow=null,this._originalStroke=null,this._originalFill=null}};let TextStyle=n$9;TextStyle.defaultTextStyle={align:"left",breakWords:!1,dropShadow:{alpha:1,angle:Math.PI/6,blur:0,color:"black",distance:5},fill:"black",fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",leading:0,letterSpacing:0,lineHeight:0,padding:0,stroke:null,textBaseline:"alphabetic",trim:!1,whiteSpace:"pre",wordWrap:!1,wordWrapWidth:100};function W$2(Z){var X,K;const J=Z;if(typeof J.dropShadow=="boolean"&&(deprecation(v8_0_0,"dropShadow is now an object, not a boolean"),Z.dropShadow={alpha:(X=J.dropShadowAlpha)!=null?X:1,angle:J.dropShadowAngle,blur:(K=J.dropShadowBlur)!=null?K:0,color:J.dropShadowColor,distance:J.dropShadowDistance}),J.strokeThickness){deprecation(v8_0_0,"strokeThickness is now a part of stroke");const Q=J.stroke;Z.stroke={color:Q,width:J.strokeThickness}}if(Array.isArray(J.fill)){deprecation(v8_0_0,"gradient fill is now a fill pattern: `new FillGradient(...)`");const Q=new FillGradient(0,0,0,Z.fontSize*1.7),ee=J.fill.map(te=>Color.shared.setValue(te).toNumber());ee.forEach((te,re)=>{var ie;const ne=(ie=J.fillGradientStops[re])!=null?ie:re/ee.length;Q.addColorStop(ne,te)}),Z.fill={fill:Q}}}class CanvasPoolClass{constructor(X){this._canvasPool=Object.create(null),this.canvasOptions=X||{},this.enableFullScreen=!1}_createCanvasAndContext(X,K){const J=DOMAdapter.get().createCanvas();J.width=X,J.height=K;const Q=J.getContext("2d");return{canvas:J,context:Q}}getOptimalCanvasAndContext(X,K,J=1){X=Math.ceil(X*J-1e-6),K=Math.ceil(K*J-1e-6),X=nextPow2(X),K=nextPow2(K);const Q=(X<<17)+(K<<1);this._canvasPool[Q]||(this._canvasPool[Q]=[]);let ee=this._canvasPool[Q].pop();return ee||(ee=this._createCanvasAndContext(X,K)),ee}returnCanvasAndContext(X){const{width:K,height:J}=X.canvas,Q=(K<<17)+(J<<1);this._canvasPool[Q].push(X)}clear(){this._canvasPool={}}}const CanvasPool=new CanvasPoolClass,r$3=["serif","sans-serif","monospace","cursive","fantasy","system-ui"];function fontStringFromTextStyle(Z){const X=typeof Z.fontSize=="number"?`${Z.fontSize}px`:Z.fontSize;let K=Z.fontFamily;Array.isArray(Z.fontFamily)||(K=Z.fontFamily.split(","));for(let J=K.length-1;J>=0;J--){let Q=K[J].trim();!/([\"\'])[^\'\"]+\1/.test(Q)&&!r$3.includes(Q)&&(Q=`"${Q}"`),K[J]=Q}return`${Z.fontStyle} ${Z.fontVariant} ${Z.fontWeight} ${X} ${K.join(",")}`}const k={willReadFrequently:!0},n$8=class{static get experimentalLetterSpacingSupported(){let Z=n$8._experimentalLetterSpacingSupported;if(Z!==void 0){const X=DOMAdapter.get().getCanvasRenderingContext2D().prototype;Z=n$8._experimentalLetterSpacingSupported="letterSpacing"in X||"textLetterSpacing"in X}return Z}constructor(Z,X,K,J,Q,ee,te,re,ie){this.text=Z,this.style=X,this.width=K,this.height=J,this.lines=Q,this.lineWidths=ee,this.lineHeight=te,this.maxLineWidth=re,this.fontProperties=ie}static measureText(Z=" ",X,K=n$8._canvas,J=X.wordWrap){var Q;const ee=`${Z}:${X.styleKey}`;if(n$8._measurementCache[ee])return n$8._measurementCache[ee];const te=fontStringFromTextStyle(X),re=n$8.measureFont(te);re.fontSize===0&&(re.fontSize=X.fontSize,re.ascent=X.fontSize);const ie=n$8.__context;ie.font=te;const ne=(J?n$8._wordWrap(Z,X,K):Z).split(/(?:\r\n|\r|\n)/),se=new Array(ne.length);let oe=0;for(let he=0;he<ne.length;he++){const pe=n$8._measureText(ne[he],X.letterSpacing,ie);se[he]=pe,oe=Math.max(oe,pe)}const ae=((Q=X._stroke)==null?void 0:Q.width)||0;let le=oe+ae;X.dropShadow&&(le+=X.dropShadow.distance);const ce=X.lineHeight||re.fontSize+ae;let de=Math.max(ce,re.fontSize+ae*2)+(ne.length-1)*(ce+X.leading);return X.dropShadow&&(de+=X.dropShadow.distance),new n$8(Z,X,le,de,ne,se,ce+X.leading,oe,re)}static _measureText(Z,X,K){let J=!1;n$8.experimentalLetterSpacingSupported&&(n$8.experimentalLetterSpacing?(K.letterSpacing=`${X}px`,K.textLetterSpacing=`${X}px`,J=!0):(K.letterSpacing="0px",K.textLetterSpacing="0px"));let Q=K.measureText(Z).width;return Q>0&&(J?Q-=X:Q+=(n$8.graphemeSegmenter(Z).length-1)*X),Q}static _wordWrap(Z,X,K=n$8._canvas){const J=K.getContext("2d",k);let Q=0,ee="",te="";const re=Object.create(null),{letterSpacing:ie,whiteSpace:ne}=X,se=n$8._collapseSpaces(ne),oe=n$8._collapseNewlines(ne);let ae=!se;const le=X.wordWrapWidth+ie,ce=n$8._tokenize(Z);for(let de=0;de<ce.length;de++){let he=ce[de];if(n$8._isNewline(he)){if(!oe){te+=n$8._addLine(ee),ae=!se,ee="",Q=0;continue}he=" "}if(se){const fe=n$8.isBreakingSpace(he),ge=n$8.isBreakingSpace(ee[ee.length-1]);if(fe&&ge)continue}const pe=n$8._getFromCache(he,ie,re,J);if(pe>le)if(ee!==""&&(te+=n$8._addLine(ee),ee="",Q=0),n$8.canBreakWords(he,X.breakWords)){const fe=n$8.wordWrapSplit(he);for(let ge=0;ge<fe.length;ge++){let me=fe[ge],ye=me,_e=1;for(;fe[ge+_e];){const xe=fe[ge+_e];if(!n$8.canBreakChars(ye,xe,he,ge,X.breakWords))me+=xe;else break;ye=xe,_e++}ge+=_e-1;const Ce=n$8._getFromCache(me,ie,re,J);Ce+Q>le&&(te+=n$8._addLine(ee),ae=!1,ee="",Q=0),ee+=me,Q+=Ce}}else{ee.length>0&&(te+=n$8._addLine(ee),ee="",Q=0);const fe=de===ce.length-1;te+=n$8._addLine(he,!fe),ae=!1,ee="",Q=0}else pe+Q>le&&(ae=!1,te+=n$8._addLine(ee),ee="",Q=0),(ee.length>0||!n$8.isBreakingSpace(he)||ae)&&(ee+=he,Q+=pe)}return te+=n$8._addLine(ee,!1),te}static _addLine(Z,X=!0){return Z=n$8._trimRight(Z),Z=X?`${Z}
`:Z,Z}static _getFromCache(Z,X,K,J){let Q=K[Z];return typeof Q!="number"&&(Q=n$8._measureText(Z,X,J)+X,K[Z]=Q),Q}static _collapseSpaces(Z){return Z==="normal"||Z==="pre-line"}static _collapseNewlines(Z){return Z==="normal"}static _trimRight(Z){if(typeof Z!="string")return"";for(let X=Z.length-1;X>=0;X--){const K=Z[X];if(!n$8.isBreakingSpace(K))break;Z=Z.slice(0,-1)}return Z}static _isNewline(Z){return typeof Z!="string"?!1:n$8._newlines.includes(Z.charCodeAt(0))}static isBreakingSpace(Z,X){return typeof Z!="string"?!1:n$8._breakingSpaces.includes(Z.charCodeAt(0))}static _tokenize(Z){const X=[];let K="";if(typeof Z!="string")return X;for(let J=0;J<Z.length;J++){const Q=Z[J],ee=Z[J+1];if(n$8.isBreakingSpace(Q,ee)||n$8._isNewline(Q)){K!==""&&(X.push(K),K=""),X.push(Q);continue}K+=Q}return K!==""&&X.push(K),X}static canBreakWords(Z,X){return X}static canBreakChars(Z,X,K,J,Q){return!0}static wordWrapSplit(Z){return n$8.graphemeSegmenter(Z)}static measureFont(Z){if(n$8._fonts[Z])return n$8._fonts[Z];const X=n$8._context;X.font=Z;const K=X.measureText(n$8.METRICS_STRING+n$8.BASELINE_SYMBOL),J={ascent:K.actualBoundingBoxAscent,descent:K.actualBoundingBoxDescent,fontSize:K.actualBoundingBoxAscent+K.actualBoundingBoxDescent};return n$8._fonts[Z]=J,J}static clearMetrics(Z=""){Z?delete n$8._fonts[Z]:n$8._fonts={}}static get _canvas(){if(!n$8.__canvas){let Z;try{const X=new OffscreenCanvas(0,0),K=X.getContext("2d",k);if(K!=null&&K.measureText)return n$8.__canvas=X,X;Z=DOMAdapter.get().createCanvas()}catch(X){Z=DOMAdapter.get().createCanvas()}Z.width=Z.height=10,n$8.__canvas=Z}return n$8.__canvas}static get _context(){return n$8.__context||(n$8.__context=n$8._canvas.getContext("2d",k)),n$8.__context}};let CanvasTextMetrics=n$8;CanvasTextMetrics.METRICS_STRING="|\xC9q\xC5",CanvasTextMetrics.BASELINE_SYMBOL="M",CanvasTextMetrics.BASELINE_MULTIPLIER=1.4,CanvasTextMetrics.HEIGHT_MULTIPLIER=2,CanvasTextMetrics.graphemeSegmenter=(()=>{if(typeof(Intl==null?void 0:Intl.Segmenter)=="function"){const Z=new Intl.Segmenter;return X=>[...Z.segment(X)].map(K=>K.segment)}return Z=>[...Z]})(),CanvasTextMetrics.experimentalLetterSpacing=!1,CanvasTextMetrics._fonts={},CanvasTextMetrics._newlines=[10,13],CanvasTextMetrics._breakingSpaces=[9,32,8192,8193,8194,8195,8196,8197,8198,8200,8201,8202,8287,12288],CanvasTextMetrics._measurementCache={};function getCanvasFillStyle(Z,X){if(Z.texture===Texture.WHITE&&!Z.fill)return Color.shared.setValue(Z.color).toHex();if(Z.fill){if(Z.fill instanceof FillPattern){const K=Z.fill,J=X.createPattern(K.texture.source.resource,"repeat"),Q=K.transform.copyTo(Matrix.shared);return Q.scale(K.texture.frameWidth,K.texture.frameHeight),J.setTransform(Q),J}else if(Z.fill instanceof FillGradient){const K=Z.fill;if(K.type==="linear"){const J=X.createLinearGradient(K.x0,K.y0,K.x1,K.y1);return K.gradientStops.forEach(Q=>{J.addColorStop(Q.offset,Color.shared.setValue(Q.color).toHex())}),J}}}else{const K=X.createPattern(Z.texture.source.resource,"repeat"),J=Z.matrix.copyTo(Matrix.shared);return J.scale(Z.texture.frameWidth,Z.texture.frameHeight),K.setTransform(J),K}return"red"}function resolveCharacters(Z){if(Z==="")return[];typeof Z=="string"&&(Z=[Z]);const X=[];for(let K=0,J=Z.length;K<J;K++){const Q=Z[K];if(Array.isArray(Q)){if(Q.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${Q.length}.`);if(Q[0].length===0||Q[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const ee=Q[0].charCodeAt(0),te=Q[1].charCodeAt(0);if(te<ee)throw new Error("[BitmapFont]: Invalid character range.");for(let re=ee,ie=te;re<=ie;re++)X.push(String.fromCharCode(re))}else X.push(...Array.from(Q))}if(X.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return X}class DynamicBitmapFont extends AbstractBitmapFont{constructor(X){var K,J,Q;super(),this.resolution=1,this.pages=[],this._padding=4,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentPageIndex=-1,this._skipKerning=!1;const ee=X,te=ee.style.clone();te.fontSize=this.baseMeasurementFontSize,ee.overrideFill&&(te._fill.color=16777215,te._fill.alpha=1,te._fill.texture=Texture.WHITE,te._fill.fill=null),this._style=te,this._skipKerning=(K=ee.skipKerning)!=null?K:!1,this.resolution=(J=ee.resolution)!=null?J:1,this._padding=(Q=ee.padding)!=null?Q:4;const re=fontStringFromTextStyle(te);this.fontMetrics=CanvasTextMetrics.measureFont(re),this.lineHeight=te.lineHeight||this.fontMetrics.fontSize||te.fontSize}ensureCharacters(X){var K,J,Q,ee;const te=resolveCharacters(X).filter(ge=>!this._currentChars.includes(ge)).filter((ge,me,ye)=>ye.indexOf(ge)===me);if(!te.length)return;this._currentChars=[...this._currentChars,...te];let re;this._currentPageIndex===-1?re=this._nextPage():re=this.pages[this._currentPageIndex];let{canvas:ie,context:ne}=re.canvasAndContext,se=re.texture.source;const oe=this._style;let ae=this._currentX,le=this._currentY;const ce=this.baseRenderedFontSize/this.baseMeasurementFontSize,de=this._padding*ce,he=oe.fontStyle==="italic"?2:1;let pe=0,fe=!1;for(let ge=0;ge<te.length;ge++){const me=te[ge],ye=CanvasTextMetrics.measureText(me,oe,ie,!1),_e=he*ye.width*ce,Ce=ye.height*ce,xe=_e+de*2,be=Ce+de*2;if(fe=!1,me!==`
`&&me!=="\r"&&me!=="	"&&me!==" "&&(fe=!0,pe=Math.ceil(Math.max(be,pe))),ae+xe>512&&(le+=pe,pe=be,ae=0,le+pe>512)){se.update();const Se=this._nextPage();ie=Se.canvasAndContext.canvas,ne=Se.canvasAndContext.context,se=Se.texture.source,le=0}const ve=_e/ce-((J=(K=oe.dropShadow)==null?void 0:K.distance)!=null?J:0)-((ee=(Q=oe._stroke)==null?void 0:Q.width)!=null?ee:0);if(this.chars[me]={id:me.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:ve,kerning:{}},fe){this._drawGlyph(ne,ye,ae+de,le+de,ce,oe);const Se=se.width*ce,Pe=se.height*ce,Te=new Rectangle(ae/Se,le/Pe,xe/Se,be/Pe);this.chars[me].texture=new Texture({source:se,layout:{frame:Te}}),ae+=Math.ceil(xe)}}se.update(),this._currentX=ae,this._currentY=le,this._skipKerning&&this._applyKerning(te,ne)}get pageTextures(){return deprecation(v8_0_0,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(X,K){const J=this._measureCache;for(let Q=0;Q<X.length;Q++){const ee=X[Q];for(let te=0;te<this._currentChars.length;te++){const re=this._currentChars[te];let ie=J[ee];ie||(ie=J[ee]=K.measureText(ee).width);let ne=J[re];ne||(ne=J[re]=K.measureText(re).width);let se=K.measureText(ee+re).width,oe=se-(ie+ne);oe&&(this.chars[ee].kerning[re]=oe),se=K.measureText(ee+re).width,oe=se-(ie+ne),oe&&(this.chars[re].kerning[ee]=oe)}}}_nextPage(){this._currentPageIndex++;const X=this.resolution,K=CanvasPool.getOptimalCanvasAndContext(512,512,X);this._setupContext(K.context,this._style,X);const J=X*(this.baseRenderedFontSize/this.baseMeasurementFontSize),Q=new Texture({source:new ImageSource({resource:K.canvas,resolution:J,alphaMode:"premultiply-alpha-on-upload"})}),ee={canvasAndContext:K,texture:Q};return this.pages[this._currentPageIndex]=ee,ee}_setupContext(X,K,J){var Q;K.fontSize=this.baseRenderedFontSize,X.scale(J,J),X.font=fontStringFromTextStyle(K),K.fontSize=this.baseMeasurementFontSize,X.textBaseline=K.textBaseline;const ee=K._stroke,te=(Q=ee==null?void 0:ee.width)!=null?Q:0;if(ee&&(X.lineWidth=te,X.lineJoin=ee.join,X.miterLimit=ee.miterLimit,X.strokeStyle=getCanvasFillStyle(ee,X)),K._fill&&(X.fillStyle=getCanvasFillStyle(K._fill,X)),K.dropShadow){const re=K.dropShadow,ie=Color.shared.setValue(re.color).toArray(),ne=re.blur*J,se=re.distance*J;X.shadowColor=`rgba(${ie[0]*255},${ie[1]*255},${ie[2]*255},${re.alpha})`,X.shadowBlur=ne,X.shadowOffsetX=Math.cos(re.angle)*se,X.shadowOffsetY=Math.sin(re.angle)*se}else X.shadowColor="black",X.shadowBlur=0,X.shadowOffsetX=0,X.shadowOffsetY=0}_drawGlyph(X,K,J,Q,ee,te){var re;const ie=K.text,ne=K.fontProperties,se=te._stroke,oe=((re=se==null?void 0:se.width)!=null?re:0)*ee,ae=J+oe/2,le=Q-oe/2,ce=ne.descent*ee,de=K.lineHeight*ee;te.stroke&&oe&&X.strokeText(ie,ae,le+de-ce),te._fill&&X.fillText(ie,ae,le+de-ce)}destroy(){super.destroy();for(let X=0;X<this.pages.length;X++){const{canvasAndContext:K,texture:J}=this.pages[X];CanvasPool.returnCanvasAndContext(K),J.destroy(!0)}this.pages=null}}function getBitmapTextLayout(Z,X,K){const J={width:0,height:0,offsetY:0,scale:X.fontSize/K.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};J.offsetY=K.baseLineOffset;let Q=J.lines[0],ee=null,te=!0;const re={spaceWord:!1,width:0,start:0,index:0,positions:[],chars:[]},ie=le=>{const ce=Q.width;for(let de=0;de<re.index;de++){const he=le.positions[de];Q.chars.push(le.chars[de]),Q.charPositions.push(he+ce)}Q.width+=le.width,te=!1,re.width=0,re.index=0,re.chars.length=0},ne=()=>{let le=Q.chars.length-1,ce=Q.chars[le];for(;ce===" ";)Q.width-=K.chars[ce].xAdvance,ce=Q.chars[--le];J.width=Math.max(J.width,Q.width),Q={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},te=!0,J.lines.push(Q),J.height+=K.lineHeight},se=K.baseMeasurementFontSize/X.fontSize,oe=X.letterSpacing*se,ae=X.wordWrapWidth*se;for(let le=0;le<Z.length+1;le++){let ce;const de=le===Z.length;de||(ce=Z[le]);const he=K.chars[ce]||K.chars[" "];if(/(?:\s)/.test(ce)||ce==="\r"||ce===`
`||de){if(!te&&X.wordWrap&&Q.width+re.width-oe>ae?(ne(),ie(re),de||Q.charPositions.push(0)):(re.start=Q.width,ie(re),de||Q.charPositions.push(0)),ce==="\r"||ce===`
`)Q.width!==0&&ne();else if(!de){const pe=he.xAdvance+(he.kerning[ee]||0)+oe;Q.width+=pe,Q.spaceWidth=pe,Q.spacesIndex.push(Q.charPositions.length),Q.chars.push(ce)}}else{const pe=he.kerning[ee]||0,fe=he.xAdvance+pe+oe;re.positions[re.index++]=re.width+pe,re.chars.push(ce),re.width+=fe}ee=ce}return ne(),X.align==="center"?b$6(J):X.align==="right"?m$8(J):X.align==="justify"&&S$1(J),J}function b$6(Z){for(let X=0;X<Z.lines.length;X++){const K=Z.lines[X],J=Z.width/2-K.width/2;for(let Q=0;Q<K.charPositions.length;Q++)K.charPositions[Q]+=J}}function m$8(Z){for(let X=0;X<Z.lines.length;X++){const K=Z.lines[X],J=Z.width-K.width;for(let Q=0;Q<K.charPositions.length;Q++)K.charPositions[Q]+=J}}function S$1(Z){const X=Z.width;for(let K=0;K<Z.lines.length;K++){const J=Z.lines[K];let Q=0,ee=J.spacesIndex[Q++],te=0;const re=J.spacesIndex.length,ie=(X-J.width)/re;for(let ne=0;ne<J.charPositions.length;ne++)ne===ee&&(ee=J.spacesIndex[Q++],te+=ie),J.charPositions[ne]+=te}}var g$4=Object.defineProperty,p$c=Object.getOwnPropertySymbols,y$3=Object.prototype.hasOwnProperty,d$5=Object.prototype.propertyIsEnumerable,m$7=(Z,X,K)=>X in Z?g$4(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$6=(Z,X)=>{for(var K in X||(X={}))y$3.call(X,K)&&m$7(Z,K,X[K]);if(p$c)for(var K of p$c(X))d$5.call(X,K)&&m$7(Z,K,X[K]);return Z};class h$a{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1}}getFont(X,K){var J;let Q=`${K.fontFamily}-bitmap`,ee=!0;K._fill.fill&&(Q+=K._fill.fill.uid,ee=!1),Cache.has(Q)||Cache.set(Q,new DynamicBitmapFont(o$6({style:K,overrideFill:ee},this.defaultOptions)));const te=Cache.get(Q);return(J=te.ensureCharacters)==null||J.call(te,X),te}getLayout(X,K){const J=this.getFont(X,K);return getBitmapTextLayout(X.split(""),K,J)}measureText(X,K){return this.getLayout(X,K)}install(X,K,J){if(!X)throw new Error("[BitmapFontManager] Property `name` is required.");J=o$6(o$6({},this.defaultOptions),J);const Q=K instanceof TextStyle?K:new TextStyle(K),ee=Q._fill.fill!==null&&Q._fill.fill!==void 0,te=new DynamicBitmapFont({style:Q,overrideFill:ee,skipKerning:J.skipKerning,padding:J.padding,resolution:J.resolution}),re=resolveCharacters(J.chars);return te.ensureCharacters(re.join("")),Cache.set(`${X}-bitmap`,te),te}}const BitmapFontManager=new h$a;class P$3 extends ProxyRenderable{constructor(){super({view:new GraphicsView})}}class BitmapTextPipe{constructor(X){this._gpuBitmapText={},this._renderer=X}validateRenderable(X){const K=this._getGpuBitmapText(X);return X.view._didUpdate&&(X.view._didUpdate=!1,this._updateContext(X,K.view.context)),this._renderer.renderPipes.graphics.validateRenderable(K)}addRenderable(X,K){const J=this._getGpuBitmapText(X);X.view._didUpdate&&(X.view._didUpdate=!1,this._updateContext(X,J.view.context)),this._renderer.renderPipes.graphics.addRenderable(J,K),J.view.context.customShader&&this._updateDistanceField(X)}destroyRenderable(X){this._destroyRenderableByUid(X.uid)}_destroyRenderableByUid(X){BigPool.return(this._gpuBitmapText[X]),this._gpuBitmapText[X]=null}updateRenderable(X){const K=this._getGpuBitmapText(X);this._renderer.renderPipes.graphics.updateRenderable(K),K.view.context.customShader&&this._updateDistanceField(X)}_updateContext(X,K){var J;const Q=X.view,ee=BitmapFontManager.getFont(Q.text,Q._style);K.clear(),ee.distanceField.type!=="none"&&(K.customShader||(this._sdfShader||(this._sdfShader=new SdfShader),K.customShader=this._sdfShader));const te=Array.from(Q.text),re=Q._style;let ie=(((J=re._stroke)==null?void 0:J.width)||0)/2;ie+=ee.baseLineOffset;const ne=getBitmapTextLayout(te,re,ee);let se=0;const oe=re.padding,ae=ne.scale;K.translate(-Q.anchor._x*ne.width-oe,-Q.anchor._y*(ne.height+ne.offsetY)-oe).scale(ae,ae);const le=re._fill.color;for(let ce=0;ce<ne.lines.length;ce++){const de=ne.lines[ce];for(let he=0;he<de.charPositions.length;he++){const pe=te[se++],fe=ee.chars[pe];fe!=null&&fe.texture&&K.texture(fe.texture,le,Math.round(de.charPositions[he]+fe.xOffset),Math.round(ie+fe.yOffset))}ie+=ee.lineHeight}}_getGpuBitmapText(X){return this._gpuBitmapText[X.uid]||this._initGpuText(X)}_initGpuText(X){const K=BigPool.get(P$3,X);return this._gpuBitmapText[X.uid]=K,K.view.roundPixels=this._renderer._roundPixels|X.view.roundPixels,this._updateContext(X,K.view.context),X.on("destroyed",()=>{this.destroyRenderable(X)}),this._gpuBitmapText[X.uid]}_updateDistanceField(X){var K;const J=this._getGpuBitmapText(X).view.context,Q=X.view,ee=Q._style.fontFamily,te=Cache.get(`${ee}-bitmap`),{a:re,b:ie,c:ne,d:se}=X.layerTransform,oe=Math.sqrt(re*re+ie*ie),ae=Math.sqrt(ne*ne+se*se),le=(Math.abs(oe)+Math.abs(ae))/2,ce=te.baseRenderedFontSize/Q._style.fontSize,de=(K=Q.resolution)!=null?K:this._renderer.resolution,he=le*te.distanceField.range*(1/ce)*de;J.customShader.resources.localUniforms.uniforms.uDistance=he}destroy(){var X;for(const K in this._gpuBitmapText)this._destroyRenderableByUid(K);this._gpuBitmapText=null,(X=this._sdfShader)==null||X.destroy(!0),this._sdfShader=null,this._renderer=null}}BitmapTextPipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"bitmapText"};class CanvasTextPipe{constructor(X){this._gpuText=Object.create(null),this._renderer=X}validateRenderable(X){var K;const J=this._getGpuText(X),Q=X.view._getKey();if(J.currentKey!==Q){const ee=X.view,te=(K=ee.resolution)!=null?K:this._renderer.resolution,{width:re,height:ie}=this._renderer.canvasText.getTextureSize(ee.text,te,ee._style);return!(this._renderer.canvasText.getReferenceCount(J.currentKey)===1&&re===J.texture._source.width&&ie===J.texture._source.height)}return!1}addRenderable(X,K){const J=this._getGpuText(X).batchableSprite;X.view._didUpdate&&this._updateText(X),this._renderer.renderPipes.batch.addToBatch(J)}updateRenderable(X){const K=this._getGpuText(X).batchableSprite;X.view._didUpdate&&this._updateText(X),K.batcher.updateElement(K)}destroyRenderable(X){this._destroyRenderableById(X.uid)}_destroyRenderableById(X){const K=this._gpuText[X];this._renderer.canvasText.decreaseReferenceCount(K.currentKey),BigPool.return(K.batchableSprite),this._gpuText[X]=null}_updateText(X){const K=X.view._getKey(),J=this._getGpuText(X),Q=J.batchableSprite;J.currentKey!==K&&this._updateGpuText(X),X.view._didUpdate=!1;const ee=X.view._style.padding;updateQuadBounds(Q.bounds,X.view.anchor,Q.texture,ee)}_updateGpuText(X){var K;const J=this._getGpuText(X),Q=J.batchableSprite,ee=X.view;J.texture&&this._renderer.canvasText.decreaseReferenceCount(J.currentKey);const te=(K=ee.resolution)!=null?K:this._renderer.resolution;J.texture=Q.texture=this._renderer.canvasText.getTexture(ee.text,te,ee._style,ee._getKey()),J.currentKey=ee._getKey(),Q.texture=J.texture}_getGpuText(X){return this._gpuText[X.uid]||this._initGpuText(X)}_initGpuText(X){const K={texture:null,currentKey:"--",batchableSprite:BigPool.get(BatchableSprite)};return K.batchableSprite.renderable=X,K.batchableSprite.bounds=[0,1,0,0],K.batchableSprite.roundPixels=this._renderer._roundPixels|X.view.roundPixels,this._gpuText[X.uid]=K,this._updateText(X),X.on("destroyed",()=>{this.destroyRenderable(X)}),K}destroy(){for(const X in this._gpuText)this._destroyRenderableById(X);this._gpuText=null,this._renderer=null}}CanvasTextPipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"text"};const p$b=new Bounds;function getPo2TextureFromSource(Z,X,K,J){const Q=p$b;Q.minX=0,Q.minY=0,Q.maxX=Z.width/J|0,Q.maxY=Z.height/J|0;const ee=TexturePool.getOptimalTexture(Q.width,Q.height,J,!1);return ee.source.uploadMethodId="image",ee.source.resource=Z,ee.source.alphaMode="premultiply-alpha-on-upload",ee.frameWidth=X/J,ee.frameHeight=K/J,ee.source.update(),ee.layout.updateUvs(),ee}class CanvasTextSystem{constructor(){this._activeTextures={}}getTextureSize(X,K,J){const Q=CanvasTextMetrics.measureText(X||" ",J);let ee=Math.ceil(Math.ceil(Math.max(1,Q.width)+J.padding*2)*K),te=Math.ceil(Math.ceil(Math.max(1,Q.height)+J.padding*2)*K);return ee=Math.ceil(ee-1e-6),te=Math.ceil(te-1e-6),ee=nextPow2(ee),te=nextPow2(te),{width:ee,height:te}}getTexture(X,K,J,Q){if(this._activeTextures[Q])return this._increaseReferenceCount(Q),this._activeTextures[Q].texture;const ee=CanvasTextMetrics.measureText(X||" ",J),te=Math.ceil(Math.ceil(Math.max(1,ee.width)+J.padding*2)*K),re=Math.ceil(Math.ceil(Math.max(1,ee.height)+J.padding*2)*K),ie=CanvasPool.getOptimalCanvasAndContext(te,re),{canvas:ne}=ie;this.renderTextToCanvas(X,J,K,ie);const se=getPo2TextureFromSource(ne,te,re,K);return this._activeTextures[Q]={canvasAndContext:ie,texture:se,usageCount:1},se}_increaseReferenceCount(X){this._activeTextures[X].usageCount++}decreaseReferenceCount(X){const K=this._activeTextures[X];if(K.usageCount--,K.usageCount===0){CanvasPool.returnCanvasAndContext(K.canvasAndContext),TexturePool.returnTexture(K.texture);const J=K.texture.source;J.resource=null,J.uploadMethodId="unknown",J.alphaMode="no-premultiply-alpha",this._activeTextures[X]=null}}getReferenceCount(X){return this._activeTextures[X].usageCount}renderTextToCanvas(X,K,J,Q){var ee,te,re,ie,ne,se;const{canvas:oe,context:ae}=Q,le=fontStringFromTextStyle(K),ce=CanvasTextMetrics.measureText(X||" ",K),de=ce.lines,he=ce.lineHeight,pe=ce.lineWidths,fe=ce.maxLineWidth,ge=ce.fontProperties,me=oe.height;if(ae.resetTransform(),ae.scale(J,J),ae.clearRect(0,0,ce.width+4,ce.height+4),(ee=K._stroke)!=null&&ee.width){const xe=K._stroke;ae.lineWidth=xe.width,ae.miterLimit=xe.miterLimit,ae.lineJoin=xe.join,ae.lineCap=xe.cap}ae.font=le;let ye,_e;const Ce=K.dropShadow?2:1;for(let xe=0;xe<Ce;++xe){const be=K.dropShadow&&xe===0,ve=be?Math.ceil(Math.max(1,me)+K.padding*2):0,Se=ve*J;if(be){ae.fillStyle="black",ae.strokeStyle="black";const Ae=K.dropShadow,Ie=Ae.color,we=Ae.alpha;ae.shadowColor=Color.shared.setValue(Ie).setAlpha(we).toRgbaString();const Be=Ae.blur*J,Re=Ae.distance*J;ae.shadowBlur=Be,ae.shadowOffsetX=Math.cos(Ae.angle)*Re,ae.shadowOffsetY=Math.sin(Ae.angle)*Re+Se}else ae.globalAlpha=(re=(te=K._fill)==null?void 0:te.alpha)!=null?re:1,ae.fillStyle=K._fill?getCanvasFillStyle(K._fill,ae):null,(ie=K._stroke)!=null&&ie.width&&(ae.strokeStyle=getCanvasFillStyle(K._stroke,ae)),ae.shadowColor="black";let Pe=(he-ge.fontSize)/2;he-ge.fontSize<0&&(Pe=0);const Te=(se=(ne=K._stroke)==null?void 0:ne.width)!=null?se:0;for(let Ae=0;Ae<de.length;Ae++)ye=Te/2,_e=Te/2+Ae*he+ge.ascent+Pe,K.align==="right"?ye+=fe-pe[Ae]:K.align==="center"&&(ye+=(fe-pe[Ae])/2),K._stroke&&this._drawLetterSpacing(de[Ae],K,Q,ye+K.padding,_e+K.padding-ve,!0),K._fill!==void 0&&this._drawLetterSpacing(de[Ae],K,Q,ye+K.padding,_e+K.padding-ve)}}_drawLetterSpacing(X,K,J,Q,ee,te=!1){const{context:re}=J,ie=K.letterSpacing;let ne=!1;if(CanvasTextMetrics.experimentalLetterSpacingSupported&&(CanvasTextMetrics.experimentalLetterSpacing?(re.letterSpacing=`${ie}px`,re.textLetterSpacing=`${ie}px`,ne=!0):(re.letterSpacing="0px",re.textLetterSpacing="0px")),ie===0||ne){te?re.strokeText(X,Q,ee):re.fillText(X,Q,ee);return}let se=Q;const oe=CanvasTextMetrics.graphemeSegmenter(X);let ae=re.measureText(X).width,le=0;for(let ce=0;ce<oe.length;++ce){const de=oe[ce];te?re.strokeText(de,se,ee):re.fillText(de,se,ee);let he="";for(let pe=ce+1;pe<oe.length;++pe)he+=oe[pe];le=re.measureText(he).width,se+=ae-le+ie,ae=le}}destroy(){this._activeTextures=null}}CanvasTextSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem,u$v.CanvasSystem],name:"canvasText"};class HTMLTextPipe{constructor(X){this._gpuText=Object.create(null),this._renderer=X}validateRenderable(X){const K=this._getGpuText(X),J=X.view._getKey();return K.textureNeedsUploading?(K.textureNeedsUploading=!1,!0):K.currentKey!==J}addRenderable(X){const K=this._getGpuText(X).batchableSprite;X.view._didUpdate&&this._updateText(X),this._renderer.renderPipes.batch.addToBatch(K)}updateRenderable(X){const K=this._getGpuText(X).batchableSprite;X.view._didUpdate&&this._updateText(X),K.batcher.updateElement(K)}destroyRenderable(X){this._destroyRenderableById(X.uid)}_destroyRenderableById(X){const K=this._gpuText[X];this._renderer.htmlText.decreaseReferenceCount(K.currentKey),BigPool.return(K.batchableSprite),this._gpuText[X]=null}_updateText(X){const K=X.view._getKey(),J=this._getGpuText(X),Q=J.batchableSprite;J.currentKey!==K&&this._updateGpuText(X).catch(te=>{console.error(te)}),X.view._didUpdate=!1;const ee=X.view._style.padding;updateQuadBounds(Q.bounds,X.view.anchor,Q.texture,ee)}async _updateGpuText(X){var K;X.view._didUpdate=!1;const J=this._getGpuText(X);if(J.generatingTexture)return;const Q=X.view._getKey();this._renderer.htmlText.decreaseReferenceCount(J.currentKey),J.generatingTexture=!0,J.currentKey=Q;const ee=X.view,te=(K=ee.resolution)!=null?K:this._renderer.resolution,re=await this._renderer.htmlText.getManagedTexture(ee.text,te,ee._style,ee._getKey()),ie=J.batchableSprite;ie.texture=J.texture=re,J.generatingTexture=!1,J.textureNeedsUploading=!0,X.view.onUpdate();const ne=X.view._style.padding;updateQuadBounds(ie.bounds,X.view.anchor,ie.texture,ne)}_getGpuText(X){return this._gpuText[X.uid]||this._initGpuText(X)}_initGpuText(X){const K={texture:Texture.EMPTY,currentKey:"--",batchableSprite:BigPool.get(BatchableSprite),textureNeedsUploading:!1,generatingTexture:!1},J=K.batchableSprite;return J.renderable=X,J.texture=Texture.EMPTY,J.bounds=[0,1,0,0],J.roundPixels=this._renderer._roundPixels|X.view.roundPixels,this._gpuText[X.uid]=K,X.on("destroyed",()=>{this.destroyRenderable(X)}),K}destroy(){for(const X in this._gpuText)this._destroyRenderableById(X);this._gpuText=null,this._renderer=null}}HTMLTextPipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"htmlText"};function isSafari(){const{userAgent:Z}=DOMAdapter.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(Z)}function extractFontFamilies(Z,X){const K=X.fontFamily,J=[],Q={},ee=/font-family:([^;"\s]+)/g,te=Z.match(ee);function re(ie){Q[ie]||(J.push(ie),Q[ie]=!0)}if(Array.isArray(K))for(let ie=0;ie<K.length;ie++)re(K[ie]);else re(K);te&&te.forEach(ie=>{const ne=ie.split(":")[1].trim();re(ne)});for(const ie in X.tagStyles){const ne=X.tagStyles[ie].fontFamily;re(ne)}return J}async function loadFontAsBase64(Z){const X=await(await DOMAdapter.get().fetch(Z)).blob(),K=new FileReader;return await new Promise((J,Q)=>{K.onloadend=()=>J(K.result),K.onerror=Q,K.readAsDataURL(X)})}async function loadFontCSS(Z,X){const K=await loadFontAsBase64(X);return`@font-face {
        font-family: "${Z.fontFamily}";
        src: url('${K}');
        font-weight: ${Z.fontWeight};
        font-style: ${Z.fontStyle};
    }`}var c$6=Object.defineProperty,f$7=Object.defineProperties,u$9=Object.getOwnPropertyDescriptors,i$3=Object.getOwnPropertySymbols,x$5=Object.prototype.hasOwnProperty,g$3=Object.prototype.propertyIsEnumerable,m$6=(Z,X,K)=>X in Z?c$6(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,p$a=(Z,X)=>{for(var K in X||(X={}))x$5.call(X,K)&&m$6(Z,K,X[K]);if(i$3)for(var K of i$3(X))g$3.call(X,K)&&m$6(Z,K,X[K]);return Z},l$9=(Z,X)=>f$7(Z,u$9(X));async function getFontCss(Z,X){const K=Z.filter(J=>Cache.has(J)).map((J,Q)=>{if(!FontStylePromiseCache.has(J)){const{url:ee}=Cache.get(J);Q===0?FontStylePromiseCache.set(J,loadFontCSS(X,ee)):FontStylePromiseCache.set(J,loadFontCSS(l$9(p$a({},HTMLTextSystem.defaultFontOptions),{fontFamily:J}),ee))}return FontStylePromiseCache.get(J)});return(await Promise.all(K)).join(`
`)}function getSVGUrl(Z,X,K,J,Q){const{domElement:ee,styleElement:te,svgRoot:re}=Q;ee.innerHTML=`<style>${X.cssStyle}</style><div>${Z}</div>`,ee.setAttribute("style",`transform: scale(${K});transform-origin: top left; display: inline-block`),te.textContent=J;const{width:ie,height:ne}=Q.image;return re.setAttribute("width",ie.toString()),re.setAttribute("height",ne.toString()),new XMLSerializer().serializeToString(re)}function getTemporaryCanvasFromImage(Z,X){const K=CanvasPool.getOptimalCanvasAndContext(Z.width,Z.height,X),{context:J}=K;return J.clearRect(0,0,Z.width,Z.height),J.drawImage(Z,0,0),CanvasPool.returnCanvasAndContext(K),K.canvas}function loadSVGImage(Z,X,K){return new Promise(async J=>{K&&await new Promise(Q=>setTimeout(Q,100)),Z.onload=()=>{J()},Z.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(X)}`,Z.crossOrigin="anonymous"})}let s$c;function measureHtmlText(Z,X,K,J){J=J||s$c||(s$c=new HTMLTextRenderData);const{domElement:Q,styleElement:ee,svgRoot:te}=J;Q.innerHTML=`<style>${X.cssStyle}</style><div>${Z}</div>`,Q.setAttribute("style","transform-origin: top left; display: inline-block"),K&&(ee.textContent=K),document.body.appendChild(te);const re=Q.getBoundingClientRect();te.remove();const ie=CanvasTextMetrics.measureFont(X.fontStyle).descent;return{width:re.width,height:re.height+ie}}const p$9="http://www.w3.org/2000/svg",d$4="http://www.w3.org/1999/xhtml",FontStylePromiseCache=new Map;class HTMLTextRenderData{constructor(){this.svgRoot=document.createElementNS(p$9,"svg"),this.foreignObject=document.createElementNS(p$9,"foreignObject"),this.domElement=document.createElementNS(d$4,"div"),this.styleElement=document.createElementNS(d$4,"style"),this.image=new Image;const{foreignObject:X,svgRoot:K,styleElement:J,domElement:Q}=this;X.setAttribute("width","10000"),X.setAttribute("height","10000"),X.style.overflow="hidden",K.appendChild(X),X.appendChild(J),X.appendChild(Q)}}class HTMLTextSystem{constructor(X){this._activeTextures={},this._renderer=X,this._createCanvas=X.type===RendererType.WEBGPU}getTexture(X){return this._buildTexturePromise(X.text,X.resolution,X.style)}getManagedTexture(X,K,J,Q){if(this._activeTextures[Q])return this._increaseReferenceCount(Q),this._activeTextures[Q].promise;const ee=this._buildTexturePromise(X,K,J).then(te=>(this._activeTextures[Q].texture=te,te));return this._activeTextures[Q]={texture:null,promise:ee,usageCount:1},ee}async _buildTexturePromise(X,K,J){const Q=BigPool.get(HTMLTextRenderData),ee=extractFontFamilies(X,J),te=await getFontCss(ee,J),re=measureHtmlText(X,J,te,Q),ie=Math.ceil(Math.ceil(Math.max(1,re.width)+J.padding*2)*K),ne=Math.ceil(Math.ceil(Math.max(1,re.height)+J.padding*2)*K),se=Q.image;se.width=ie|0,se.height=ne|0;const oe=getSVGUrl(X,J,K,te,Q);await loadSVGImage(se,oe,isSafari()&&ee.length>0);let ae=se;this._createCanvas&&(ae=getTemporaryCanvasFromImage(se,K));const le=getPo2TextureFromSource(ae,se.width,se.height,K);return this._createCanvas&&this._renderer.texture.initSource(le.source),BigPool.return(Q),le}_increaseReferenceCount(X){this._activeTextures[X].usageCount++}decreaseReferenceCount(X){const K=this._activeTextures[X];K&&(K.usageCount--,K.usageCount===0&&(K.texture?this._cleanUp(K):K.promise.then(J=>{K.texture=J,this._cleanUp(K)}).catch(()=>{}),this._activeTextures[X]=null))}_cleanUp(X){TexturePool.returnTexture(X.texture),X.texture.source.resource=null,X.texture.source.uploadMethodId="unknown"}getReferenceCount(X){return this._activeTextures[X].usageCount}destroy(){this._activeTextures=null}}HTMLTextSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem,u$v.CanvasSystem],name:"htmlText"},HTMLTextSystem.defaultFontOptions={fontFamily:"Arial",fontStyle:"normal",fontWeight:"normal"};var u$8=Object.defineProperty,c$5=Object.getOwnPropertySymbols,s$b=Object.prototype.hasOwnProperty,b$5=Object.prototype.propertyIsEnumerable,n$7=(Z,X,K)=>X in Z?u$8(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,a$6=(Z,X)=>{for(var K in X||(X={}))s$b.call(X,K)&&n$7(Z,K,X[K]);if(c$5)for(var K of c$5(X))b$5.call(X,K)&&n$7(Z,K,X[K]);return Z};const l$8=class{constructor(){this.clearBeforeRender=!0,this._backgroundColor=new Color(0),this.color=this._backgroundColor,this.alpha=1}init(Z){Z=a$6(a$6({},l$8.defaultOptions),Z),this.clearBeforeRender=Z.clearBeforeRender,this.color=Z.background||Z.backgroundColor||this._backgroundColor,this.alpha=Z.backgroundAlpha,this._backgroundColor.setAlpha(Z.backgroundAlpha)}get color(){return this._backgroundColor}set color(Z){this._backgroundColor.setValue(Z)}get alpha(){return this._backgroundColor.alpha}set alpha(Z){this._backgroundColor.setAlpha(Z)}get colorRgba(){return this._backgroundColor.toArray()}destroy(){}};let BackgroundSystem=l$8;BackgroundSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem,u$v.CanvasSystem],name:"background",priority:0},BackgroundSystem.defaultOptions={backgroundAlpha:1,backgroundColor:0,clearBeforeRender:!0};const n$6={};b$p.handle(u$v.BlendMode,Z=>{if(!Z.name)throw new Error("BlendMode extension must have a name property");n$6[Z.name]=Z.ref},Z=>{delete n$6[Z.name]});class BlendModePipe{constructor(X){this._isAdvanced=!1,this._filterHash=Object.create(null),this._renderer=X}setBlendMode(X,K,J){if(this._activeBlendMode===K){this._isAdvanced&&this._renderableList.push(X);return}this._activeBlendMode=K,this._isAdvanced&&this._endAdvancedBlendMode(J),this._isAdvanced=!!n$6[K],this._isAdvanced&&(this._beginAdvancedBlendMode(J),this._renderableList.push(X))}_beginAdvancedBlendMode(X){this._renderer.renderPipes.batch.break(X);const K=this._activeBlendMode;if(!n$6[K])return;this._filterHash[K]||(this._filterHash[K]=new FilterEffect({filters:[new n$6[K]]}));const J={renderPipeId:"filter",action:"pushFilter",renderables:[],filterEffect:this._filterHash[K],canBundle:!1};this._renderableList=J.renderables,X.add(J)}_endAdvancedBlendMode(X){this._renderableList=null,this._renderer.renderPipes.batch.break(X),X.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}buildStart(){this._isAdvanced=!1}buildEnd(X){this._isAdvanced&&this._endAdvancedBlendMode(X)}destroy(){this._renderer=null,this._renderableList=null;for(const X in this._filterHash)this._filterHash[X].destroy();this._filterHash=null}}BlendModePipe.extension={type:[u$v.WebGLPipes,u$v.WebGPUPipes,u$v.CanvasPipes],name:"blendMode"};var f$6=Object.defineProperty,x$4=Object.getOwnPropertySymbols,O=Object.prototype.hasOwnProperty,b$4=Object.prototype.propertyIsEnumerable,d$3=(Z,X,K)=>X in Z?f$6(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$7=(Z,X)=>{for(var K in X||(X={}))O.call(X,K)&&d$3(Z,K,X[K]);if(x$4)for(var K of x$4(X))b$4.call(X,K)&&d$3(Z,K,X[K]);return Z};const p$8=class{constructor(Z){this._renderer=Z}_normalizeOptions(Z,X={}){return Z instanceof Container||Z instanceof Texture?u$7({target:Z},X):u$7(u$7({},X),Z)}async image(Z){const X=new Image;return X.src=await this.base64(Z),X}async base64(Z){Z=this._normalizeOptions(Z,p$8.defaultImageOptions);const{format:X,quality:K}=Z,J=this.canvas(Z);if(J.toBlob!==void 0)return new Promise((Q,ee)=>{J.toBlob(te=>{if(!te){ee(new Error("ICanvas.toBlob failed!"));return}const re=new FileReader;re.onload=()=>Q(re.result),re.onerror=ee,re.readAsDataURL(te)},X,K)});if(J.toDataURL!==void 0)return J.toDataURL(X,K);if(J.convertToBlob!==void 0){const Q=await J.convertToBlob({type:X,quality:K});return new Promise((ee,te)=>{const re=new FileReader;re.onload=()=>ee(re.result),re.onerror=te,re.readAsDataURL(Q)})}throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")}canvas(Z){Z=this._normalizeOptions(Z);const X=Z.target,K=this._renderer,J=X instanceof Texture?X:K.textureGenerator.generateTexture(Z),Q=K.texture.generateCanvas(J);return X instanceof Container&&J.destroy(),Q}pixels(Z){Z=this._normalizeOptions(Z);const X=Z.target,K=this._renderer,J=X instanceof Texture?X:K.textureGenerator.generateTexture(Z),Q=K.texture.getPixels(J);return X instanceof Container&&J.destroy(),Q}texture(Z){return Z=this._normalizeOptions(Z),Z.target instanceof Texture?Z.target:this._renderer.textureGenerator.generateTexture(Z)}download(Z){var X;Z=this._normalizeOptions(Z);const K=this.canvas(Z),J=document.createElement("a");J.download=(X=Z.filename)!=null?X:"image.png",J.href=K.toDataURL("image/png"),document.body.appendChild(J),J.click(),document.body.removeChild(J)}log(Z){var X;const K=(X=Z.width)!=null?X:200;Z=this._normalizeOptions(Z);const J=this.canvas(Z),Q=J.toDataURL();console.log(`[Pixi Texture] ${J.width}px ${J.height}px`);const ee=["font-size: 1px;",`padding: ${K}px 300px;`,`background: url(${Q}) no-repeat;`,"background-size: contain;"].join(" ");console.log("%c ",ee)}destroy(){this._renderer=null}};let ExtractSystem=p$8;ExtractSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem],name:"extract"},ExtractSystem.defaultImageOptions={format:"png",quality:1};class RenderTexture extends Texture{static create(X){return new Texture({source:new TextureSource(X)})}resize(X,K,J){return this.source.resize(X,K,J),this}}var x$3=Object.defineProperty,y$2=Object.defineProperties,h$9=Object.getOwnPropertyDescriptors,a$5=Object.getOwnPropertySymbols,f$5=Object.prototype.hasOwnProperty,g$2=Object.prototype.propertyIsEnumerable,m$5=(Z,X,K)=>X in Z?x$3(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,c$4=(Z,X)=>{for(var K in X||(X={}))f$5.call(X,K)&&m$5(Z,K,X[K]);if(a$5)for(var K of a$5(X))g$2.call(X,K)&&m$5(Z,K,X[K]);return Z},l$7=(Z,X)=>y$2(Z,h$9(X));const A$1=new Rectangle,b$3=new Bounds,B=[0,0,0,0];class GenerateTextureSystem{constructor(X){this._renderer=X}generateTexture(X){var K;X instanceof Container&&(X={target:X,frame:void 0,textureSourceOptions:{},resolution:void 0});const J=X.resolution||this._renderer.resolution,Q=X.target;let ee=X.clearColor;ee?ee=Array.isArray(ee)&&ee.length===4?ee:Color.shared.setValue(ee).toArray():ee=B;const te=((K=X.frame)==null?void 0:K.copyTo(A$1))||getLocalBounds(Q,b$3).rectangle;te.width=Math.max(te.width,1/J)|0,te.height=Math.max(te.height,1/J)|0;const re=RenderTexture.create(l$7(c$4({},X.textureSourceOptions),{width:te.width,height:te.height,resolution:J})),ie=Matrix.shared.translate(-te.x,-te.y);return this._renderer.render({container:Q,transform:ie,target:re,clearColor:ee}),re}destroy(){this._renderer=null}}GenerateTextureSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem],name:"textureGenerator"};class GlobalUniformSystem{constructor(X){this._stackIndex=0,this._globalUniformDataStack=[],this._uniformsPool=[],this._activeUniforms=[],this._bindGroupPool=[],this._activeBindGroups=[],this._renderer=X}reset(){this._stackIndex=0;for(let X=0;X<this._activeUniforms.length;X++)this._uniformsPool.push(this._activeUniforms[X]);for(let X=0;X<this._activeBindGroups.length;X++)this._bindGroupPool.push(this._activeBindGroups[X]);this._activeUniforms.length=0,this._activeBindGroups.length=0}start(X){this.reset(),this.push(X)}bind({size:X,projectionMatrix:K,worldTransformMatrix:J,worldColor:Q,offset:ee}){const te=this._renderer.renderTarget.renderTarget,re=this._stackIndex?this._globalUniformDataStack[this._stackIndex-1]:{projectionData:te,worldTransformMatrix:new Matrix,worldColor:4294967295,offset:new Point},ie={projectionMatrix:K||this._renderer.renderTarget.projectionMatrix,resolution:X||te.size,worldTransformMatrix:J||re.worldTransformMatrix,worldColor:Q||re.worldColor,offset:ee||re.offset,bindGroup:null},ne=this._uniformsPool.pop()||this._createUniforms();this._activeUniforms.push(ne);const se=ne.uniforms;se.projectionMatrix=ie.projectionMatrix,se.uResolution=ie.resolution,se.worldTransformMatrix.copyFrom(ie.worldTransformMatrix),se.worldTransformMatrix.tx-=ie.offset.x,se.worldTransformMatrix.ty-=ie.offset.y,se.worldAlpha=(ie.worldColor>>24&255)/255,ne.update();let oe;this._renderer.renderPipes.uniformBatch?oe=this._renderer.renderPipes.uniformBatch.getUniformBindGroup(ne,!1):(this._renderer.uniformBuffer.updateUniformGroup(ne),oe=this._bindGroupPool.pop()||new BindGroup,this._activeBindGroups.push(oe),oe.setResource(ne,0)),ie.bindGroup=oe,this._currentGlobalUniformData=ie}push(X){this.bind(X),this._globalUniformDataStack[this._stackIndex++]=this._currentGlobalUniformData}pop(){this._currentGlobalUniformData=this._globalUniformDataStack[--this._stackIndex-1]}get bindGroup(){return this._currentGlobalUniformData.bindGroup}get uniformGroup(){return this._currentGlobalUniformData.bindGroup.resources[0]}_createUniforms(){return new UniformGroup({projectionMatrix:{value:new Matrix,type:"mat3x3<f32>"},worldTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},worldAlpha:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}},{ubo:!0,isStatic:!0})}destroy(){this._renderer=null}}GlobalUniformSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem,u$v.CanvasSystem],name:"globalUniforms"};const WGSL_TO_STD40_SIZE={f32:4,"vec2<f32>":8,"vec3<f32>":12,"vec4<f32>":16,"mat2x2<f32>":48,"mat3x3<f32>":48,"mat4x4<f32>":64};function createUBOElements(Z){const X=Z.map(ee=>({data:ee,offset:0,size:0}));let K=0,J=0,Q=0;for(let ee=0;ee<X.length;ee++){const te=X[ee];if(K=WGSL_TO_STD40_SIZE[te.data.type],!K)throw new Error(`Unknown type ${te.data.type}`);if(te.data.size>1&&(K=Math.max(K,16)*te.data.size),te.size=K,J%K!==0&&J<16){const re=J%K%16;J+=re,Q+=re}J+K>16?(Q=Math.ceil(Q/16)*16,te.offset=Q,Q+=K,J=K):(te.offset=Q,J+=K,Q+=K)}return Q=Math.ceil(Q/16)*16,{uboElements:X,size:Q}}const uniformBufferParsers=[{type:"mat3x3<f32>",test:Z=>Z.value.a!==void 0,code:Z=>`
                var ${Z}_matrix = uv.${Z}.toArray(true);

                data[offset] = ${Z}_matrix[0];
                data[offset+1] = ${Z}_matrix[1];
                data[offset+2] = ${Z}_matrix[2];

                data[offset + 4] = ${Z}_matrix[3];
                data[offset + 5] = ${Z}_matrix[4];
                data[offset + 6] = ${Z}_matrix[5];

                data[offset + 8] = ${Z}_matrix[6];
                data[offset + 9] = ${Z}_matrix[7];
                data[offset + 10] = ${Z}_matrix[8];
            `},{type:"vec4<f32>",test:Z=>Z.type==="vec4<f32>"&&Z.size===1&&Z.value.width!==void 0,code:Z=>`
                        v = uv.${Z};

                        data[offset] = v.x;
                        data[offset+1] = v.y;
                        data[offset+2] = v.width;
                        data[offset+3] = v.height;
                    `},{type:"vec2<f32>",test:Z=>Z.type==="vec2<f32>"&&Z.size===1&&Z.value.x!==void 0,code:Z=>`
                    v = uv.${Z};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                `}],u$6={f32:`
        data[offset] = v;
    `,"vec2<f32>":`
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,"vec3<f32>":`
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,"vec4<f32>":`
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,"mat2x2<f32>":`
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,"mat3x3<f32>":`
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,"mat4x4<f32>":`
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `};function generateUniformBufferSync(Z){const X=[`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
    `];let K=0;for(let Q=0;Q<Z.length;Q++){const ee=Z[Q],te=ee.data.name;let re=!1,ie=0;for(let ne=0;ne<uniformBufferParsers.length;ne++)if(uniformBufferParsers[ne].test(ee.data)){ie=ee.offset/4,X.push(`offset += ${ie-K};`,uniformBufferParsers[ne].code(te)),re=!0;break}if(!re)if(ee.data.size>1){const ne=Math.max(WGSL_TO_STD40_SIZE[ee.data.type]/16,1),se=ee.data.value.length/ee.data.size,oe=(4-se%4)%4;ie=ee.offset/4,X.push(`
                    v = uv.${te};
                    offset += ${ie-K};

                    let arrayOffset = offset;
                    
                    t = 0;

                    for(var i=0; i < ${ee.data.size*ne}; i++)
                    {
                        for(var j = 0; j < ${se}; j++)
                        {
                            data[arrayOffset++] = v[t++];
                        }
                        ${oe!==0?"arrayOffset += ${remainder};":""}
                    }
                `)}else{const ne=u$6[ee.data.type];ie=ee.offset/4,X.push(`
                    v = uv.${te};
                    offset += ${ie-K};
                    ${ne};
                `)}K=ie}const J=X.join(`
`);return new Function("uv","data","offset",J)}class UniformBufferSystem{constructor(){this._syncFunctionHash=Object.create(null)}ensureUniformGroup(X){X._syncFunction||this._initUniformGroup(X)}_initUniformGroup(X){const K=X._signature;let J=this._syncFunctionHash[K];if(!J){const Q=Object.keys(X.uniformStructures).map(re=>X.uniformStructures[re]),ee=createUBOElements(Q),te=generateUniformBufferSync(ee.uboElements);J=this._syncFunctionHash[K]={layout:ee,syncFunction:te}}return X._syncFunction=J.syncFunction,X.buffer=new Buffer({data:new Float32Array(J.layout.size/4),usage:BufferUsage.UNIFORM|BufferUsage.COPY_DST}),X._syncFunction}syncUniformGroup(X,K,J){const Q=X._syncFunction||this._initUniformGroup(X);return K||(K=X.buffer.data),J||(J=0),Q(X.uniforms,K,J),!0}updateUniformGroup(X){if(X.isStatic&&!X._dirtyId)return!1;X._dirtyId=0;const K=this.syncUniformGroup(X);return X.buffer.update(),K}destroy(){this._syncFunctionHash=null}}UniformBufferSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem,u$v.CanvasSystem],name:"uniformBuffer"};let i$2=!1;const VERSION="8.0.0-beta.10";function sayHello(Z){if(!i$2){if(DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome")>-1){const X=[`%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${Z}) http://www.pixijs.com/

`,"background: #E72264; padding:5px 0;","background: #6CA2EA; padding:5px 0;","background: #B5D33D; padding:5px 0;","background: #FED23F; padding:5px 0;","color: #FFFFFF; background: #E72264; padding:5px 0;","color: #E72264; background: #FFFFFF; padding:5px 0;"];globalThis.console.log(...X)}else globalThis.console&&globalThis.console.log(`PixiJS ${VERSION} - ${Z} - http://www.pixijs.com/`);i$2=!0}}class HelloSystem{constructor(X){this._renderer=X}init(X){X.hello&&sayHello(this._renderer.name)}}HelloSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem,u$v.CanvasSystem],name:"hello",priority:0},HelloSystem.defaultOptions={hello:!1};var a$4=Object.defineProperty,c$3=Object.getOwnPropertySymbols,d$2=Object.prototype.hasOwnProperty,h$8=Object.prototype.propertyIsEnumerable,s$a=(Z,X,K)=>X in Z?a$4(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$5=(Z,X)=>{for(var K in X||(X={}))d$2.call(X,K)&&s$a(Z,K,X[K]);if(c$3)for(var K of c$3(X))h$8.call(X,K)&&s$a(Z,K,X[K]);return Z};const i$1=class{constructor(Z){this._renderer=Z,this.count=0,this.checkCount=0}init(Z){Z=u$5(u$5({},i$1.defaultOptions),Z),this.checkCountMax=Z.textureGCCheckCountMax,this.maxIdle=Z.textureGCAMaxIdle,this.active=Z.textureGCActive}postrender(){this._renderer.renderingToScreen&&(this.count++,this.active&&(this.checkCount++,this.checkCount>this.checkCountMax&&(this.checkCount=0,this.run())))}run(){const Z=this._renderer.texture.managedTextures;for(let X=0;X<Z.length;X++){const K=Z[X];K.resource&&K._touched>-1&&this.count-K._touched>this.maxIdle&&(K._touched=-1,K.unload())}}destroy(){this._renderer=null}};let TextureGCSystem=i$1;TextureGCSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem],name:"textureGC"},TextureGCSystem.defaultOptions={textureGCActive:!0,textureGCAMaxIdle:60*60,textureGCCheckCountMax:600},b$p.add(TextureGCSystem);var m$4=Object.defineProperty,n$5=Object.getOwnPropertySymbols,h$7=Object.prototype.hasOwnProperty,l$6=Object.prototype.propertyIsEnumerable,u$4=(Z,X,K)=>X in Z?m$4(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,s$9=(Z,X)=>{for(var K in X||(X={}))h$7.call(X,K)&&u$4(Z,K,X[K]);if(n$5)for(var K of n$5(X))l$6.call(X,K)&&u$4(Z,K,X[K]);return Z};const r$2=class{get resolution(){return this.texture.source._resolution}set resolution(Z){this.texture.source.resize(this.texture.source.width,this.texture.source.height,Z)}init(Z){Z=s$9(s$9({},r$2.defaultOptions),Z),Z.element&&(deprecation(v8_0_0,"ViewSystem.element has been renamed to ViewSystem.canvas"),Z.canvas=Z.element),this.screen=new Rectangle(0,0,Z.width,Z.height),this.canvas=Z.canvas||DOMAdapter.get().createCanvas(),this.antialias=!!Z.antialias,this.texture=getCanvasTexture(this.canvas,Z),this.multiView=!!Z.multiView,this.autoDensity&&(this.canvas.style.width=`${this.texture.width}px`,this.canvas.style.height=`${this.texture.height}px`),this.resolution=Z.resolution}resize(Z,X,K){this.texture.source.resize(Z,X,K),this.screen.width=this.texture.frameWidth,this.screen.height=this.texture.frameHeight,this.autoDensity&&(this.canvas.style.width=`${Z}px`,this.canvas.style.height=`${X}px`)}destroy(Z=!1){(typeof Z=="boolean"?Z:Z!=null&&Z.removeView)&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}};let ViewSystem=r$2;ViewSystem.extension={type:[u$v.WebGLSystem,u$v.WebGPUSystem,u$v.CanvasSystem],name:"view",priority:0},ViewSystem.defaultOptions={width:800,height:600,autoDensity:!1,antialias:!1};const SharedSystems=[BackgroundSystem,FilterSystem,GraphicsContextSystem,GlobalUniformSystem,HelloSystem,ViewSystem,CanvasTextSystem,HTMLTextSystem,LayerSystem,UniformBufferSystem,TextureGCSystem,GenerateTextureSystem,ExtractSystem],SharedRenderPipes=[BlendModePipe,BatcherPipe,SpritePipe,LayerPipe,MeshPipe,GraphicsPipe,CanvasTextPipe,HTMLTextPipe,BitmapTextPipe,TilingSpritePipe,FilterPipe,AlphaMaskPipe,StencilMaskPipe,ColorMaskPipe],T$3=[...SharedSystems,GlBackBufferSystem,GlContextSystem,GlBufferSystem,GlTextureSystem,GlRenderTargetSystem,GlGeometrySystem,GlUniformGroupSystem,GlShaderSystem,GlEncoderSystem,GlStateSystem,GlStencilSystem,GlColorMaskSystem],h$6=[...SharedRenderPipes],v$2=[GlBatchAdaptor,GlMeshAdaptor,GlGraphicsAdaptor],r$1=[],s$8=[],o$5=[];b$p.handleByNamedList(u$v.WebGLSystem,r$1),b$p.handleByNamedList(u$v.WebGLPipes,s$8),b$p.handleByNamedList(u$v.WebGLPipesAdaptor,o$5),b$p.add(...T$3,...h$6,...v$2);class WebGLRenderer extends AbstractRenderer{constructor(){const X={name:"webgl2",type:RendererType.WEBGL,systems:r$1,renderPipes:s$8,renderPipeAdaptors:o$5};super(X)}}var WebGLRenderer$1={__proto__:null,WebGLRenderer};class BindGroupSystem{constructor(X){this._hash=Object.create(null),this._renderer=X}contextChange(X){this._gpu=X}getBindGroup(X,K,J){return X._updateKey(),this._hash[X._key]||this._createBindGroup(X,K,J)}_createBindGroup(X,K,J){var Q;const ee=this._gpu.device,te=K.layout[J],re=[];for(const ne in te){const se=(Q=X.resources[ne])!=null?Q:X.resources[te[ne]];let oe;if(se._resourceType==="uniformGroup"){const ae=se;this._renderer.uniformBuffer.updateUniformGroup(ae);const le=ae.buffer;oe={buffer:this._renderer.buffer.getGPUBuffer(le),offset:0,size:le.descriptor.size}}else if(se._resourceType==="buffer"){const ae=se;oe={buffer:this._renderer.buffer.getGPUBuffer(ae),offset:0,size:ae.descriptor.size}}else if(se._resourceType==="bufferResource"){const ae=se;oe={buffer:this._renderer.buffer.getGPUBuffer(ae.buffer),offset:ae.offset,size:ae.size}}else if(se._resourceType==="textureSampler"){const ae=se;oe=this._renderer.texture.getGpuSampler(ae)}else if(se._resourceType==="textureSource"){const ae=se;oe=this._renderer.texture.getGpuSource(ae).createView({})}re.push({binding:te[ne],resource:oe})}const ie=ee.createBindGroup({layout:K._gpuLayout.bindGroups[J],entries:re});return this._hash[X._key]=ie,ie}destroy(){for(const X of Object.keys(this._hash))this._hash[X]=null;this._hash=null,this._renderer=null}}BindGroupSystem.extension={type:[u$v.WebGPUSystem],name:"bindGroup"};class BufferSystem{constructor(){this._gpuBuffers=Object.create(null)}contextChange(X){this._gpu=X}getGPUBuffer(X){return this._gpuBuffers[X.uid]||this.createGPUBuffer(X)}updateBuffer(X){const K=this._gpuBuffers[X.uid]||this.createGPUBuffer(X);return X._updateID&&X.data&&(X._updateID=0,this._gpu.device.queue.writeBuffer(K,0,X.data.buffer,0,X._updateSize)),K}destroyAll(){for(const X in this._gpuBuffers)this._gpuBuffers[X].destroy();this._gpuBuffers={}}createGPUBuffer(X){const K=this._gpu.device.createBuffer(X.descriptor);return X._updateID=0,X.data&&(fastCopy(X.data.buffer,K.getMappedRange()),K.unmap()),this._gpuBuffers[X.uid]=K,X.on("update",this.updateBuffer,this),X.on("change",this.onBufferChange,this),X.on("destroy",this.onBufferDestroy,this),K}onBufferChange(X){let K=this._gpuBuffers[X.uid];K.destroy(),K=this.createGPUBuffer(X),X._updateID=0}onBufferDestroy(X){this._gpuBuffers[X.uid].destroy(),this._gpuBuffers[X.uid]=null}destroy(){for(const X of Object.keys(this._gpuBuffers)){const K=Number(X);this._gpuBuffers[K].destroy(),this._gpuBuffers[K]=null}this._gpuBuffers=null}}BufferSystem.extension={type:[u$v.WebGPUSystem],name:"buffer"};function GpuReadBuffer(Z,X){const K=Z.descriptor.size,J=X.gpu.device,Q=new Buffer({data:new Float32Array(24e5),usage:BufferUsage.MAP_READ|BufferUsage.COPY_DST}),ee=X.buffer.createGPUBuffer(Q),te=J.createCommandEncoder();te.copyBufferToBuffer(X.buffer.getGPUBuffer(Z),0,ee,0,K),J.queue.submit([te.finish()]),ee.mapAsync(GPUMapMode.READ,0,K).then(()=>{ee.getMappedRange(0,K),ee.unmap()})}class UniformBufferBatch{constructor({minUniformOffsetAlignment:X}){this._minUniformOffsetAlignment=256,this.byteIndex=0,this._minUniformOffsetAlignment=X,this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(X){if(X>this._minUniformOffsetAlignment/4)throw new Error(`UniformBufferBatch: array is too large: ${X*4}`);const K=this.byteIndex;let J=K+X*4;if(J=Math.ceil(J/this._minUniformOffsetAlignment)*this._minUniformOffsetAlignment,J>this.data.length*4)throw new Error("UniformBufferBatch: ubo batch got too big");return this.byteIndex=J,K}addGroup(X){const K=this.addEmptyGroup(X.length);for(let J=0;J<X.length;J++)this.data[K/4+J]=X[J];return K}destroy(){this._buffer.destroy(),this._buffer=null,this.data=null}}class GpuColorMaskSystem{constructor(X){this._colorMaskCache=15,this._renderer=X}setMask(X){this._colorMaskCache!==X&&(this._colorMaskCache=X,this._renderer.pipeline.setColorMask(X))}destroy(){this._renderer=null,this._colorMaskCache=null}}GpuColorMaskSystem.extension={type:[u$v.WebGPUSystem],name:"colorMask"};class GpuDeviceSystem{constructor(X){this._renderer=X}async init(X){return this._initPromise?this._initPromise:(this._initPromise=this._createDeviceAndAdaptor(X).then(K=>{this.gpu=K,this._renderer.runners.contextChange.emit(this.gpu)}),this._initPromise)}contextChange(X){this._renderer.gpu=X}async _createDeviceAndAdaptor(X){const K=await navigator.gpu.requestAdapter({powerPreference:X.powerPreference,forceFallbackAdapter:X.forceFallbackAdapter}),J=["texture-compression-bc","texture-compression-astc","texture-compression-etc2"].filter(ee=>K.features.has(ee)),Q=await K.requestDevice({requiredFeatures:J});return{adapter:K,device:Q}}destroy(){this.gpu=null,this._renderer=null}}GpuDeviceSystem.extension={type:[u$v.WebGPUSystem],name:"device"},GpuDeviceSystem.defaultOptions={powerPreference:void 0,forceFallbackAdapter:!1};var c$2=Object.defineProperty,p$7=Object.getOwnPropertySymbols,m$3=Object.prototype.hasOwnProperty,l$5=Object.prototype.propertyIsEnumerable,h$5=(Z,X,K)=>X in Z?c$2(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,u$3=(Z,X)=>{for(var K in X||(X={}))m$3.call(X,K)&&h$5(Z,K,X[K]);if(p$7)for(var K of p$7(X))l$5.call(X,K)&&h$5(Z,K,X[K]);return Z};class GpuEncoderSystem{constructor(X){this._boundBindGroup=Object.create(null),this._boundVertexBuffer=Object.create(null),this._renderer=X}renderStart(){this.commandFinished=new Promise(X=>{this._resolveCommandFinished=X}),this.commandEncoder=this._renderer.gpu.device.createCommandEncoder()}beginRenderPass(X){this.endRenderPass(),this._clearCache(),this.renderPassEncoder=this.commandEncoder.beginRenderPass(X.descriptor)}endRenderPass(){this.renderPassEncoder&&this.renderPassEncoder.end(),this.renderPassEncoder=null}setViewport(X){this.renderPassEncoder.setViewport(X.x,X.y,X.width,X.height,0,1)}setPipelineFromGeometryProgramAndState(X,K,J,Q){const ee=this._renderer.pipeline.getPipeline(X,K,J,Q);this.setPipeline(ee)}setPipeline(X){this._boundPipeline!==X&&(this._boundPipeline=X,this.renderPassEncoder.setPipeline(X))}_setVertexBuffer(X,K){this._boundVertexBuffer[X]!==K&&(this._boundVertexBuffer[X]=K,this.renderPassEncoder.setVertexBuffer(X,this._renderer.buffer.updateBuffer(K)))}_setIndexBuffer(X){this._boundIndexBuffer!==X&&(this._boundIndexBuffer=X,this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(X),"uint32"))}setBindGroup(X,K,J){if(this._boundBindGroup[X]===K)return;this._boundBindGroup[X]=K,K._touch(this._renderer.textureGC.count);const Q=this._renderer.bindGroup.getBindGroup(K,J,X);this.renderPassEncoder.setBindGroup(X,Q)}setGeometry(X){for(const K in X.attributes){const J=X.attributes[K];this._setVertexBuffer(J.shaderLocation,J.buffer)}X.indexBuffer&&this._setIndexBuffer(X.indexBuffer)}_setShaderBindGroups(X,K){for(const J in X.groups){const Q=X.groups[J];K||this._syncBindGroup(Q),this.setBindGroup(J,Q,X.gpuProgram)}}_syncBindGroup(X){for(const K in X.resources){const J=X.resources[K];J.isUniformGroup&&this._renderer.uniformBuffer.updateUniformGroup(J)}}draw(X){const{geometry:K,shader:J,state:Q,topology:ee,size:te,start:re,instanceCount:ie,skipSync:ne}=X;this.setPipelineFromGeometryProgramAndState(K,J.gpuProgram,Q,ee),this.setGeometry(K),this._setShaderBindGroups(J,ne),K.indexBuffer?this.renderPassEncoder.drawIndexed(te||K.indexBuffer.data.length,ie||1,re||0):this.renderPassEncoder.draw(te||K.getSize(),ie||1,re||0)}finishRenderPass(){this.renderPassEncoder&&(this.renderPassEncoder.end(),this.renderPassEncoder=null)}postrender(){this.finishRenderPass(),this._gpu.device.queue.submit([this.commandEncoder.finish()]),this._resolveCommandFinished()}restoreRenderPass(){const X=this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget,!1,[0,0,0,1]);this.renderPassEncoder=this.commandEncoder.beginRenderPass(X);const K=this._boundPipeline,J=u$3({},this._boundVertexBuffer),Q=this._boundIndexBuffer,ee=u$3({},this._boundBindGroup);this._clearCache();const te=this._renderer.renderTarget.viewport;this.renderPassEncoder.setViewport(te.x,te.y,te.width,te.height,0,1),this.setPipeline(K);for(const re in J)this._setVertexBuffer(re,J[re]);for(const re in ee)this.setBindGroup(re,ee[re],null);this._setIndexBuffer(Q)}_clearCache(){for(let X=0;X<16;X++)this._boundBindGroup[X]=null,this._boundVertexBuffer[X]=null;this._boundIndexBuffer=null,this._boundPipeline=null}destroy(){this._renderer=null,this._gpu=null,this._boundBindGroup=null,this._boundVertexBuffer=null,this._boundIndexBuffer=null,this._boundPipeline=null}contextChange(X){this._gpu=X}}GpuEncoderSystem.extension={type:[u$v.WebGPUSystem],name:"encoder",priority:1};class GpuStencilSystem{constructor(X){this._renderTargetStencilState=Object.create(null),this._renderer=X,X.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(X){let K=this._renderTargetStencilState[X.uid];K||(K=this._renderTargetStencilState[X.uid]={stencilMode:STENCIL_MODES.DISABLED,stencilReference:0}),this._activeRenderTarget=X,this.setStencilMode(K.stencilMode,K.stencilReference)}setStencilMode(X,K){const J=this._renderTargetStencilState[this._activeRenderTarget.uid];J.stencilMode=X,J.stencilReference=K;const Q=this._renderer;Q.pipeline.setStencilMode(X),Q.encoder.renderPassEncoder.setStencilReference(K)}destroy(){this._renderer.renderTarget.onRenderTargetChange.remove(this),this._renderer=null,this._activeRenderTarget=null,this._renderTargetStencilState=null}}GpuStencilSystem.extension={type:[u$v.WebGPUSystem],name:"stencil"};const s$7=128;class GpuUniformBatchPipe{constructor(X){this._bindGroupHash=Object.create(null),this._buffers=[],this._bindGroups=[],this._bufferResources=[],this._renderer=X,this._batchBuffer=new UniformBufferBatch({minUniformOffsetAlignment:s$7});const K=256/s$7;for(let J=0;J<K;J++){let Q=BufferUsage.UNIFORM|BufferUsage.COPY_DST;J===0&&(Q|=BufferUsage.COPY_SRC),this._buffers.push(new Buffer({data:this._batchBuffer.data,usage:Q}))}}renderEnd(){this._uploadBindGroups(),this._resetBindGroups()}_resetBindGroups(){for(const X in this._bindGroupHash)this._bindGroupHash[X]=null;this._batchBuffer.clear()}getUniformBindGroup(X,K){if(!K&&this._bindGroupHash[X.uid])return this._bindGroupHash[X.uid];this._renderer.uniformBuffer.ensureUniformGroup(X);const J=X.buffer.data,Q=this._batchBuffer.addEmptyGroup(J.length);return this._renderer.uniformBuffer.syncUniformGroup(X,this._batchBuffer.data,Q/4),this._bindGroupHash[X.uid]=this._getBindGroup(Q/s$7),this._bindGroupHash[X.uid]}getUniformBufferResource(X){this._renderer.uniformBuffer.updateUniformGroup(X);const K=X.buffer.data,J=this._batchBuffer.addGroup(K);return this._getBufferResource(J/s$7)}getArrayBindGroup(X){const K=this._batchBuffer.addGroup(X);return this._getBindGroup(K/s$7)}getArrayBufferResource(X){const K=this._batchBuffer.addGroup(X)/s$7;return this._getBufferResource(K)}_getBufferResource(X){if(!this._bufferResources[X]){const K=this._buffers[X%2];this._bufferResources[X]=new BufferResource({buffer:K,offset:(X/2|0)*256,size:s$7})}return this._bufferResources[X]}_getBindGroup(X){if(!this._bindGroups[X]){const K=new BindGroup({0:this._getBufferResource(X)});this._bindGroups[X]=K}return this._bindGroups[X]}_uploadBindGroups(){const X=this._renderer.buffer,K=this._buffers[0];K.update(this._batchBuffer.byteIndex),X.updateBuffer(K);const J=this._renderer.gpu.device.createCommandEncoder();for(let Q=1;Q<this._buffers.length;Q++){const ee=this._buffers[Q];J.copyBufferToBuffer(X.getGPUBuffer(K),s$7,X.getGPUBuffer(ee),0,this._batchBuffer.byteIndex)}this._renderer.gpu.device.queue.submit([J.finish()])}destroy(){for(let X=0;X<this._bindGroups.length;X++)this._bindGroups[X].destroy();this._bindGroups=null,this._bindGroupHash=null;for(let X=0;X<this._buffers.length;X++)this._buffers[X].destroy();this._buffers=null;for(let X=0;X<this._bufferResources.length;X++)this._bufferResources[X].destroy();this._bufferResources=null,this._batchBuffer.destroy(),this._bindGroupHash=null,this._renderer=null}}GpuUniformBatchPipe.extension={type:[u$v.WebGPUPipes],name:"uniformBatch"};const h$4={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};function f$4(Z,X,K,J,Q,ee,te,re){return Z<<26|X<<18|te<<14|K<<8|J<<3|re<<1|Q<<4|ee}class PipelineSystem{constructor(X){this._moduleCache=Object.create(null),this._bufferLayoutsCache=Object.create(null),this._pipeCache=Object.create(null),this._colorMask=15,this._multisampleCount=1,this._renderer=X}contextChange(X){this._gpu=X,this.setStencilMode(STENCIL_MODES.DISABLED)}setMultisampleCount(X){this._multisampleCount=X}setColorMask(X){this._colorMask=X}setStencilMode(X){this._stencilMode=X,this._stencilState=GpuStencilModesToPixi[X]}setPipeline(X,K,J,Q){const ee=this.getPipeline(X,K,J);Q.setPipeline(ee)}getPipeline(X,K,J,Q){X._layoutKey||this._generateBufferKey(X),K._layoutKey||(this._generateProgramKey(K),this._renderer.shader.createProgramLayout(K)),Q=Q||X.topology;const ee=f$4(X._layoutKey,K._layoutKey,J.data,J._blendModeId,this._stencilMode,this._multisampleCount,this._colorMask,h$4[Q]);return this._pipeCache[ee]?this._pipeCache[ee]:(this._pipeCache[ee]=this._createPipeline(X,K,J,Q),this._pipeCache[ee])}_createPipeline(X,K,J,Q){const ee=this._gpu.device,te=this._createVertexBufferLayouts(X),re=this._renderer.state.getColorTargets(J);let ie=this._stencilState;ie=GpuStencilModesToPixi[this._stencilMode],re[0].writeMask=this._stencilMode===STENCIL_MODES.RENDERING_MASK_ADD?0:this._colorMask;const ne={vertex:{module:this._getModule(K.vertex.source),entryPoint:K.vertex.entryPoint,buffers:te},fragment:{module:this._getModule(K.fragment.source),entryPoint:K.fragment.entryPoint,targets:re},primitive:{topology:Q,cullMode:J.cullMode},layout:K._gpuLayout.pipeline,multisample:{count:this._multisampleCount},depthStencil:ie,label:"PIXI Pipeline"};return ee.createRenderPipeline(ne)}_getModule(X){return this._moduleCache[X]||this._createModule(X)}_createModule(X){const K=this._gpu.device;return this._moduleCache[X]=K.createShaderModule({code:X}),this._moduleCache[X]}_generateProgramKey(X){const{vertex:K,fragment:J}=X,Q=K.source+J.source+K.entryPoint+J.entryPoint;return X._layoutKey=createIdFromString(Q,"program"),X._layoutKey}_generateBufferKey(X){const K=[];let J=0;const Q=Object.keys(X.attributes).sort();for(let te=0;te<Q.length;te++){const re=X.attributes[Q[te]];K[J++]=re.shaderLocation,K[J++]=re.offset,K[J++]=re.format,K[J++]=re.stride}const ee=K.join("");return X._layoutKey=createIdFromString(ee,"geometry"),X._layoutKey}_createVertexBufferLayouts(X){if(this._bufferLayoutsCache[X._layoutKey])return this._bufferLayoutsCache[X._layoutKey];const K=[];return X.buffers.forEach(J=>{const Q={arrayStride:0,stepMode:"vertex",attributes:[]},ee=Q.attributes;for(const te in X.attributes){const re=X.attributes[te];re.buffer===J&&(Q.arrayStride=re.stride,ee.push({shaderLocation:re.shaderLocation,offset:re.offset,format:re.format}))}ee.length&&K.push(Q)}),this._bufferLayoutsCache[X._layoutKey]=K,K}destroy(){this._renderer=null,this._bufferLayoutsCache=null}}PipelineSystem.extension={type:[u$v.WebGPUSystem],name:"pipeline"};class GpuRenderTarget{constructor(){this.contexts=[],this.msaaTextures=[],this.msaaSamples=1}}class GpuRenderTargetAdaptor{init(X,K){this._renderer=X,this._renderTargetSystem=K}copyToTexture(X,K,J,Q){const ee=this._renderer,te=this._getGpuColorTexture(X),re=ee.texture.getGpuSource(K.source);return ee.encoder.commandEncoder.copyTextureToTexture({texture:te,origin:J},{texture:re},Q),K}startRenderPass(X,K=!0,J,Q){const ee=this._renderTargetSystem.getGpuRenderTarget(X),te=this.getDescriptor(X,K,J);ee.descriptor=te,this._renderer.encoder.beginRenderPass(ee),this._renderer.encoder.setViewport(Q),this._renderer.pipeline.setMultisampleCount(ee.msaaSamples)}finishRenderPass(){this._renderer.encoder.endRenderPass()}_getGpuColorTexture(X){const K=this._renderTargetSystem.getGpuRenderTarget(X);return K.contexts[0]?K.contexts[0].getCurrentTexture():this._renderer.texture.getGpuSource(X.colorTextures[0].source)}getDescriptor(X,K,J){typeof K=="boolean"&&(K=K?CLEAR.ALL:CLEAR.NONE);const Q=this._renderTargetSystem,ee=Q.getGpuRenderTarget(X),te=X.colorTextures.map((ie,ne)=>{const se=ee.contexts[ne];let oe,ae;se?oe=se.getCurrentTexture().createView():oe=this._renderer.texture.getTextureView(ie),ee.msaaTextures[ne]&&(ae=oe,oe=this._renderer.texture.getTextureView(ee.msaaTextures[ne]));const le=K&CLEAR.COLOR?"clear":"load";return J!=null||(J=Q.defaultClearColor),{view:oe,resolveTarget:ae,clearValue:J,storeOp:"store",loadOp:le}});let re;if(X.depthTexture){const ie=K&CLEAR.STENCIL?"clear":"load";re={view:this._renderer.texture.getGpuSource(X.depthTexture.source).createView(),stencilStoreOp:"store",stencilLoadOp:ie}}return{colorAttachments:te,depthStencilAttachment:re}}clear(X,K=!0,J,Q){this.startRenderPass(X,K,J,Q)}initGpuRenderTarget(X){X.isRoot=!0;const K=new GpuRenderTarget;return X.colorTextures.forEach((J,Q)=>{if(CanvasSource.test(J.resource)){const ee=X.colorTexture.resource.getContext("webgpu");try{ee.configure({device:this._renderer.gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode:"opaque"})}catch(te){console.error(te)}K.contexts[Q]=ee}if(K.msaa=J.source.antialias,J.source.antialias){const ee=new TextureSource({width:0,height:0,sampleCount:4});K.msaaTextures[Q]=ee}}),K.msaa&&(K.msaaSamples=4,X.depthTexture&&(X.depthTexture.source.sampleCount=4)),K}resizeGpuRenderTarget(X){const K=this._renderTargetSystem.getGpuRenderTarget(X);K.width=X.width,K.height=X.height,K.msaa&&X.colorTextures.forEach((J,Q)=>{const ee=K.msaaTextures[Q];ee==null||ee.resize(J.source.width,J.source.height,J.source._resolution)})}}class GpuRenderTargetSystem extends RenderTargetSystem{constructor(X){super(X),this.adaptor=new GpuRenderTargetAdaptor,this.adaptor.init(X,this)}}GpuRenderTargetSystem.extension={type:[u$v.WebGPUSystem],name:"renderTarget"};class GpuShaderSystem{contextChange(X){this._gpu=X}createProgramLayout(X){const K=this._gpu.device;if(!X._gpuLayout)if(X.gpuLayout){const J=X.gpuLayout.map(ee=>K.createBindGroupLayout({entries:ee})),Q={bindGroupLayouts:J};X._gpuLayout={bindGroups:J,pipeline:K.createPipelineLayout(Q)}}else X._gpuLayout={bindGroups:null,pipeline:"auto"}}destroy(){this._gpu=null}}GpuShaderSystem.extension={type:[u$v.WebGPUSystem],name:"shader"};const GpuBlendModesToPixi={};GpuBlendModesToPixi.normal={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}},GpuBlendModesToPixi.add={alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one",operation:"add"}},GpuBlendModesToPixi.multiply={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"dst",dstFactor:"one-minus-src-alpha",operation:"add"}},GpuBlendModesToPixi.screen={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},GpuBlendModesToPixi.overlay={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},GpuBlendModesToPixi.none={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"zero",operation:"add"}},GpuBlendModesToPixi["normal-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}},GpuBlendModesToPixi["add-npm"]={alpha:{srcFactor:"one",dstFactor:"one",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one",operation:"add"}},GpuBlendModesToPixi["screen-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src",operation:"add"}},GpuBlendModesToPixi.erase={alpha:{srcFactor:"zero",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"one-minus-src",operation:"add"}};class GpuStateSystem{constructor(){this.defaultState=new State,this.defaultState.blend=!0}contextChange(X){this.gpu=X}getColorTargets(X){return[{format:"bgra8unorm",writeMask:0,blend:GpuBlendModesToPixi[X.blendMode]||GpuBlendModesToPixi.normal}]}destroy(){this.gpu=null}}GpuStateSystem.extension={type:[u$v.WebGPUSystem],name:"state"};const gpuUploadBufferImageResource={type:"image",upload(Z,X,K){const J=Z.resource,Q=(Z.pixelWidth|0)*(Z.pixelHeight|0),ee=J.byteLength/Q;K.device.queue.writeTexture({texture:X},J,{offset:0,rowsPerImage:Z.pixelHeight,bytesPerRow:Z.pixelHeight*ee},{width:Z.pixelWidth,height:Z.pixelHeight,depthOrArrayLayers:1})}},blockDataMap={"bc1-rgba-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"bc2-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc3-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc7-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"etc1-rgb-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"etc2-rgba8unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"astc-4x4-unorm":{blockBytes:16,blockWidth:4,blockHeight:4}},s$6={blockBytes:4,blockWidth:1,blockHeight:1},gpuUploadCompressedTextureResource={type:"compressed",upload(Z,X,K){let J=Z.pixelWidth,Q=Z.pixelHeight;const ee=blockDataMap[Z.format]||s$6;for(let te=0;te<Z.resource.length;te++){const re=Z.resource[te],ie=Math.ceil(J/ee.blockWidth)*ee.blockBytes;K.device.queue.writeTexture({texture:X,mipLevel:te},re,{offset:0,bytesPerRow:ie},{width:Math.ceil(J/ee.blockWidth)*ee.blockWidth,height:Math.ceil(Q/ee.blockHeight)*ee.blockHeight,depthOrArrayLayers:1}),J=Math.max(J>>1,1),Q=Math.max(Q>>1,1)}}},gpuUploadImageResource={type:"image",upload(Z,X,K){const J=Z.resource;if(!J)return;const Q=Z.resourceWidth||Z.pixelWidth,ee=Z.resourceHeight||Z.pixelHeight,te=Z.alphaMode==="premultiply-alpha-on-upload";K.device.queue.copyExternalImageToTexture({source:J},{texture:X,premultipliedAlpha:te},{width:Q,height:ee})}},gpuUploadVideoResource={type:"video",upload(Z,X,K){gpuUploadImageResource.upload(Z,X,K)}};class GpuMipmapGenerator{constructor(X){this.device=X,this.sampler=X.createSampler({minFilter:"linear"}),this.pipelines={}}_getMipmapPipeline(X){let K=this.pipelines[X];return K||(this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:`
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `})),K=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format:X}]}}),this.pipelines[X]=K),K}generateMipmap(X){const K=this._getMipmapPipeline(X.format);if(X.dimension==="3d"||X.dimension==="1d")throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let J=X;const Q=X.depthOrArrayLayers||1,ee=X.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!ee){const ie={size:{width:Math.ceil(X.width/2),height:Math.ceil(X.height/2),depthOrArrayLayers:Q},format:X.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:X.mipLevelCount-1};J=this.device.createTexture(ie)}const te=this.device.createCommandEncoder({}),re=K.getBindGroupLayout(0);for(let ie=0;ie<Q;++ie){let ne=X.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:ie,arrayLayerCount:1}),se=ee?1:0;for(let oe=1;oe<X.mipLevelCount;++oe){const ae=J.createView({baseMipLevel:se++,mipLevelCount:1,dimension:"2d",baseArrayLayer:ie,arrayLayerCount:1}),le=te.beginRenderPass({colorAttachments:[{view:ae,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0}}]}),ce=this.device.createBindGroup({layout:re,entries:[{binding:0,resource:this.sampler},{binding:1,resource:ne}]});le.setPipeline(K),le.setBindGroup(0,ce),le.draw(3,1,0,0),le.end(),ne=ae}}if(!ee){const ie={width:Math.ceil(X.width/2),height:Math.ceil(X.height/2),depthOrArrayLayers:Q};for(let ne=1;ne<X.mipLevelCount;++ne)te.copyTextureToTexture({texture:J,mipLevel:ne-1},{texture:X,mipLevel:ne},ie),ie.width=Math.ceil(ie.width/2),ie.height=Math.ceil(ie.height/2)}return this.device.queue.submit([te.finish()]),ee||J.destroy(),X}}class GpuTextureSystem{constructor(X){this.managedTextures=[],this._gpuSources=Object.create(null),this._gpuSamplers=Object.create(null),this._bindGroupHash=Object.create(null),this._textureViewHash=Object.create(null),this._uploads={image:gpuUploadImageResource,buffer:gpuUploadBufferImageResource,video:gpuUploadVideoResource,compressed:gpuUploadCompressedTextureResource},this._renderer=X}contextChange(X){this._gpu=X}initSource(X){if(X.autoGenerateMipmaps){const ie=Math.max(X.pixelWidth,X.pixelHeight);X.mipLevelCount=Math.floor(Math.log2(ie))+1}let K=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;X.uploadMethodId!=="compressed"&&(K|=GPUTextureUsage.RENDER_ATTACHMENT,K|=GPUTextureUsage.COPY_SRC);const J=blockDataMap[X.format]||{blockBytes:4,blockWidth:1,blockHeight:1},Q=Math.ceil(X.pixelWidth/J.blockWidth)*J.blockWidth,ee=Math.ceil(X.pixelHeight/J.blockHeight)*J.blockHeight,te={label:X.label,size:{width:Q,height:ee},format:X.format,sampleCount:X.sampleCount,mipLevelCount:X.mipLevelCount,dimension:X.dimension,usage:K},re=this._gpu.device.createTexture(te);return this._gpuSources[X.uid]=re,X.on("update",this.onSourceUpdate,this),X.on("resize",this.onSourceResize,this),X.on("destroy",this.onSourceDestroy,this),X.on("unload",this.onSourceUnload,this),this.managedTextures.push(X),this.onSourceUpdate(X),re}onSourceUpdate(X){const K=this.getGpuSource(X);K&&(this._uploads[X.uploadMethodId]&&this._uploads[X.uploadMethodId].upload(X,K,this._gpu),X.autoGenerateMipmaps&&X.mipLevelCount>1&&(this._mipmapGenerator||(this._mipmapGenerator=new GpuMipmapGenerator(this._gpu.device)),this._mipmapGenerator.generateMipmap(K)))}onSourceUnload(X){const K=this._gpuSources[X.uid];K&&(this._gpuSources[X.uid]=null,K.destroy())}onSourceDestroy(X){X.off("update",this.onSourceUpdate,this),X.off("unload",this.onSourceUnload,this),X.off("destroy",this.onSourceDestroy,this),X.off("resize",this.onSourceResize,this),this.managedTextures.splice(this.managedTextures.indexOf(X),1),this.onSourceUnload(X)}onSourceResize(X){const K=this._gpuSources[X.uid];(K.width!==X.pixelWidth||K.height!==X.pixelHeight)&&(this._textureViewHash[X.uid]=null,this._bindGroupHash[X.uid]=null,this.onSourceUnload(X),this.initSource(X))}_initSampler(X){return this._gpuSamplers[X._resourceId]=this._gpu.device.createSampler(X),this._gpuSamplers[X._resourceId]}getGpuSampler(X){return this._gpuSamplers[X._resourceId]||this._initSampler(X)}getGpuSource(X){return this._gpuSources[X.uid]||this.initSource(X)}getTextureBindGroup(X){var K;return(K=this._bindGroupHash[X.id])!=null?K:this._createTextureBindGroup(X)}_createTextureBindGroup(X){const K=X.source,J=K.uid;return this._bindGroupHash[J]=new BindGroup({0:K,1:K.style}),this._bindGroupHash[J]}getTextureView(X){var K;const J=X.source;return(K=this._textureViewHash[J.uid])!=null?K:this._createTextureView(J)}_createTextureView(X){return this._textureViewHash[X.uid]=this.getGpuSource(X).createView(),this._textureViewHash[X.uid]}generateCanvas(X){const K=this._renderer,J=K.gpu.device.createCommandEncoder(),Q=DOMAdapter.get().createCanvas();Q.width=X.source.pixelWidth,Q.height=X.source.pixelHeight;const ee=Q.getContext("webgpu");return ee.configure({device:K.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:navigator.gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"}),J.copyTextureToTexture({texture:K.texture.getGpuSource(X.source),origin:{x:0,y:0}},{texture:ee.getCurrentTexture()},{width:Q.width,height:Q.height}),K.gpu.device.queue.submit([J.finish()]),Q}getPixels(X){const K=this.generateCanvas(X),J=CanvasPool.getOptimalCanvasAndContext(K.width,K.height),Q=J.context;Q.drawImage(K,0,0);const{width:ee,height:te}=K,re=Q.getImageData(0,0,ee,te),ie=new Uint8ClampedArray(re.data.buffer);return CanvasPool.returnCanvasAndContext(J),{pixels:ie,width:ee,height:te}}destroy(){this.managedTextures.slice().forEach(X=>this.onSourceDestroy(X)),this.managedTextures=null;for(const X of Object.keys(this._bindGroupHash)){const K=Number(X),J=this._bindGroupHash[K];J==null||J.destroy(),this._bindGroupHash[K]=null}this._gpu=null,this._mipmapGenerator=null,this._gpuSources=null,this._bindGroupHash=null,this._textureViewHash=null,this._gpuSamplers=null}}GpuTextureSystem.extension={type:[u$v.WebGPUSystem],name:"texture"};class GpuGraphicsAdaptor{init(){const X=new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),K=compileHighShaderGpuProgram({name:"graphics",bits:[colorBit,generateTextureBatchBit(MAX_TEXTURES),localUniformBitGroup2,roundPixelsBit]});this.shader=new Shader({gpuProgram:K,resources:{localUniforms:X}}),this.shader.addResource("globalUniforms",0,0)}execute(X,K){const J=K.view.context,Q=J.customShader||this.shader,ee=X.renderer,te=ee.graphicsContext,{geometry:re,instructions:ie}=te.getContextRenderData(J),ne=ee.encoder;ne.setPipelineFromGeometryProgramAndState(re,Q.gpuProgram,X.state),ne.setGeometry(re);const se=ee.globalUniforms.bindGroup;ne.setBindGroup(0,se,Q.gpuProgram);const oe=ee.renderPipes.uniformBatch.getUniformBindGroup(Q.resources.localUniforms,!0);ne.setBindGroup(2,oe,Q.gpuProgram);const ae=ie.instructions;for(let le=0;le<ie.instructionSize;le++){const ce=ae[le];if(Q.groups[1]=ce.bindGroup,!ce.gpuBindGroup){const de=ce.textures;ce.bindGroup=getTextureBatchBindGroup(de.textures,de.count),ce.gpuBindGroup=ee.bindGroup.getBindGroup(ce.bindGroup,Q.gpuProgram,1)}ne.setBindGroup(1,ce.bindGroup,Q.gpuProgram),ne.renderPassEncoder.drawIndexed(ce.size,1,ce.start)}}destroy(){this.shader.destroy(!0),this.shader=null}}GpuGraphicsAdaptor.extension={type:[u$v.WebGPUPipesAdaptor],name:"graphics"};class GpuMeshAdapter{init(){const X=compileHighShaderGpuProgram({name:"mesh",bits:[localUniformBit,textureBit,roundPixelsBit]});this._shader=new Shader({gpuProgram:X,resources:{uTexture:Texture.EMPTY._source,uSampler:Texture.EMPTY._source.style}})}execute(X,K){const J=X.renderer,Q=K.view;let ee=Q._shader;ee||(ee=this._shader,ee.groups[2]=J.texture.getTextureBindGroup(Q.texture)),ee.groups[0]=J.globalUniforms.bindGroup;const te=X.localUniforms;ee.groups[1]=J.renderPipes.uniformBatch.getUniformBindGroup(te,!0),J.encoder.draw({geometry:Q._geometry,shader:ee,state:Q.state})}destroy(){this._shader.destroy(!0),this._shader=null}}GpuMeshAdapter.extension={type:[u$v.WebGPUPipesAdaptor],name:"mesh"};const T$2=[...SharedSystems,GpuEncoderSystem,GpuDeviceSystem,BufferSystem,GpuTextureSystem,GpuRenderTargetSystem,GpuShaderSystem,GpuStateSystem,PipelineSystem,GpuColorMaskSystem,GpuStencilSystem,BindGroupSystem],v$1=[...SharedRenderPipes,GpuUniformBatchPipe],C=[GpuBatchAdaptor,GpuMeshAdapter,GpuGraphicsAdaptor],s$5=[],r=[],i=[];b$p.handleByNamedList(u$v.WebGPUSystem,s$5),b$p.handleByNamedList(u$v.WebGPUPipes,r),b$p.handleByNamedList(u$v.WebGPUPipesAdaptor,i),b$p.add(...T$2,...v$1,...C);class WebGPURenderer extends AbstractRenderer{constructor(){const X={name:"webgpu",type:RendererType.WEBGPU,systems:s$5,renderPipes:r,renderPipeAdaptors:i};super(X)}}var WebGPURenderer$1={__proto__:null,WebGPURenderer};const o$4={POINTS:"point-list",LINES:"line-list",LINE_STRIP:"line-strip",TRIANGLES:"triangle-list",TRIANGLE_STRIP:"triangle-strip"},DRAW_MODES=new Proxy(o$4,{get(Z,X){return deprecation(v8_0_0,`DRAW_MODES.${X} is deprecated, use '${X}' instead`),Z[X]}}),n$4=new Rectangle(0,0,1,1);function viewportFromFrame(Z,X,K){K||(K=n$4);const J=X.pixelWidth,Q=X.pixelHeight;return Z.x=K.x*J|0,Z.y=K.y*Q|0,Z.width=K.width*J|0,Z.height=K.height*Q|0,Z}const GLSL_TO_STD40_SIZE={float:4,vec2:8,vec3:12,vec4:16,int:4,ivec2:8,ivec3:12,ivec4:16,uint:4,uvec2:8,uvec3:12,uvec4:16,bool:4,bvec2:8,bvec3:12,bvec4:16,mat2:32,mat3:48,mat4:64};var MSAA_QUALITY=(Z=>(Z[Z.NONE=0]="NONE",Z[Z.LOW=2]="LOW",Z[Z.MEDIUM=4]="MEDIUM",Z[Z.HIGH=8]="HIGH",Z))(MSAA_QUALITY||{}),DEPRECATED_WRAP_MODES=(Z=>(Z.CLAMP="clamp-to-edge",Z.REPEAT="repeat",Z.MIRRORED_REPEAT="mirror-repeat",Z))(DEPRECATED_WRAP_MODES||{});const WRAP_MODES=new Proxy(DEPRECATED_WRAP_MODES,{get(Z,X){return deprecation(v8_0_0,`DRAW_MODES.${X} is deprecated, use '${X}' instead`),Z[X]}});var DEPRECATED_SCALE_MODES=(Z=>(Z.NEAREST="nearest",Z.LINEAR="linear",Z))(DEPRECATED_SCALE_MODES||{});const SCALE_MODES=new Proxy(DEPRECATED_SCALE_MODES,{get(Z,X){return deprecation(v8_0_0,`DRAW_MODES.${X} is deprecated, use '${X}' instead`),Z[X]}});class TextureUvs{constructor(){this.x0=0,this.y0=0,this.x1=1,this.y1=0,this.x2=1,this.y2=1,this.x3=0,this.y3=1,this.uvsFloat32=new Float32Array(8)}set(X,K,J){const Q=K.width,ee=K.height;if(J){const te=X.width/2/Q,re=X.height/2/ee,ie=X.x/Q+te,ne=X.y/ee+re;J=groupD8.add(J,groupD8.NW),this.x0=ie+te*groupD8.uX(J),this.y0=ne+re*groupD8.uY(J),J=groupD8.add(J,2),this.x1=ie+te*groupD8.uX(J),this.y1=ne+re*groupD8.uY(J),J=groupD8.add(J,2),this.x2=ie+te*groupD8.uX(J),this.y2=ne+re*groupD8.uY(J),J=groupD8.add(J,2),this.x3=ie+te*groupD8.uX(J),this.y3=ne+re*groupD8.uY(J)}else this.x0=X.x/Q,this.y0=X.y/ee,this.x1=(X.x+X.width)/Q,this.y1=X.y/ee,this.x2=(X.x+X.width)/Q,this.y2=(X.y+X.height)/ee,this.x3=X.x/Q,this.y3=(X.y+X.height)/ee;this.uvsFloat32[0]=this.x0,this.uvsFloat32[1]=this.y0,this.uvsFloat32[2]=this.x1,this.uvsFloat32[3]=this.y1,this.uvsFloat32[4]=this.x2,this.uvsFloat32[5]=this.y2,this.uvsFloat32[6]=this.x3,this.uvsFloat32[7]=this.y3}}let e=0;function generateUID(){return e++}function multiplyHexColors(Z,X){if(Z===16777215||!X)return X;if(X===16777215||!Z)return Z;const K=Z>>16&255,J=Z>>8&255,Q=Z&255,ee=X>>16&255,te=X>>8&255,re=X&255,ie=K*ee/255,ne=J*te/255,se=Q*re/255;return(ie<<16)+(ne<<8)+se}function updateWorldTransform(Z,X,K){const J=Z.a,Q=Z.b,ee=Z.c,te=Z.d,re=Z.tx,ie=Z.ty,ne=X.a,se=X.b,oe=X.c,ae=X.d;K.a=J*ne+Q*oe,K.b=J*se+Q*ae,K.c=ee*ne+te*oe,K.d=ee*se+te*ae,K.tx=re*ne+ie*oe+X.tx,K.ty=re*se+ie*ae+X.ty}var p$6=Object.defineProperty,a$3=Object.getOwnPropertySymbols,l$4=Object.prototype.hasOwnProperty,c$1=Object.prototype.propertyIsEnumerable,o$3=(Z,X,K)=>X in Z?p$6(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,h$3=(Z,X)=>{for(var K in X||(X={}))l$4.call(X,K)&&o$3(Z,K,X[K]);if(a$3)for(var K of a$3(X))c$1.call(X,K)&&o$3(Z,K,X[K]);return Z},u$2=(Z,X)=>{var K={};for(var J in Z)l$4.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&a$3)for(var J of a$3(Z))X.indexOf(J)<0&&c$1.call(Z,J)&&(K[J]=Z[J]);return K};class Graphics extends Container{constructor(X){X instanceof GraphicsContext&&(X={context:X});const K=X||{},{context:J}=K,Q=u$2(K,["context"]);super(h$3({view:new GraphicsView(J),label:"Graphics"},Q)),this.allowChildren=!1}get context(){return this.view.context}set context(X){this.view.context=X}_callContextMethod(X,K){return this.view.context[X](...K),this}fill(...X){return this._callContextMethod("fill",X)}stroke(...X){return this._callContextMethod("stroke",X)}texture(...X){return this._callContextMethod("texture",X)}beginPath(){return this._callContextMethod("beginPath",[])}cut(...X){return this._callContextMethod("cut",X)}arc(...X){return this._callContextMethod("arc",X)}arcTo(...X){return this._callContextMethod("arcTo",X)}arcToSvg(...X){return this._callContextMethod("arcToSvg",X)}bezierCurveTo(...X){return this._callContextMethod("bezierCurveTo",X)}closePath(...X){return this._callContextMethod("closePath",X)}ellipse(...X){return this._callContextMethod("ellipse",X)}circle(...X){return this._callContextMethod("circle",X)}path(...X){return this._callContextMethod("path",X)}lineTo(...X){return this._callContextMethod("lineTo",X)}moveTo(...X){return this._callContextMethod("moveTo",X)}quadraticCurveTo(...X){return this._callContextMethod("quadraticCurveTo",X)}rect(...X){return this._callContextMethod("rect",X)}roundRect(...X){return this._callContextMethod("roundRect",X)}poly(...X){return this._callContextMethod("poly",X)}regularPoly(...X){return this._callContextMethod("regularPoly",X)}roundPoly(...X){return this._callContextMethod("roundPoly",X)}roundShape(...X){return this._callContextMethod("roundShape",X)}filletRect(...X){return this._callContextMethod("filletRect",X)}chamferRect(...X){return this._callContextMethod("chamferRect",X)}star(...X){return this._callContextMethod("star",X)}svg(...X){return this._callContextMethod("svg",X)}restore(...X){return this._callContextMethod("restore",X)}save(...X){return this._callContextMethod("save",X)}getTransform(...X){return this._callContextMethod("getTransform",X)}resetTransform(...X){return this._callContextMethod("resetTransform",X)}rotateTransform(...X){return this._callContextMethod("rotate",X)}scaleTransform(...X){return this._callContextMethod("scale",X)}setTransform(...X){return this._callContextMethod("setTransform",X)}transform(...X){return this._callContextMethod("transform",X)}translateTransform(...X){return this._callContextMethod("translate",X)}clear(...X){return this._callContextMethod("clear",X)}get fillStyle(){return this.view.context.fillStyle}set fillStyle(X){this.view.context.fillStyle=X}get strokeStyle(){return this.view.context.strokeStyle}set strokeStyle(X){this.view.context.strokeStyle=X}beginFill(X,K){return deprecation("8.0.0","Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."),this.endFill(),this.context.fillStyle={color:X,alpha:K},this}endFill(){return deprecation("8.0.0","Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."),this.context.fill(),this}drawCircle(...X){return deprecation("8.0.0","Graphics#drawCircle has been renamed to Graphics#circle"),this._callContextMethod("circle",X)}drawEllipse(...X){return deprecation("8.0.0","Graphics#drawEllipse has been renamed to Graphics#ellipse"),this._callContextMethod("ellipse",X)}drawPolygon(...X){return deprecation("8.0.0","Graphics#drawPolygon has been renamed to Graphics#poly"),this._callContextMethod("poly",X)}drawRect(...X){return deprecation("8.0.0","Graphics#drawRect has been renamed to Graphics#rect"),this._callContextMethod("rect",X)}drawRoundedRect(...X){return deprecation("8.0.0","Graphics#drawRoundedRect has been renamed to Graphics#roundRect"),this._callContextMethod("roundRect",X)}drawStar(...X){return deprecation("8.0.0","Graphics#drawStar has been renamed to Graphics#star"),this._callContextMethod("star",X)}get roundPixels(){return!!this.view.roundPixels}set roundPixels(X){this.view.roundPixels=X?1:0}}const P$2={rectangle:buildRectangle,polygon:buildPolygon,triangle:buildTriangle,circle:buildCircle,ellipse:buildCircle,roundedRectangle:buildCircle};function buildGeometryFromPath(Z){const X=[],K=[],J=[],Q=Z.path.shapePath,ee=Z.textureMatrix;Q.shapePrimitives.forEach(({shape:re,transform:ie})=>{const ne=J.length,se=X.length/2,oe=[],ae=P$2[re.type];ae.build(re,oe),ie&&transformVertices(oe,ie),ae.triangulate(oe,X,2,se,J,ne);const le=K.length/2;ee?(ie&&ee.append(ie.clone().invert()),buildUvs(X,2,se,K,le,2,X.length/2-se,ee)):buildSimpleUvs(K,le,2,X.length/2-se)});const te=Z.out;return te?(te.positions=new Float32Array(X),te.uvs=new Float32Array(K),te.indices=new Uint32Array(J),te):new MeshGeometry({positions:new Float32Array(X),uvs:new Float32Array(K),indices:new Uint32Array(J)})}var P$1=Object.defineProperty,w$2=Object.getOwnPropertySymbols,A=Object.prototype.hasOwnProperty,z=Object.prototype.propertyIsEnumerable,Y=(Z,X,K)=>X in Z?P$1(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,v=(Z,X)=>{for(var K in X||(X={}))A.call(X,K)&&Y(Z,K,X[K]);if(w$2)for(var K of w$2(X))z.call(X,K)&&Y(Z,K,X[K]);return Z};const m$2=class extends MeshGeometry{constructor(...Z){var X;super({});let K=(X=Z[0])!=null?X:{};typeof K=="number"&&(deprecation(v8_0_0,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),K={width:K,height:Z[1],verticesX:Z[2],verticesY:Z[3]}),this.build(K)}build(Z){var X,K,J,Q;Z=v(v({},m$2.defaultOptions),Z),this.verticesX=(X=this.verticesX)!=null?X:Z.verticesX,this.verticesY=(K=this.verticesY)!=null?K:Z.verticesY,this.width=(J=this.width)!=null?J:Z.width,this.height=(Q=this.height)!=null?Q:Z.height;const ee=this.verticesX*this.verticesY,te=[],re=[],ie=[],ne=this.verticesX-1,se=this.verticesY-1,oe=this.width/ne,ae=this.height/se;for(let ce=0;ce<ee;ce++){const de=ce%this.verticesX,he=ce/this.verticesX|0;te.push(de*oe,he*ae),re.push(de/ne,he/se)}const le=ne*se;for(let ce=0;ce<le;ce++){const de=ce%ne,he=ce/ne|0,pe=he*this.verticesX+de,fe=he*this.verticesX+de+1,ge=(he+1)*this.verticesX+de,me=(he+1)*this.verticesX+de+1;ie.push(pe,fe,ge,fe,me,ge)}this.buffers[0].data=new Float32Array(te),this.buffers[1].data=new Float32Array(re),this.indexBuffer.data=new Uint32Array(ie),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};let PlaneGeometry=m$2;PlaneGeometry.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};var p$5=Object.defineProperty,H$1=Object.getOwnPropertySymbols,f$3=Object.prototype.hasOwnProperty,x$2=Object.prototype.propertyIsEnumerable,W$1=(Z,X,K)=>X in Z?p$5(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,_=(Z,X)=>{for(var K in X||(X={}))f$3.call(X,K)&&W$1(Z,K,X[K]);if(H$1)for(var K of H$1(X))x$2.call(X,K)&&W$1(Z,K,X[K]);return Z};const u$1=class extends PlaneGeometry{constructor(Z){Z=_(_({},u$1.defaultOptions),Z),super({width:Z.width,height:Z.height,verticesX:4,verticesY:4}),this._textureMatrix=new Matrix,this.update(Z)}update(Z){this.updateUvs(Z),this.updatePositions(Z)}updatePositions(Z){var X,K,J,Q,ee,te;this.width=(X=Z.width)!=null?X:this.width,this.height=(K=Z.height)!=null?K:this.height,this._leftWidth=(J=Z.leftWidth)!=null?J:this._leftWidth,this._rightWidth=(Q=Z.rightWidth)!=null?Q:this._rightWidth,this._topHeight=(ee=Z.topHeight)!=null?ee:this._topHeight,this._bottomHeight=(te=Z.bottomHeight)!=null?te:this._bottomHeight;const re=this.positions,ie=this._leftWidth+this._rightWidth,ne=this.width>ie?1:this.width/ie,se=this._topHeight+this._bottomHeight,oe=this.height>se?1:this.height/se,ae=Math.min(ne,oe);re[9]=re[11]=re[13]=re[15]=this._topHeight*ae,re[17]=re[19]=re[21]=re[23]=this.height-this._bottomHeight*ae,re[25]=re[27]=re[29]=re[31]=this.height,re[2]=re[10]=re[18]=re[26]=this._leftWidth*ae,re[4]=re[12]=re[20]=re[28]=this.width-this._rightWidth*ae,re[6]=re[14]=re[22]=re[30]=this.width,this.getBuffer("aPosition").update()}updateUvs(Z){var X,K,J,Q,ee,te;this._originalWidth=(X=Z.originalWidth)!=null?X:this._originalWidth,this._originalHeight=(K=Z.originalHeight)!=null?K:this._originalHeight,this._leftWidth=(J=Z.leftWidth)!=null?J:this._leftWidth,this._rightWidth=(Q=Z.rightWidth)!=null?Q:this._rightWidth,this._topHeight=(ee=Z.topHeight)!=null?ee:this._topHeight,this._bottomHeight=(te=Z.bottomHeight)!=null?te:this._bottomHeight,Z.textureMatrix&&this._textureMatrix.copyFrom(Z.textureMatrix);const re=this._textureMatrix,ie=this.uvs;ie[0]=ie[8]=ie[16]=ie[24]=0,ie[1]=ie[3]=ie[5]=ie[7]=0,ie[6]=ie[14]=ie[22]=ie[30]=1,ie[25]=ie[27]=ie[29]=ie[31]=1;const ne=1/this._originalWidth,se=1/this._originalHeight;ie[2]=ie[10]=ie[18]=ie[26]=ne*this._leftWidth,ie[9]=ie[11]=ie[13]=ie[15]=se*this._topHeight,ie[4]=ie[12]=ie[20]=ie[28]=1-ne*this._rightWidth,ie[17]=ie[19]=ie[21]=ie[23]=1-se*this._bottomHeight,M(re,ie),this.getBuffer("aUV").update()}};let NineSliceGeometry=u$1;NineSliceGeometry.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};function M(Z,X,K){K!=null||(K=X);const J=Z.a,Q=Z.b,ee=Z.c,te=Z.d,re=Z.tx,ie=Z.ty;for(let ne=0;ne<X.length;ne+=2){const se=X[ne],oe=X[ne+1];K[ne]=se*J+oe*ee+re,K[ne+1]=se*Q+oe*te+ie}return K}var P=Object.defineProperty,u=Object.getOwnPropertySymbols,f$2=Object.prototype.hasOwnProperty,b$2=Object.prototype.propertyIsEnumerable,w$1=(Z,X,K)=>X in Z?P(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,H=(Z,X)=>{for(var K in X||(X={}))f$2.call(X,K)&&w$1(Z,K,X[K]);if(u)for(var K of u(X))b$2.call(X,K)&&w$1(Z,K,X[K]);return Z},W=(Z,X)=>{var K={};for(var J in Z)f$2.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&u)for(var J of u(Z))X.indexOf(J)<0&&b$2.call(Z,J)&&(K[J]=Z[J]);return K};const h$2=class extends Container{constructor(Z){var X,K,J,Q;Z instanceof Texture&&(Z={texture:Z});const ee=Z,{leftWidth:te,rightWidth:re,topHeight:ie,bottomHeight:ne,texture:se}=ee,oe=W(ee,["leftWidth","rightWidth","topHeight","bottomHeight","texture"]),ae=se!=null?se:h$2.defaultOptions.texture,le=ae.layout.defaultBorders,ce=new NineSliceGeometry(definedProps({width:ae.width,height:ae.height,originalWidth:ae.width,originalHeight:ae.height,leftWidth:(X=te!=null?te:le==null?void 0:le.left)!=null?X:h$2.defaultOptions.leftWidth,topHeight:(K=ie!=null?ie:le==null?void 0:le.top)!=null?K:h$2.defaultOptions.topHeight,rightWidth:(J=re!=null?re:le==null?void 0:le.right)!=null?J:h$2.defaultOptions.rightWidth,bottomHeight:(Q=ne!=null?ne:le==null?void 0:le.bottom)!=null?Q:h$2.defaultOptions.bottomHeight,textureMatrix:ae.textureMatrix.mapCoord}));super(H({view:new MeshView(definedProps({geometry:ce,texture:ae})),label:"NineSliceSprite"},oe)),this.allowChildren=!1}get width(){return this.view.geometry.width}set width(Z){this.view.geometry.updatePositions({width:Z})}get height(){return this.view.geometry.height}set height(Z){this.view.geometry.updatePositions({height:Z})}get leftWidth(){return this.view.geometry._leftWidth}set leftWidth(Z){this.view.geometry.updateUvs({leftWidth:Z})}get topHeight(){return this.view.geometry._topHeight}set topHeight(Z){this.view.geometry.updateUvs({topHeight:Z})}get rightWidth(){return this.view.geometry._rightWidth}set rightWidth(Z){this.view.geometry.updateUvs({rightWidth:Z})}get bottomHeight(){return this.view.geometry._bottomHeight}set bottomHeight(Z){this.view.geometry.updateUvs({bottomHeight:Z})}get texture(){return this.view.texture}set texture(Z){Z!==this.view.texture&&(this.view.geometry.updateUvs({originalWidth:Z.width,originalHeight:Z.height,textureMatrix:Z.textureMatrix.mapCoord}),this.view.texture=Z)}get roundPixels(){return!!this.view.roundPixels}set roundPixels(Z){this.view.roundPixels=Z?1:0}};let NineSliceSprite=h$2;NineSliceSprite.defaultOptions={texture:Texture.EMPTY,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10};class NineSlicePlane extends NineSliceSprite{constructor(...X){let K=X[0];K instanceof Texture&&(deprecation(v8_0_0,"NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}"),K={texture:K,leftWidth:X[1],topHeight:X[2],rightWidth:X[3],bottomHeight:X[4]}),deprecation(v8_0_0,"NineSlicePlane is deprecated. Use NineSliceSprite instead."),super(K)}}function getTextureDefaultMatrix(Z,X){const{frameWidth:K,frameHeight:J}=Z;return X.scale(1/K,1/J),X}var x$1=Object.defineProperty,s$4=Object.getOwnPropertySymbols,m$1=Object.prototype.hasOwnProperty,d$1=Object.prototype.propertyIsEnumerable,a$2=(Z,X,K)=>X in Z?x$1(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,p$4=(Z,X)=>{for(var K in X||(X={}))m$1.call(X,K)&&a$2(Z,K,X[K]);if(s$4)for(var K of s$4(X))d$1.call(X,K)&&a$2(Z,K,X[K]);return Z},E=(Z,X)=>{var K={};for(var J in Z)m$1.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&s$4)for(var J of s$4(Z))X.indexOf(J)<0&&d$1.call(Z,J)&&(K[J]=Z[J]);return K};class Mesh extends Container{constructor(...X){let K=X[0];K instanceof MeshGeometry&&(deprecation(v8_0_0,"Mesh: use new Mesh({ geometry, shader }) instead"),K={geometry:K,shader:X[1]},X[3]&&(deprecation(v8_0_0,"Mesh: topology argument has been removed, use geometry.topology instead"),K.geometry.topology=X[3]));const J=K,{geometry:Q,shader:ee,texture:te}=J,re=E(J,["geometry","shader","texture"]);super(p$4({view:new MeshView(definedProps({geometry:Q,shader:ee,texture:te})),label:"Mesh"},re)),this.allowChildren=!1}get texture(){return this.view.texture}set texture(X){this.view.texture=X}get geometry(){return this.view.geometry}set geometry(X){this.view.geometry=X}get material(){return deprecation(v8_0_0,"mesh.material property has been removed, use mesh.shader instead"),this.view.shader}get shader(){return this.view.shader}get roundPixels(){return!!this.view.roundPixels}set roundPixels(X){this.view.roundPixels=X?1:0}}class AnimatedSprite extends Sprite{constructor(X,K=!0){super(X[0]instanceof Texture?X[0]:X[0].texture),this._textures=null,this._durations=null,this._autoUpdate=K,this._isConnectedToTicker=!1,this.animationSpeed=1,this.loop=!0,this.updateAnchor=!1,this.onComplete=null,this.onFrameChange=null,this.onLoop=null,this._currentTime=0,this._playing=!1,this._previousFrame=null,this.textures=X}stop(){this._playing&&(this._playing=!1,this._autoUpdate&&this._isConnectedToTicker&&(Ticker.shared.remove(this.update,this),this._isConnectedToTicker=!1))}play(){this._playing||(this._playing=!0,this._autoUpdate&&!this._isConnectedToTicker&&(Ticker.shared.add(this.update,this,UPDATE_PRIORITY.HIGH),this._isConnectedToTicker=!0))}gotoAndStop(X){this.stop(),this.currentFrame=X}gotoAndPlay(X){this.currentFrame=X,this.play()}update(X){if(!this._playing)return;const K=X.deltaTime,J=this.animationSpeed*K,Q=this.currentFrame;if(this._durations!==null){let ee=this._currentTime%1*this._durations[this.currentFrame];for(ee+=J/60*1e3;ee<0;)this._currentTime--,ee+=this._durations[this.currentFrame];const te=Math.sign(this.animationSpeed*K);for(this._currentTime=Math.floor(this._currentTime);ee>=this._durations[this.currentFrame];)ee-=this._durations[this.currentFrame]*te,this._currentTime+=te;this._currentTime+=ee/this._durations[this.currentFrame]}else this._currentTime+=J;this._currentTime<0&&!this.loop?(this.gotoAndStop(0),this.onComplete&&this.onComplete()):this._currentTime>=this._textures.length&&!this.loop?(this.gotoAndStop(this._textures.length-1),this.onComplete&&this.onComplete()):Q!==this.currentFrame&&(this.loop&&this.onLoop&&(this.animationSpeed>0&&this.currentFrame<Q||this.animationSpeed<0&&this.currentFrame>Q)&&this.onLoop(),this._updateTexture())}_updateTexture(){const X=this.currentFrame;this._previousFrame!==X&&(this._previousFrame=X,this.texture=this._textures[X],this.updateAnchor&&this.anchor.copyFrom(this.texture.layout.defaultAnchor),this.onFrameChange&&this.onFrameChange(this.currentFrame))}destroy(){this.stop(),super.destroy(),this.onComplete=null,this.onFrameChange=null,this.onLoop=null}static fromFrames(X){const K=[];for(let J=0;J<X.length;++J)K.push(Texture.from(X[J]));return new AnimatedSprite(K)}static fromImages(X){const K=[];for(let J=0;J<X.length;++J)K.push(Texture.from(X[J]));return new AnimatedSprite(K)}get totalFrames(){return this._textures.length}get textures(){return this._textures}set textures(X){if(X[0]instanceof Texture)this._textures=X,this._durations=null;else{this._textures=[],this._durations=[];for(let K=0;K<X.length;K++)this._textures.push(X[K].texture),this._durations.push(X[K].time)}this._previousFrame=null,this.gotoAndStop(0),this._updateTexture()}get currentFrame(){let X=Math.floor(this._currentTime)%this._textures.length;return X<0&&(X+=this._textures.length),X}set currentFrame(X){if(X<0||X>this.totalFrames-1)throw new Error(`[AnimatedSprite]: Invalid frame index value ${X}, expected to be between 0 and totalFrames ${this.totalFrames}.`);const K=this.currentFrame;this._currentTime=X,K!==this.currentFrame&&this._updateTexture()}get playing(){return this._playing}get autoUpdate(){return this._autoUpdate}set autoUpdate(X){X!==this._autoUpdate&&(this._autoUpdate=X,!this._autoUpdate&&this._isConnectedToTicker?(Ticker.shared.remove(this.update,this),this._isConnectedToTicker=!1):this._autoUpdate&&!this._isConnectedToTicker&&this._playing&&(Ticker.shared.add(this.update,this),this._isConnectedToTicker=!0))}}class Transform{constructor({matrix:X,observer:K}={}){this.dirty=!0,this._matrix=X!=null?X:new Matrix,this.observer=K,this.position=new ObservablePoint(this,0,0),this.scale=new ObservablePoint(this,1,1),this.pivot=new ObservablePoint(this,0,0),this.skew=new ObservablePoint(this,0,0),this._rotation=0,this._cx=1,this._sx=0,this._cy=0,this._sy=1}get matrix(){const X=this._matrix;return this.dirty&&(X.a=this._cx*this.scale.x,X.b=this._sx*this.scale.x,X.c=this._cy*this.scale.y,X.d=this._sy*this.scale.y,X.tx=this.position.x-(this.pivot.x*X.a+this.pivot.y*X.c),X.ty=this.position.y-(this.pivot.x*X.b+this.pivot.y*X.d),this.dirty=!1),X}onUpdate(X){var K;this.dirty=!0,X===this.skew&&this.updateSkew(),(K=this.observer)==null||K.onUpdate(this)}updateSkew(){this._cx=Math.cos(this._rotation+this.skew.y),this._sx=Math.sin(this._rotation+this.skew.y),this._cy=-Math.sin(this._rotation-this.skew.x),this._sy=Math.cos(this._rotation-this.skew.x),this.dirty=!0}setFromMatrix(X){X.decompose(this),this.dirty=!0}get rotation(){return this._rotation}set rotation(X){this._rotation!==X&&(this._rotation=X,this.updateSkew())}}var a$1=Object.defineProperty,h$1=Object.getOwnPropertySymbols,l$3=Object.prototype.hasOwnProperty,b$1=Object.prototype.propertyIsEnumerable,d=(Z,X,K)=>X in Z?a$1(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,s$3=(Z,X)=>{for(var K in X||(X={}))l$3.call(X,K)&&d(Z,K,X[K]);if(h$1)for(var K of h$1(X))b$1.call(X,K)&&d(Z,K,X[K]);return Z};const o$2=class{constructor(Z){this.owner=emptyViewObserver,this.uid=uid("tilingSpriteView"),this.renderPipeId="tilingSprite",this.batched=!0,this.roundPixels=0,this._bounds=[0,1,0,0],this._boundsDirty=!0,Z=s$3(s$3({},o$2.defaultOptions),Z),this.anchor=new ObservablePoint(this,0,0),this._applyAnchorToTexture=Z.applyAnchorToTexture,this.texture=Z.texture,this._width=Z.width,this._height=Z.height,this._tileTransform=new Transform({observer:this})}get bounds(){return this._boundsDirty&&(this._updateBounds(),this._boundsDirty=!1),this._bounds}set texture(Z){this._texture!==Z&&(this._texture=Z,this.onUpdate())}get texture(){return this._texture}set width(Z){this._width=Z,this.onUpdate()}get width(){return this._width}set height(Z){this._height=Z,this.onUpdate()}get height(){return this._height}_updateBounds(){const Z=this._bounds,X=this.anchor,K=this._width,J=this._height;Z[1]=-X._x*K,Z[0]=Z[1]+K,Z[3]=-X._y*J,Z[2]=Z[3]+J}addBounds(Z){const X=this.bounds;Z.addFrame(X[0],X[2],X[1],X[3])}containsPoint(Z){const X=this.bounds[0],K=this.bounds[2],J=-X*this.anchor.x;let Q=0;return Z.x>=J&&Z.x<=J+X&&(Q=-K*this.anchor.y,Z.y>=Q&&Z.y<=Q+K)}onUpdate(){this._boundsDirty=!0,this._didUpdate=!0,this.owner.onViewUpdate()}destroy(Z=!1){if(this.anchor=null,this._tileTransform=null,this._bounds=null,typeof Z=="boolean"?Z:Z==null?void 0:Z.texture){const X=typeof Z=="boolean"?Z:Z==null?void 0:Z.textureSource;this._texture.destroy(X)}this._texture=null}};let TilingSpriteView=o$2;TilingSpriteView.defaultOptions={texture:Texture.EMPTY,width:256,height:256,applyAnchorToTexture:!1};var g$1=Object.defineProperty,n$3=Object.getOwnPropertySymbols,l$2=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable,s$2=(Z,X,K)=>X in Z?g$1(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,o$1=(Z,X)=>{for(var K in X||(X={}))l$2.call(X,K)&&s$2(Z,K,X[K]);if(n$3)for(var K of n$3(X))h.call(X,K)&&s$2(Z,K,X[K]);return Z},p$3=(Z,X)=>{var K={};for(var J in Z)l$2.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&n$3)for(var J of n$3(Z))X.indexOf(J)<0&&h.call(Z,J)&&(K[J]=Z[J]);return K};class TilingSprite extends Container{static from(X,K={}){return typeof X=="string"?new TilingSprite(o$1({texture:Cache.get(X)},K)):new TilingSprite(o$1({texture:X},K))}constructor(X){const K=X!=null?X:{},{texture:J,width:Q,height:ee,applyAnchorToTexture:te}=K,re=p$3(K,["texture","width","height","applyAnchorToTexture"]);super(o$1({view:new TilingSpriteView(definedProps({texture:J,width:Q,height:ee,applyAnchorToTexture:te})),label:"TilingSprite"},re)),this.allowChildren=!1}get clampMargin(){return this.view.texture.textureMatrix.clampMargin}set clampMargin(X){this.view.texture.textureMatrix.clampMargin=X}set texture(X){this.view.texture=X}get texture(){return this.view.texture}get anchor(){return this.view.anchor}set anchor(X){this.view.anchor.x=X.x,this.view.anchor.y=X.y}get width(){return this.view.width}set width(X){this.view.width=X}get height(){return this.view.height}set height(X){this.view.height=X}get tilePosition(){return this.view._tileTransform.position}set tilePosition(X){this.view._tileTransform.position.copyFrom(X)}get tileScale(){return this.view._tileTransform.scale}set tileScale(X){this.view._tileTransform.scale.copyFrom(X)}set tileRotation(X){this.view._tileTransform.rotation=X}get tileRotation(){return this.view._tileTransform.rotation}get tileTransform(){return this.view._tileTransform}get roundPixels(){return!!this.view.roundPixels}set roundPixels(X){this.view.roundPixels=X?1:0}}function textStyleToCSS(Z){const X=Z._stroke,K=Z._fill,J=[`div { ${[`color: ${Color.shared.setValue(K.color).toHex()}`,`font-size: ${Z.fontSize}px`,`font-family: ${Z.fontFamily}`,`font-weight: ${Z.fontWeight}`,`font-style: ${Z.fontStyle}`,`font-variant: ${Z.fontVariant}`,`letter-spacing: ${Z.letterSpacing}px`,`text-align: ${Z.align}`,`padding: ${Z.padding}px`,`white-space: ${Z.whiteSpace}`,...Z.lineHeight?[`line-height: ${Z.lineHeight}px`]:[],...Z.wordWrap?[`word-wrap: ${Z.breakWords?"break-all":"break-word"}`,`max-width: ${Z.wordWrapWidth}px`]:[],...X?[p$2(X)]:[],...Z.dropShadow?[s$1(Z.dropShadow)]:[],...Z.cssOverrides].join(";")} }`];return c(Z.tagStyles,J),J.join(" ")}function s$1(Z){const X=Color.shared.setValue(Z.color).setAlpha(Z.alpha).toHexa(),K=Math.round(Math.cos(Z.angle)*Z.distance),J=Math.round(Math.sin(Z.angle)*Z.distance),Q=`${K}px ${J}px`;return Z.blur>0?`text-shadow: ${Q} ${Z.blur}px ${X}`:`text-shadow: ${Q} ${X}`}function p$2(Z){return[`-webkit-text-stroke-width: ${Z.width}px`,`-webkit-text-stroke-color: ${Color.shared.setValue(Z.color).toHex()}`,`text-stroke-width: ${Z.width}px`,`text-stroke-color: ${Color.shared.setValue(Z.color).toHex()}`,"paint-order: stroke"].join(";")}const f$1={fontSize:"font-size: {{VALUE}}px",fontFamily:"font-family: {{VALUE}}",fontWeight:"font-weight: {{VALUE}}",fontStyle:"font-style: {{VALUE}}",fontVariant:"font-variant: {{VALUE}}",letterSpacing:"letter-spacing: {{VALUE}}px",align:"text-align: {{VALUE}}",padding:"padding: {{VALUE}}px",whiteSpace:"white-space: {{VALUE}}",lineHeight:"line-height: {{VALUE}}px",wordWrapWidth:"max-width: {{VALUE}}px"},l$1={fill:Z=>`color: ${Color.shared.setValue(Z).toHex()}`,breakWords:Z=>`word-wrap: ${Z?"break-all":"break-word"}`,stroke:p$2,dropShadow:s$1};function c(Z,X){for(const K in Z){const J=Z[K],Q=[];for(const ee in J)l$1[ee]?Q.push(l$1[ee](J[ee])):f$1[ee]&&Q.push(f$1[ee].replace("{{VALUE}}",J[ee]));X.push(`${K} { ${Q.join(";")} }`)}}class HTMLTextStyle extends TextStyle{constructor(X={}){var K,J;super(X),this._cssOverrides=[],(K=this.cssOverrides)!=null||(this.cssOverrides=X.cssOverrides),this.tagStyles=(J=X.tagStyles)!=null?J:{}}set cssOverrides(X){this._cssOverrides=X instanceof Array?X:[X],this.update()}get cssOverrides(){return this._cssOverrides}_generateKey(){return this._styleKey=generateTextStyleKey(this)+this._cssOverrides.join("-"),this._styleKey}update(){this._cssStyle=null,super.update()}clone(){return new HTMLTextStyle({align:this.align,breakWords:this.breakWords,dropShadow:this.dropShadow,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth,cssOverrides:this.cssOverrides})}get cssStyle(){return this._cssStyle||(this._cssStyle=textStyleToCSS(this)),this._cssStyle}addOverride(...X){const K=X.filter(J=>!this.cssOverrides.includes(J));K.length>0&&(this.cssOverrides.push(...K),this.update())}removeOverride(...X){const K=X.filter(J=>this.cssOverrides.includes(J));K.length>0&&(this.cssOverrides=this.cssOverrides.filter(J=>!K.includes(J)),this.update())}set fill(X){super.fill=X}set stroke(X){super.stroke=X}}function detectRenderType(Z){if(Z instanceof HTMLTextStyle)return"html";const X=Cache.get(`${Z==null?void 0:Z.fontFamily}-bitmap`);return X instanceof DynamicBitmapFont||X instanceof BitmapFont?"bitmap":"canvas"}function ensureTextStyle(Z,X){return X instanceof TextStyle||X instanceof HTMLTextStyle?X:Z==="html"?new HTMLTextStyle(X):new TextStyle(X)}const T$1={canvas:"text",html:"htmlText",bitmap:"bitmapText"};class TextView{constructor(X){this.uid=uid("textView"),this.renderPipeId="text",this.owner=emptyViewObserver,this.batched=!0,this.resolution=null,this._didUpdate=!0,this.roundPixels=0,this._bounds=[0,1,0,0],this._boundsDirty=!0;var K,J,Q;this.text=(K=X.text)!=null?K:"";const ee=(J=X.renderMode)!=null?J:detectRenderType(X.style);this._renderMode=ee,this.style=ensureTextStyle(ee,X.style),this.renderPipeId=T$1[ee],this.anchor=new ObservablePoint(this,0,0),this.resolution=(Q=X.resolution)!=null?Q:null}set text(X){X=X.toString(),this._text!==X&&(this._text=X,this.onUpdate())}get text(){return this._text}get style(){return this._style}set style(X){var K;X=X||{},(K=this._style)==null||K.off("update",this.onUpdate,this),this._style=ensureTextStyle(this._renderMode,X),this._style.on("update",this.onUpdate,this),this.onUpdate()}get bounds(){return this._boundsDirty&&(this._updateBounds(),this._boundsDirty=!1),this._bounds}addBounds(X){const K=this.bounds;X.addFrame(K[0],K[2],K[1],K[3])}containsPoint(X){const K=this.bounds[1],J=this.bounds[3],Q=-K*this.anchor.x;let ee=0;return X.x>=Q&&X.x<=Q+K&&(ee=-J*this.anchor.y,X.y>=ee&&X.y<=ee+J)}onUpdate(){this._didUpdate=!0,this._boundsDirty=!0,this.owner.onViewUpdate()}_getKey(){return`${this.text}:${this._style.styleKey}`}_updateBounds(){const X=this._bounds,K=this._style.padding,J=this.anchor;if(this.renderPipeId==="bitmapText"){const Q=BitmapFontManager.measureText(this.text,this._style),ee=Q.scale,te=Q.offsetY*ee,re=Q.width*ee,ie=Q.height*ee;X[0]=-J._x*re-K,X[1]=X[0]+re,X[2]=-J._y*(ie+te)-K,X[3]=X[2]+ie}else if(this.renderPipeId==="htmlText"){const Q=measureHtmlText(this.text,this._style),{width:ee,height:te}=Q;X[0]=-J._x*ee-K,X[1]=X[0]+ee,X[2]=-J._y*te-K,X[3]=X[2]+te}else{const Q=CanvasTextMetrics.measureText(this.text,this._style),{width:ee,height:te}=Q;X[0]=-J._x*ee-K,X[1]=X[0]+ee,X[2]=-J._y*te-K,X[3]=X[2]+te}}destroy(X=!1){this.owner=null,this._bounds=null,this.anchor=null,this._style.destroy(X),this._style=null,this._text=null}}var S=Object.defineProperty,n$2=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,T=Object.prototype.propertyIsEnumerable,p$1=(Z,X,K)=>X in Z?S(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,a=(Z,X)=>{for(var K in X||(X={}))l.call(X,K)&&p$1(Z,K,X[K]);if(n$2)for(var K of n$2(X))T.call(X,K)&&p$1(Z,K,X[K]);return Z},y$1=(Z,X)=>{var K={};for(var J in Z)l.call(Z,J)&&X.indexOf(J)<0&&(K[J]=Z[J]);if(Z!=null&&n$2)for(var J of n$2(Z))X.indexOf(J)<0&&T.call(Z,J)&&(K[J]=Z[J]);return K};class Text extends Container{constructor(...X){let K=X[0];(typeof K=="string"||X[1])&&(deprecation(v8_0_0,'use new Text({ text: "hi!", style }) instead'),K={text:K,style:X[1]});const J=K,{style:Q,text:ee,renderMode:te,resolution:re}=J,ie=y$1(J,["style","text","renderMode","resolution"]);super(a({view:new TextView(definedProps({style:Q,text:ee,renderMode:te,resolution:re})),label:"Text"},ie)),this.allowChildren=!1}get anchor(){return this.view.anchor}set anchor(X){this.view.anchor.x=X.x,this.view.anchor.y=X.y}set text(X){this.view.text=X}get text(){return this.view.text}set style(X){this.view.style=X}get style(){return this.view.style}get roundPixels(){return!!this.view.roundPixels}set roundPixels(X){this.view.roundPixels=X?1:0}}class BitmapText extends Text{constructor(...X){deprecation(v8_0_0,'use new Text({ text: "hi!", style, renderMode: "bitmap" }) instead');let K=X[0];(typeof K=="string"||X[1])&&(K={text:K,style:X[1]}),K.renderMode="bitmap",super(K)}}class HTMLText extends Text{constructor(...X){deprecation(v8_0_0,'use new Text({ text: "hi!", style, renderMode: "html" }) instead');let K=X[0];(typeof K=="string"||X[1])&&(K={text:K,style:X[1]}),K.renderMode="html",super(K)}}const DATA_URI=/^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;async function logDebugTexture(Z,X,K=200){const J=await X.extract.base64(Z);await X.encoder.commandFinished;const Q=K;console.log(`logging texture ${Z.source.width}px ${Z.source.height}px`);const ee=["font-size: 1px;",`padding: ${Q}px 300px;`,`background: url(${J}) no-repeat;`,"background-size: contain;"].join(" ");console.log("%c ",ee)}var $=Object.defineProperty,x=Object.defineProperties,g=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,m=Object.prototype.hasOwnProperty,y=Object.prototype.propertyIsEnumerable,f=(Z,X,K)=>X in Z?$(Z,X,{enumerable:!0,configurable:!0,writable:!0,value:K}):Z[X]=K,n$1=(Z,X)=>{for(var K in X||(X={}))m.call(X,K)&&f(Z,K,X[K]);if(s)for(var K of s(X))y.call(X,K)&&f(Z,K,X[K]);return Z},p=(Z,X)=>x(Z,g(X));const b=["#000080","#228B22","#8B0000","#4169E1","#008080","#800000","#9400D3","#FF8C00","#556B2F","#8B008B"];let w=0;function logScene(Z,X=0,K={color:"#000000"}){Z.isLayerRoot&&(K.color=b[w++]);let J="";for(let te=0;te<X;te++)J+="    ";let Q=Z.label;!Q&&Z instanceof Sprite&&(Q=`sprite:${Z.view.texture.label}`);let ee=`%c ${J}|- ${Q} (worldX:${Z.worldTransform.tx}, layerX:${Z.layerTransform.tx}, localX:${Z.x})`;Z.isLayerRoot&&(ee+=" (LayerGroup)"),Z.filters&&(ee+="(*filters)"),console.log(ee,`color:${K.color}; font-weight:bold;`),X++;for(let te=0;te<Z.children.length;te++){const re=Z.children[te];logScene(re,X,n$1({},K))}}function logLayerGroupScene(Z,X=0,K={index:0,color:"#000000"}){let J="";for(let ee=0;ee<X;ee++)J+="    ";const Q=`%c ${J}- ${K.index}: ${Z.root.label} worldX:${Z.worldTransform.tx}`;console.log(Q,`color:${K.color}; font-weight:bold;`),X++;for(let ee=0;ee<Z.layerGroupChildren.length;ee++){const te=Z.layerGroupChildren[ee];logLayerGroupScene(te,X,p(n$1({},K),{index:ee}))}}let n=0;const o=500;function warn(...Z){n!==o&&(n++,n===o?console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS."):console.warn("PixiJS Warning: ",...Z))}var hsl=`fn getLuminosity(c: vec3<f32>) -> f32 {
  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
}

fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32> {
  let d: f32 = lum - getLuminosity(c);
  let newColor: vec3<f32> = c.rgb + vec3<f32>(d, d, d);

  // clip back into legal range
  let newLum: f32 = getLuminosity(newColor);
  let cMin: f32 = min(newColor.r, min(newColor.g, newColor.b));
  let cMax: f32 = max(newColor.r, max(newColor.g, newColor.b));

  let t1: f32 = newLum / (newLum - cMin);
  let t2: f32 = (1.0 - newLum) / (cMax - newLum);

  let finalColor = mix(vec3<f32>(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax > 1.0), t1, cMin < 0.0));

  return finalColor;
}

fn getSaturation(c: vec3<f32>) -> f32 {
  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
}

// Set saturation if color components are sorted in ascending order.
fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32> {
  var result: vec3<f32>;
  if (cSorted.z > cSorted.x) {
    let newY = (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));
    result = vec3<f32>(0.0, newY, s);
  } else {
    result = vec3<f32>(0.0, 0.0, 0.0);
  }
  return vec3<f32>(result.x, result.y, result.z);
}

fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32> {
    var result: vec3<f32> = c;

    if (c.r <= c.g && c.r <= c.b) {
        if (c.g <= c.b) {
            result = setSaturationMinMidMax(result, s);
        } else {
            var temp: vec3<f32> = vec3<f32>(result.r, result.b, result.g);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.r, temp.b, temp.g);
        }
    } else if (c.g <= c.r && c.g <= c.b) {
        if (c.r <= c.b) {
            var temp: vec3<f32> = vec3<f32>(result.g, result.r, result.b);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.g, temp.r, temp.b);
        } else {
            var temp: vec3<f32> = vec3<f32>(result.g, result.b, result.r);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.g, temp.b, temp.r);
        }
    } else {
        if (c.r <= c.g) {
            var temp: vec3<f32> = vec3<f32>(result.b, result.r, result.g);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.b, temp.r, temp.g);
        } else {
            var temp: vec3<f32> = vec3<f32>(result.b, result.g, result.r);
            temp = setSaturationMinMidMax(temp, s);
            result = vec3<f32>(temp.b, temp.g, temp.r);
        }
    }

    return result;
}`;export{AbstractBitmapFont,AbstractRenderer,AccessibilitySystem,AlphaFilter,AlphaMask,AlphaMaskPipe,AnimatedSprite,Application,Assets,AssetsClass,BLEND_TO_NPM,BUFFER_TYPE,BackgroundLoader,BackgroundSystem,Batch,BatchGeometry,BatchTextureArray,BatchableGraphics,BatchableMesh,BatchableSprite,Batcher,BatcherPipe,BigPool,BindGroup,BindGroupSystem,BitmapFont,BitmapFontManager,BitmapText,BitmapTextPipe,BlendModeFilter,BlendModePipe,BlurFilter,BlurFilterPass,Bounds,BrowserAdapter,Buffer,BufferImageSource,BufferResource,BufferSystem,BufferUsage,CLEAR,Cache,CanvasPool,CanvasPoolClass,CanvasSource,CanvasTextMetrics,CanvasTextPipe,CanvasTextSystem,Circle,Color,ColorMask,ColorMaskPipe,ColorMatrixFilter,CompressedSource,Container,DATA_URI,DEG_TO_RAD,DEPRECATED_SCALE_MODES,DEPRECATED_WRAP_MODES,DOMAdapter,DRAW_MODES,DisplacementFilter,DynamicBitmapFont,Ellipse,EventBoundary,eventemitter3 as EventEmitter,EventSystem,EventsTicker,u$v as ExtensionType,ExtractSystem,FederatedContainer,FederatedEvent,FederatedMouseEvent,FederatedPointerEvent,FederatedWheelEvent,FillGradient,FillPattern,Filter,FilterEffect,FilterPipe,FilterSystem,FontStylePromiseCache,GAUSSIAN_VALUES,GLSL_TO_STD40_SIZE,GL_FORMATS,GL_TARGETS,GL_TYPES,GL_WRAP_MODES,GenerateTextureSystem,Geometry,GlBackBufferSystem,GlBatchAdaptor,GlBuffer,GlBufferSystem,GlColorMaskSystem,GlContextSystem,GlEncoderSystem,GlGeometrySystem,GlGraphicsAdaptor,GlMeshAdaptor,GlProgram,GlProgramData,GlRenderTarget,GlRenderTargetAdaptor,GlRenderTargetSystem,GlShaderSystem,GlStateSystem,GlStencilSystem,GlTexture,GlTextureSystem,GlUniformGroupSystem,GlobalUniformSystem,GpuBatchAdaptor,GpuBlendModesToPixi,GpuColorMaskSystem,GpuDeviceSystem,GpuEncoderSystem,GpuGraphicsAdaptor,GpuGraphicsContext,GpuMeshAdapter,GpuMipmapGenerator,GpuProgram,GpuReadBuffer,GpuRenderTarget,GpuRenderTargetAdaptor,GpuRenderTargetSystem,GpuShaderSystem,GpuStateSystem,GpuStencilModesToPixi,GpuStencilSystem,GpuTextureSystem,GpuUniformBatchPipe,Graphics,GraphicsContext,GraphicsContextRenderData,GraphicsContextSystem,GraphicsPath,GraphicsPipe,GraphicsView,HTMLText,HTMLTextPipe,HTMLTextRenderData,HTMLTextStyle,HTMLTextSystem,HelloSystem,IGLUniformData,ImageSource,InstructionSet,LayerGroup,LayerPipe,LayerRenderable,LayerSystem,Loader,LoaderParserPriority,MAX_TEXTURES,MSAA_QUALITY,MaskEffectManager,MaskEffectManagerClass,MaskFilter,Matrix,Mesh,MeshGeometry,MeshPipe,MeshView,NOOP,NineSliceGeometry,NineSlicePlane,NineSliceSprite,NoiseFilter,ObservablePoint,PI_2,PipelineSystem,PlaneGeometry,Point,Polygon,Pool,PoolGroupClass,ProxyRenderable,QuadGeometry,RAD_TO_DEG,Rectangle,RenderTarget,RenderTargetSystem,RenderTexture,RendererType,ResizePlugin,Resolver,RoundedRectangle,SCALE_MODES,STENCIL_MODES,SVGParser,SVGToGraphicsPath,ScissorMask,SdfShader,Shader,ShaderStage,ShapePath,SharedRenderPipes,SharedSystems,ShockwaveFilter,Sprite,SpritePipe,SpriteView,Spritesheet,State,StencilMask,StencilMaskPipe,SystemRunner,Text,TextStyle,TextView,Texture,TextureGCSystem,TextureLayout,TextureMatrix,TexturePool,TexturePoolClass,TextureSource,TextureStyle,TextureUvs,Ticker,TickerListener,TickerPlugin,TilingSprite,TilingSpritePipe,TilingSpriteShader,TilingSpriteView,Transform,Triangle,UPDATE_BLEND,UPDATE_COLOR,UPDATE_PRIORITY,UPDATE_TRANSFORM,UPDATE_VISIBLE,UniformBufferBatch,UniformBufferSystem,UniformGroup,VERSION,VideoSource,ViewSystem,ViewableBuffer,WGSL_TO_STD40_SIZE,WRAP_MODES,WebGLRenderer,WebGPURenderer,WebWorkerAdapter,d$j as WorkerManager,_getGlobalBounds,accessibilityTarget,addBits,addMaskBounds,addMaskLocalBounds,y$9 as alphaFrag,s$m as alphaWgsl,applyStyleParams,autoDetectEnvironment,autoDetectRenderer,autoDetectSource,basisTranscoderUrls,batchSamplersUniformGroup,bitmapFontCachePlugin,bitmapFontTextParser,bitmapFontXMLParser,bitmapFontXMLStringParser,M$3 as blendTemplateFrag,B$2 as blendTemplateVert,O$2 as blendTemplateWgsl,blockDataMap,b$b as blurTemplateWgsl,browserExt,buildAdaptiveBezier,buildAdaptiveQuadratic,buildArc,buildArcTo,buildArcToSvg,buildCircle,buildContextBatches,buildGeometryFromPath,buildInstructions,buildLine,buildPolygon,buildRectangle,buildSimpleUvs,buildTriangle,buildUvs,cacheTextureArray,calculateProjection,checkDataUrl,checkExtension,childrenHelperMixin,closePointEps,collectAllRenderables,collectLayerGroups,color32BitToUniform,colorBit,colorBitGl,F as colorMatrixFilterFrag,d$a as colorMatrixFilterWgsl,colorToUniform,compareModeToGlCompare,compileHighShader,compileHighShaderGl,compileHighShaderGlProgram,compileHighShaderGpuProgram,compileHooks,compileInputs,compileOutputs,compileShader,convertFillInputToFillStyle,convertToList,copySearchParams,createIdFromString,createLevelBuffers,createLevelBuffersFromKTX,createStringVariations,createTexture,createUBOElements,crossOrigin,curveEps,P$6 as defaultFilterVert,defaultUniformValue,defaultValue,definedProps,deprecation,detectAvif,detectBasis,detectDefaults,detectMp4,detectOgv,detectRenderType,detectVideoAlphaMode,detectWebm,detectWebp,determineCrossOrigin,h$i as displacementFrag,S$5 as displacementVert,p$l as displacementWgsl,earcut_1 as earcut,effectsMixin,emptyViewObserver,ensureIsBuffer,ensurePrecision,ensureTextStyle,executeInstructions,b$p as extensions,extractFontFamilies,extractStructAndGroups,fastCopy,findHooksRx,findMixin,fontStringFromTextStyle,formatShader,r$4 as fragmentGPUTemplate,i$b as fragmentGlTemplate,generateBlurFragSource,generateBlurGlProgram,generateBlurProgram,generateBlurVertSource,generateGPULayout,generateGpuLayoutGroups,generateLayout,generateLayoutHash,generateProgram,generateTextStyleKey,generateTextureBatchBit,generateTextureBatchBitGl,generateUID,generateUniformBufferSync,generateUniformsSync,getAttributeData,getBitmapTextLayout,getCanvasFillStyle,getCanvasTexture,getFilterEffect,getFontCss,getFontFamilyName,getGlInfoFromFormat,getGlobalBounds,getGlobalRenderableBounds,getLocalBounds,getMatrixRelativeToParent,getMaxFragmentPrecision,getOrientationOfPoints,getParent,getPo2TextureFromSource,getResolutionOfUrl,getSVGUrl,getSupportedCompressedTextureFormats,getSupportedGPUCompressedTextureFormats,getSupportedGlCompressedTextureFormats,getSupportedTextureFormats,getTemporaryCanvasFromImage,getTestContext,getTextureBatchBindGroup,getTextureDefaultMatrix,getTextureFormatFromKTXTexture,getUniformBufferData,getUniformData,getUrlExtension,glFormatToGPUFormat,glUploadBufferImageResource,glUploadCompressedTextureResource,glUploadImageResource,glUploadVideoResource,globalUniformsBit,globalUniformsBitGl,gpuFormatToBasisTranscoderFormat,gpuFormatToKTXBasisTranscoderFormat,gpuUploadBufferImageResource,gpuUploadCompressedTextureResource,gpuUploadImageResource,gpuUploadVideoResource,groupD8,hsl as hslWgsl,hslgl,hslgpu,injectBits,isMobile,isPow2,isRenderingToScreen,isSafari,isSingleItem,ktxTranscoderUrls,loadBasis,loadBasisOnWorker,loadDDS,loadFontAsBase64,loadFontCSS,loadImageBitmap,loadJson,loadKTX,loadKTX2onWorker,loadSVGImage,loadSvg,loadTextures,loadTxt,loadVideoTextures,loadWebFont,localUniformBit,localUniformBitGl,localUniformBitGroup2,localUniformMSDFBit,localUniformMSDFBitGl,log2,logDebugTexture,logLayerGroupScene,logProgramError,logScene,mSDFBit,mSDFBitGl,mapFormatToGlFormat,mapFormatToGlInternalFormat,mapFormatToGlType,mapSize,mapType,mapWebGLBlendModesToPixi,l$g as maskFrag,f$d as maskVert,o$g as maskWgsl,measureHtmlText,measureMixin,migrateFragmentFromV7toV8,mipmapScaleModeToGlFilter,mixColors,mixHexColors,mixStandardAnd32BitColors,multiplyHexColors,nextPow2,U as noiseFrag,f$f as noiseWgsl,nonCompressedFormats,normalizeExtensionPriority,onRenderMixin,parseDDS,path,preloadVideo,removeItems,removeStructAndGroupDuplicates,resolveCharacters,resolveCompressedTextureUrl,resolveTextureUrl,resourceToTexture,returnFilterEffect,roundPixelsBit,roundPixelsBitGl,roundedShapeArc,roundedShapeQuadraticCurve,sayHello,scaleModeToGlFilter,setBasisTranscoderPath,setKTXTranscoderPath,setProgramName,setProgramVersion,P$5 as shockwaveFrag,w$3 as shockwaveVert,f$e as shockwaveWgsl,sortMixin,spritesheetAsset,testImageFormat,testVideoFormat,textStyleToCSS,textureBit,textureBitGl,tilingBit,tilingBitGl,toLocalGlobalMixin,transformVertices,triangulateWithHoles,uniformBufferParsers,uniformParsers,unpremultiplyAlpha,updateLayerGroupTransforms,updateLayerTransform,updateLocalTransform,updateQuadBounds,updateTransformAndChildren,updateTransformBackwards,updateWorldTransform,v8_0_0,validFormats,validateRenderables,o$d as vertexGPUTemplate,t$3 as vertexGlTemplate,viewportFromFrame,vkFormatToGPUFormat,warn,webworkerExt,wrapModeToGlAddress,xmlBitmapFontLoader};
//# sourceMappingURL=pixi.min.mjs.map
